# üìã Code Review Report

**Commit Range:** `ca959ab71539b277af5f9880e6a4c5779e135cad` ‚Üí `82120869afaca1dee5da0c92c3ca871c451d7dfa`
**Paths:** `rs/node_rewards/canister`, `rs/node_rewards`, `rs/registry/node_provider_rewards`
**Generated:** 2025-10-18 20:33:52

## üìä Summary

| Metric | Value |
|--------|-------|
| **Total Commits** | 14 |
| **Files Changed** | 53 |
| **Lines Added** | 0 |
| **Lines Removed** | 0 |

## üìù Commits

| Hash | Message | Author | Date |
|------|---------|--------|------|
| `46e8847699a9d2eba30bb47872b977e083f9d385` | chore(node-rewards-canister): RecurringSyncTask for updating registry and node metrics (#7239) | pietrodimarco-dfinity | 2025-10-15 |
| `0987d0ef4394c7934186a042046d297ee7b6242d` | chore(node-rewards-canister): Address pending TODOs (#7222) | pietrodimarco-dfinity | 2025-10-14 |
| `55d5612325bfea80a32845c0eec023ed58c4d173` | feat(node-rewards-canister): Compute rewards over single day for all node providers (#7071) | pietrodimarco-dfinity | 2025-10-13 |
| `2851d16acbe87159f58348a9c9f4e10f34f488b9` | fix(node-rewards-canister): Discard DayUtc type in favor of NaiveDate (#6981) | pietrodimarco-dfinity | 2025-09-30 |
| `d161192b1376423686e5a826b7affb0da7bc868c` | chore(ICP_Ledger): FI-1845: Remove ICP ledger notify-method feature (#6717) | Mathias Bj√∂rkqvist | 2025-09-26 |
| `ef7cd8fdf88c3fae338854a378cf284522d8357c` | fix(node-rewards-canister): Consolidate DayUtc type (#6853) | pietrodimarco-dfinity | 2025-09-25 |
| `2f56f172a1ea9dfac0c2fc6889454c38bb88ff57` | chore: bump rust to 1.89 (#6758) | Nikola Milosavljevic | 2025-09-24 |
| `626ccf507254cc6b72ae126ae4d7f7ba22b52406` | chore(nns): Release notes (#6641) | pietrodimarco-dfinity | 2025-09-16 |
| `ed7dbb0a280cf0e25b712b651a05997d3ce24f92` | feat(NRC): Refactor NRC to compute daily rewards (#6730) | pietrodimarco-dfinity | 2025-09-15 |
| `b9221277cd5e0dc9a2cd5af5ed7ddc9aff10e7a3` | chore: bumping edition to 2024 (#6715) | Nikola Milosavljevic | 2025-09-12 |
| `0226e886d73fa5396d39d71d297e2527cb8cb43f` | feat(NRC): Refactor rewards calculator to compute daily rewards (#6724) | pietrodimarco-dfinity | 2025-09-12 |
| `861616d46ded00091fecbfe01f441b38b56b483c` | fix(NRC): Remove API types from proto (#6693) | pietrodimarco-dfinity | 2025-09-11 |
| `c4bf3da835f3407818b706cf2f7ae4485c7e032f` | chore(PocketIC): replace EmptyConfig by better readable enumerations (#6630) | mraszyk | 2025-09-10 |
| `db65a720ff4db47302d04d426e9abc414e73774b` | chore(nns): Release notes (#6532) | pietrodimarco-dfinity | 2025-09-06 |

## üìÅ Files Changed

- `rs/node_rewards/canister/BUILD.bazel`
- `rs/node_rewards/canister/CHANGELOG.md`
- `rs/node_rewards/canister/Cargo.toml`
- `rs/node_rewards/canister/api/BUILD.bazel`
- `rs/node_rewards/canister/api/Cargo.toml`
- `rs/node_rewards/canister/api/src/api_native_conversion.rs`
- `rs/node_rewards/canister/api/src/lib.rs`
- `rs/node_rewards/canister/api/src/provider_rewards_calculation.rs`
- `rs/node_rewards/canister/api/src/providers_rewards.rs`
- `rs/node_rewards/canister/node-rewards-canister.did`
- `rs/node_rewards/canister/proto/rewards_calculator/pb/v1/types.proto`
- `rs/node_rewards/canister/protobuf/BUILD.bazel`
- `rs/node_rewards/canister/protobuf/Cargo.toml`
- `rs/node_rewards/canister/protobuf/src/conversions.rs`
- `rs/node_rewards/canister/protobuf/src/gen/rewards_calculator.pb.v1.rs`
- `rs/node_rewards/canister/protobuf/src/lib.rs`
- `rs/node_rewards/canister/protobuf/src/pb/ic_node_rewards/mod.rs`
- `rs/node_rewards/canister/protobuf/src/pb/mod.rs`
- `rs/node_rewards/canister/protobuf/src/pb/rewards_calculator/mod.rs`
- `rs/node_rewards/canister/protobuf_generator/src/lib.rs`
- `rs/node_rewards/canister/protobuf_generator/src/main.rs`
- `rs/node_rewards/canister/src/canister/mod.rs`
- `rs/node_rewards/canister/src/canister/test/get_node_providers_monthly_xdr_rewards.rs`
- `rs/node_rewards/canister/src/canister/test/get_node_providers_rewards.rs`
- `rs/node_rewards/canister/src/canister/test/sync_all.rs`
- `rs/node_rewards/canister/src/canister/test/test_utils.rs`
- `rs/node_rewards/canister/src/chrono_utils.rs`
- `rs/node_rewards/canister/src/gen/ic_node_rewards.pb.v1.rs`
- `rs/node_rewards/canister/src/lib.rs`
- `rs/node_rewards/canister/src/main.rs`
- `rs/node_rewards/canister/src/metrics.rs`
- `rs/node_rewards/canister/src/metrics/tests.rs`
- `rs/node_rewards/canister/src/pb/mod.rs`
- `rs/node_rewards/canister/src/registry_querier.rs`
- `rs/node_rewards/canister/src/registry_querier/tests.rs`
- `rs/node_rewards/canister/src/storage.rs`
- `rs/node_rewards/canister/src/telemetry.rs`
- `rs/node_rewards/canister/src/timer_tasks.rs`
- `rs/node_rewards/canister/tests/get_node_providers_monthly_xdr_rewards.rs`
- `rs/node_rewards/canister/tests/regisry_sync_test.rs`
- `rs/node_rewards/rewards_calculation/BUILD.bazel`
- `rs/node_rewards/rewards_calculation/Cargo.toml`
- `rs/node_rewards/rewards_calculation/src/lib.rs`
- `rs/node_rewards/rewards_calculation/src/performance_based_algorithm/mod.rs`
- `rs/node_rewards/rewards_calculation/src/performance_based_algorithm/results.rs`
- `rs/node_rewards/rewards_calculation/src/performance_based_algorithm/test_utils.rs`
- `rs/node_rewards/rewards_calculation/src/performance_based_algorithm/v1.rs`
- `rs/node_rewards/rewards_calculation/src/rewards_calculator/mod.rs`
- `rs/node_rewards/rewards_calculation/src/rewards_calculator/tests.rs`
- `rs/node_rewards/rewards_calculation/src/rewards_calculator_results.rs`
- `rs/node_rewards/rewards_calculation/src/types.rs`
- `rs/registry/node_provider_rewards/src/lib.rs`
- `rs/registry/node_provider_rewards/src/logs.rs`

## üîç Detailed Changes

### Commit `46e8847699a9d2eba30bb47872b977e083f9d385`

**Author:** pietrodimarco-dfinity <124565147+pietrodimarco-dfinity@users.noreply.github.com>  
**Date:** 2025-10-15  
**Message:** chore(node-rewards-canister): RecurringSyncTask for updating registry and node metrics (#7239)

**Files Changed:**
- `rs/node_rewards/canister/BUILD.bazel`
- `rs/node_rewards/canister/Cargo.toml`
- `rs/node_rewards/canister/src/canister/mod.rs`
- `rs/node_rewards/canister/src/canister/test/get_node_providers_rewards.rs`
- `rs/node_rewards/canister/src/canister/test/sync_all.rs`
- `rs/node_rewards/canister/src/canister/test/test_utils.rs`
- `rs/node_rewards/canister/src/lib.rs`
- `rs/node_rewards/canister/src/main.rs`
- `rs/node_rewards/canister/src/metrics.rs`
- `rs/node_rewards/canister/src/metrics/tests.rs`
- `rs/node_rewards/canister/src/storage.rs`
- `rs/node_rewards/canister/src/timer_tasks.rs`
- `rs/node_rewards/canister/tests/get_node_providers_monthly_xdr_rewards.rs`
- `rs/node_rewards/canister/tests/regisry_sync_test.rs`

**Code Changes:**

```diff
commit 46e8847699a9d2eba30bb47872b977e083f9d385
Author: pietrodimarco-dfinity <124565147+pietrodimarco-dfinity@users.noreply.github.com>
Date:   Wed Oct 15 09:11:56 2025 +0200

    chore(node-rewards-canister): RecurringSyncTask for updating registry and node metrics (#7239)
    
    Changes:
    
    - Syncing registry and metrics with RecurringSyncTask instead of custom
    implementation
    - Timer syncs registry and metrics every hr + 5 min (to fetch asap
    metrics for yesterday)
    - Simplified metrics syncing: Metrics manager does not handle retries
    but relies on timer
    - Added `last_day_synced` check to prevent computing rewards in case of
    missing metrics

diff --git a/rs/node_rewards/canister/BUILD.bazel b/rs/node_rewards/canister/BUILD.bazel
index 0e5213753b..0c8cddbb19 100644
--- a/rs/node_rewards/canister/BUILD.bazel
+++ b/rs/node_rewards/canister/BUILD.bazel
@@ -9,6 +9,7 @@ DEPENDENCIES = [
     "//rs/interfaces/registry",
     "//rs/nervous_system/canisters",
     "//rs/nervous_system/common",
+    "//rs/nervous_system/timer_task",
     "//rs/nns/constants",
     "//rs/node_rewards/canister/api",
     "//rs/node_rewards/rewards_calculation",
diff --git a/rs/node_rewards/canister/Cargo.toml b/rs/node_rewards/canister/Cargo.toml
index 68435759ce..784e76ca25 100644
--- a/rs/node_rewards/canister/Cargo.toml
+++ b/rs/node_rewards/canister/Cargo.toml
@@ -24,6 +24,7 @@ ic-management-canister-types = { workspace = true }
 ic-metrics-encoder = "1.1.1"
 ic-nervous-system-canisters = { path = "../../nervous_system/canisters" }
 ic-nervous-system-common = { path = "../../nervous_system/common" }
+ic-nervous-system-timer-task = { path = "../../nervous_system/timer_task" }
 ic-nns-constants = { path = "../../nns/constants" }
 ic-node-rewards-canister-api = { path = "./api" }
 ic-registry-canister-client = { path = "../../registry/canister-client" }
diff --git a/rs/node_rewards/canister/src/canister/mod.rs b/rs/node_rewards/canister/src/canister/mod.rs
index f8f23e02d2..6377f80946 100644
--- a/rs/node_rewards/canister/src/canister/mod.rs
+++ b/rs/node_rewards/canister/src/canister/mod.rs
@@ -1,10 +1,9 @@
 use crate::chrono_utils::last_unix_timestamp_nanoseconds;
 use crate::metrics::MetricsManager;
 use crate::registry_querier::RegistryQuerier;
-use crate::storage::VM;
+use crate::storage::{NaiveDateStorable, VM};
 use chrono::{DateTime, NaiveDate};
 use ic_base_types::{PrincipalId, SubnetId};
-use ic_interfaces_registry::ZERO_REGISTRY_VERSION;
 use ic_node_rewards_canister_api::monthly_rewards::{
     GetNodeProvidersMonthlyXdrRewardsRequest, GetNodeProvidersMonthlyXdrRewardsResponse,
     NodeProvidersMonthlyXdrRewards,
@@ -24,12 +23,13 @@ use ic_registry_keys::{
     DATA_CENTER_KEY_PREFIX, NODE_OPERATOR_RECORD_KEY_PREFIX, NODE_REWARDS_TABLE_KEY,
 };
 use ic_registry_node_provider_rewards::{RewardsPerNodeProvider, calculate_rewards_v0};
+use ic_stable_structures::StableCell;
 use ic_types::{RegistryVersion, Time};
 use rewards_calculation::performance_based_algorithm::results::RewardsCalculatorResults;
 use rewards_calculation::performance_based_algorithm::v1::RewardsCalculationV1;
 use rewards_calculation::types::{NodeMetricsDailyRaw, RewardableNode};
 use std::cell::RefCell;
-use std::collections::{BTreeMap, HashSet};
+use std::collections::BTreeMap;
 use std::rc::Rc;
 use std::sync::Arc;
 use std::thread::LocalKey;
@@ -38,13 +38,13 @@ use std::thread::LocalKey;
 mod test;
 
 #[cfg(target_arch = "wasm32")]
-fn current_time() -> Time {
+pub fn current_time() -> Time {
     let current_time = ic_cdk::api::time();
     Time::from_nanos_since_unix_epoch(current_time)
 }
 
 #[cfg(not(any(target_arch = "wasm32")))]
-fn current_time() -> Time {
+pub fn current_time() -> Time {
     ic_types::time::current_time()
 }
 
@@ -54,7 +54,7 @@ fn current_time() -> Time {
 pub struct NodeRewardsCanister {
     registry_client: Arc<dyn CanisterRegistryClient>,
     metrics_manager: Rc<MetricsManager<VM>>,
-    last_metrics_update: RegistryVersion,
+    last_day_synced: &'static LocalKey<RefCell<StableCell<Option<NaiveDateStorable>, VM>>>,
 }
 
 /// Internal methods
@@ -62,11 +62,12 @@ impl NodeRewardsCanister {
     pub fn new(
         registry_client: Arc<dyn CanisterRegistryClient>,
         metrics_manager: Rc<MetricsManager<VM>>,
+        last_day_synced: &'static LocalKey<RefCell<StableCell<Option<NaiveDateStorable>, VM>>>,
     ) -> Self {
         Self {
-            last_metrics_update: registry_client.get_latest_version(),
             registry_client,
             metrics_manager,
+            last_day_synced,
         }
     }
 
@@ -87,6 +88,18 @@ impl NodeRewardsCanister {
             .map_err(|e| format!("Failed to get registry value: {:?}", e))
     }
 
+    pub fn get_last_day_synced(&self) -> Option<NaiveDate> {
+        self.last_day_synced
+            .with_borrow(|last_day_synced| last_day_synced.get().clone().map(|d| d.0))
+    }
+
+    pub fn set_last_day_synced(&self, last_day_synced: NaiveDate) {
+        self.last_day_synced.with_borrow_mut(|cell| {
+            cell.set(Some(NaiveDateStorable(last_day_synced)))
+                .expect("Could not set last day synced");
+        });
+    }
+
     pub async fn schedule_registry_sync(
         canister: &'static LocalKey<RefCell<NodeRewardsCanister>>,
     ) -> Result<RegistryVersion, String> {
@@ -95,50 +108,52 @@ impl NodeRewardsCanister {
         registry_client.sync_registry_stored().await
     }
 
-    pub async fn schedule_metrics_sync(canister: &'static LocalKey<RefCell<NodeRewardsCanister>>) {
-        let (registry_client, metrics_manager, pre_sync_version) = canister.with(|canister| {
+    pub async fn schedule_metrics_sync(
+        canister: &'static LocalKey<RefCell<NodeRewardsCanister>>,
+    ) -> Result<(), String> {
+        let (registry_client, metrics_manager) = canister.with(|canister| {
             (
                 canister.borrow().get_registry_client(),
                 canister.borrow().get_metrics_manager(),
-                canister.borrow().last_metrics_update,
             )
         });
-        let post_sync_version = registry_client.get_latest_version();
         let registry_querier = RegistryQuerier::new(registry_client.clone());
+        let version = registry_client.get_latest_version();
+        let subnets_list = registry_querier.subnets_list(version);
+        let last_day_synced: NaiveDate =
+            metrics_manager.update_subnets_metrics(subnets_list).await?;
+        canister.with_borrow(|canister| {
+            canister.set_last_day_synced(last_day_synced);
+        });
 
-        let mut subnets_list: HashSet<SubnetId> = HashSet::default();
-        let mut version = if pre_sync_version == ZERO_REGISTRY_VERSION {
-            // If the pre-sync version is 0, we consider all subnets from the post-sync version
-            post_sync_version
-        } else {
-            pre_sync_version
-        };
-        while version <= post_sync_version {
-            subnets_list.extend(registry_querier.subnets_list(version));
+        Ok(())
+    }
 
-            // Increment the version to sync the next one
-            version = version.increment();
+    fn validate_reward_period(
+        &self,
+        from_date: &NaiveDate,
+        to_date: &NaiveDate,
+    ) -> Result<(), String> {
+        let last_day_synced = self
+            .get_last_day_synced()
+            .ok_or("Metrics and registry are not synced up")?;
+
+        if last_day_synced < *to_date {
+            return Err("Metrics and registry are not synced up to to_date".to_string());
         }
 
-        metrics_manager
-            .update_subnets_metrics(subnets_list.into_iter().collect())
-            .await;
-        metrics_manager.retry_failed_subnets().await;
-        canister.with_borrow_mut(|canister| {
-            canister.last_metrics_update = post_sync_version;
-        });
-    }
+        if from_date > to_date {
+            return Err("from_date must be before to_date".to_string());
+        }
 
-    fn validate_reward_period(from_date: &NaiveDate, to_date: &NaiveDate) -> Result<(), String> {
         let today =
             DateTime::from_timestamp_nanos(current_time().as_nanos_since_unix_epoch() as i64)
                 .date_naive();
-        if from_date > to_date {
-            return Err("from_date must be before to_date".to_string());
-        }
+
         if to_date >= &today {
             return Err("to_date must be earlier than today".to_string());
         }
+
         Ok(())
     }
 
@@ -148,7 +163,7 @@ impl NodeRewardsCanister {
     ) -> Result<RewardsCalculatorResults, String> {
         let start_day = NaiveDate::try_from(request.from_day)?;
         let end_day = NaiveDate::try_from(request.to_day)?;
-        Self::validate_reward_period(&start_day, &end_day)?;
+        self.validate_reward_period(&start_day, &end_day)?;
 
         RewardsCalculationV1::calculate_rewards(&start_day, &end_day, self)
             .map_err(|e| format!("Could not calculate rewards: {e:?}"))
@@ -262,20 +277,10 @@ impl NodeRewardsCanister {
         }
     }
 
-    pub async fn get_node_providers_rewards(
+    pub fn get_node_providers_rewards(
         canister: &'static LocalKey<RefCell<NodeRewardsCanister>>,
         request: GetNodeProvidersRewardsRequest,
     ) -> GetNodeProvidersRewardsResponse {
-        NodeRewardsCanister::schedule_registry_sync(canister)
-            .await
-            .map_err(|e| {
-                format!(
-                    "Could not sync registry store to latest version, \
-                    please try again later: {:?}",
-                    e
-                )
-            })?;
-        NodeRewardsCanister::schedule_metrics_sync(canister).await;
         let result = canister.with_borrow(|canister| canister.calculate_rewards(request))?;
 
         let rewards_xdr_permyriad = result
diff --git a/rs/node_rewards/canister/src/canister/test/get_node_providers_rewards.rs b/rs/node_rewards/canister/src/canister/test/get_node_providers_rewards.rs
index d24a62132c..27f3eaed95 100644
--- a/rs/node_rewards/canister/src/canister/test/get_node_providers_rewards.rs
+++ b/rs/node_rewards/canister/src/canister/test/get_node_providers_rewards.rs
@@ -1,8 +1,11 @@
 use crate::canister::NodeRewardsCanister;
-use crate::canister::test::test_utils::{CANISTER_TEST, VM, setup_thread_local_canister_for_test};
+use crate::canister::test::test_utils::{
+    CANISTER_TEST, LAST_DAY_SYNCED, VM, setup_thread_local_canister_for_test,
+};
 use crate::chrono_utils::{last_unix_timestamp_nanoseconds, to_native_date};
 use crate::metrics::MetricsManager;
 use crate::pb::v1::{NodeMetrics, SubnetMetricsKey, SubnetMetricsValue};
+use crate::storage::NaiveDateStorable;
 use futures_util::FutureExt;
 use ic_nervous_system_canisters::registry::fake::FakeRegistry;
 use ic_node_rewards_canister_api::providers_rewards::{
@@ -299,6 +302,7 @@ fn setup_data_for_test_rewards_calculation(
             }],
         },
     );
+    LAST_DAY_SYNCED.with_borrow_mut(|cell| cell.set(Some(NaiveDateStorable(day2))).unwrap());
 }
 
 #[test]
@@ -308,7 +312,6 @@ fn test_get_node_providers_rewards() {
     let (fake_registry, metrics_manager) = setup_thread_local_canister_for_test();
     setup_data_for_test_rewards_calculation(fake_registry, metrics_manager);
     NodeRewardsCanister::schedule_registry_sync(&CANISTER_TEST).now_or_never();
-    NodeRewardsCanister::schedule_metrics_sync(&CANISTER_TEST).now_or_never();
     let from = to_native_date("2024-01-01");
     let to = to_native_date("2024-01-02");
 
@@ -317,9 +320,7 @@ fn test_get_node_providers_rewards() {
         to_day: to.into(),
     };
     let result_endpoint =
-        NodeRewardsCanister::get_node_providers_rewards(&CANISTER_TEST, request.clone())
-            .now_or_never()
-            .unwrap();
+        NodeRewardsCanister::get_node_providers_rewards(&CANISTER_TEST, request.clone());
 
     let expected = NodeProvidersRewards {
         rewards_xdr_permyriad: btreemap! {
diff --git a/rs/node_rewards/canister/src/canister/test/sync_all.rs b/rs/node_rewards/canister/src/canister/test/sync_all.rs
index ba53d290a5..385c8bce20 100644
--- a/rs/node_rewards/canister/src/canister/test/sync_all.rs
+++ b/rs/node_rewards/canister/src/canister/test/sync_all.rs
@@ -38,6 +38,7 @@ fn sync_all() {
         .unwrap();
     NodeRewardsCanister::schedule_metrics_sync(&CANISTER_TEST)
         .now_or_never()
+        .unwrap()
         .unwrap();
 }
 
@@ -94,14 +95,15 @@ fn test_sync_non_zero_registry_version() {
         subnet_id(8),
         subnet_id(9),
     ];
-    add_subnet_list(fake_registry.clone(), subnets_second_sync[..3].to_vec());
-    add_subnet_list(fake_registry.clone(), subnets_second_sync[3..].to_vec());
+    add_subnet_list(fake_registry.clone(), subnets_second_sync.clone());
     sync_all();
 
     let registry_client = CANISTER_TEST.with_borrow(|canister| canister.get_registry_client());
     let metrics_manager = CANISTER_TEST.with_borrow(|canister| canister.get_metrics_manager());
 
-    let expected_version = RegistryVersion::from(3);
+    let expected_version = RegistryVersion::from(2);
+    assert_eq!(expected_version, registry_client.get_latest_version());
+
     // From NON ZERO_REGISTRY_VERSION, we expect all subnets to be synced.
     let expected_subnets: Vec<SubnetId> = subnets_first_sync
         .into_iter()
@@ -114,6 +116,5 @@ fn test_sync_non_zero_registry_version() {
         .map(|(k, _)| k.subnet_id.unwrap().into())
         .collect::<Vec<_>>();
 
-    assert_eq!(expected_version, registry_client.get_latest_version());
     assert_eq!(expected_subnets, got_subnets);
 }
diff --git a/rs/node_rewards/canister/src/canister/test/test_utils.rs b/rs/node_rewards/canister/src/canister/test/test_utils.rs
index 248313de41..d2fc2470c5 100644
--- a/rs/node_rewards/canister/src/canister/test/test_utils.rs
+++ b/rs/node_rewards/canister/src/canister/test/test_utils.rs
@@ -1,7 +1,7 @@
 #![allow(deprecated)]
 use crate::canister::NodeRewardsCanister;
 use crate::metrics::MetricsManager;
-use crate::storage::METRICS_MANAGER;
+use crate::storage::{METRICS_MANAGER, NaiveDateStorable};
 use ic_cdk::api::call::CallResult;
 use ic_management_canister_types::NodeMetricsHistoryRecord;
 use ic_nervous_system_canisters::registry::fake::FakeRegistry;
@@ -11,7 +11,7 @@ use ic_registry_canister_client::{
     test_registry_data_stable_memory_impl,
 };
 use ic_stable_structures::memory_manager::{MemoryId, MemoryManager, VirtualMemory};
-use ic_stable_structures::{DefaultMemoryImpl, StableBTreeMap};
+use ic_stable_structures::{DefaultMemoryImpl, StableBTreeMap, StableCell};
 use std::cell::RefCell;
 use std::rc::Rc;
 use std::sync::Arc;
@@ -23,12 +23,18 @@ thread_local! {
         let mgr = MemoryManager::init(DefaultMemoryImpl::default());
         StableBTreeMap::init(mgr.get(MemoryId::new(0)))
     });
+
+    pub static LAST_DAY_SYNCED: RefCell<StableCell<Option<NaiveDateStorable>, VM>> = RefCell::new({
+        let mgr = MemoryManager::init(DefaultMemoryImpl::default());
+        StableCell::init(mgr.get(MemoryId::new(1)), None).expect("Could not initialize last_day_synced")
+    });
+
     // Dummy value b/c we can't do direct assignment using values defined above.
     pub(crate) static CANISTER_TEST: RefCell<NodeRewardsCanister> = {
         let registry_store = Arc::new(StableCanisterRegistryClient::<TestState>::new(Arc::new(FakeRegistry::default())));
         let metrics_manager = METRICS_MANAGER.with(|m| m.clone());
 
-        RefCell::new(NodeRewardsCanister::new(registry_store, metrics_manager))
+        RefCell::new(NodeRewardsCanister::new(registry_store, metrics_manager, &LAST_DAY_SYNCED))
     };
 }
 
@@ -50,6 +56,7 @@ pub(crate) fn setup_thread_local_canister_for_test() -> (Arc<FakeRegistry>, Rc<M
         ))
         .clone(),
         metrics_manager.clone(),
+        &LAST_DAY_SYNCED,
     );
     CANISTER_TEST.with_borrow_mut(|c| *c = canister);
     (fake_registry, metrics_manager)
diff --git a/rs/node_rewards/canister/src/lib.rs b/rs/node_rewards/canister/src/lib.rs
index a1161a5093..a7d9af7516 100644
--- a/rs/node_rewards/canister/src/lib.rs
+++ b/rs/node_rewards/canister/src/lib.rs
@@ -5,7 +5,9 @@
 // 4. Structure makes boundaries clear and easy to enforce
 // 5. Simple Organization
 
+use crate::storage::NaiveDateStorable;
 use candid::Principal;
+use chrono::{Datelike, NaiveDate};
 use ic_base_types::{PrincipalId, SubnetId};
 use ic_management_canister_types::NodeMetrics;
 use ic_stable_structures::Storable;
@@ -20,6 +22,7 @@ pub mod pb;
 pub mod registry_querier;
 pub mod storage;
 pub mod telemetry;
+pub mod timer_tasks;
 
 // Maximum sizes for the storable types chosen as result of test `max_bound_size`
 const MAX_BYTES_SUBNET_ID_STORED: u32 = 33;
@@ -54,6 +57,28 @@ impl KeyRange for pb::v1::SubnetMetricsKey {
 
 //------------ Storable Implementations ------------//
 
+impl Storable for NaiveDateStorable {
+    fn to_bytes(&self) -> Cow<'_, [u8]> {
+        // We'll store it as a 32-bit integer: number of days since a fixed epoch.
+        // NaiveDate stores dates internally as (year, ordinal_day), but we can easily
+        // reconstruct it from a serializable integer.
+        let days = self.0.num_days_from_ce();
+        Cow::Owned(days.to_be_bytes().to_vec())
+    }
+
+    fn from_bytes(bytes: Cow<[u8]>) -> Self {
+        let mut arr = [0u8; 4];
+        arr.copy_from_slice(&bytes);
+        let days = i32::from_be_bytes(arr);
+        Self(NaiveDate::from_num_days_from_ce_opt(days).unwrap())
+    }
+
+    const BOUND: Bound = Bound::Bounded {
+        max_size: 4,
+        is_fixed_size: true,
+    };
+}
+
 impl Storable for pb::v1::SubnetIdKey {
     fn to_bytes(&self) -> std::borrow::Cow<'_, [u8]> {
         Cow::Owned(self.encode_to_vec())
diff --git a/rs/node_rewards/canister/src/main.rs b/rs/node_rewards/canister/src/main.rs
index 7b9de699a8..47345c2b4a 100644
--- a/rs/node_rewards/canister/src/main.rs
+++ b/rs/node_rewards/canister/src/main.rs
@@ -1,10 +1,13 @@
 use ic_cdk::api::in_replicated_execution;
 use ic_cdk::{init, post_upgrade, pre_upgrade, query, update};
 use ic_nervous_system_canisters::registry::RegistryCanister;
+use ic_nervous_system_timer_task::{RecurringSyncTask, TimerTaskMetricsRegistry};
 use ic_nns_constants::GOVERNANCE_CANISTER_ID;
 use ic_node_rewards_canister::canister::NodeRewardsCanister;
-use ic_node_rewards_canister::storage::{METRICS_MANAGER, RegistryStoreStableMemoryBorrower};
-use ic_node_rewards_canister::telemetry;
+use ic_node_rewards_canister::storage::{
+    LAST_DAY_SYNCED, METRICS_MANAGER, RegistryStoreStableMemoryBorrower,
+};
+use ic_node_rewards_canister::timer_tasks::HourlySyncTask;
 use ic_node_rewards_canister_api::monthly_rewards::{
     GetNodeProvidersMonthlyXdrRewardsRequest, GetNodeProvidersMonthlyXdrRewardsResponse,
 };
@@ -17,7 +20,6 @@ use ic_node_rewards_canister_api::providers_rewards::{
 use ic_registry_canister_client::StableCanisterRegistryClient;
 use std::cell::RefCell;
 use std::sync::Arc;
-use std::time::Duration;
 
 fn main() {}
 
@@ -33,8 +35,10 @@ thread_local! {
         });
         let metrics_manager = METRICS_MANAGER.with(|m| m.clone());
 
-        RefCell::new(NodeRewardsCanister::new(registry_store, metrics_manager))
+        RefCell::new(NodeRewardsCanister::new(registry_store, metrics_manager, &LAST_DAY_SYNCED))
     };
+
+    static METRICS_REGISTRY: RefCell<TimerTaskMetricsRegistry> = RefCell::new(TimerTaskMetricsRegistry::default());
 }
 
 #[init]
@@ -50,42 +54,8 @@ fn post_upgrade() {
     schedule_timers();
 }
 
-// The frequency of regular registry syncs.  This is set to 1 hour to avoid
-// making too many requests.  Before meaningful calculations are made, however, the
-// registry data should be updated.
-const SYNC_INTERVAL_SECONDS: Duration = Duration::from_secs(60 * 60); // 1 hour
-
-fn schedule_timers() {
-    ic_cdk_timers::set_timer_interval(SYNC_INTERVAL_SECONDS, move || {
-        ic_cdk::futures::spawn_017_compat(async move {
-            telemetry::PROMETHEUS_METRICS.with_borrow_mut(|m| m.mark_last_sync_start());
-            let mut instruction_counter = telemetry::InstructionCounter::default();
-            instruction_counter.lap();
-            let registry_sync_result = NodeRewardsCanister::schedule_registry_sync(&CANISTER).await;
-            let registry_sync_instructions = instruction_counter.lap();
-
-            let mut metrics_sync_instructions: u64 = 0;
-            match registry_sync_result {
-                Ok(_) => {
-                    instruction_counter.lap();
-                    NodeRewardsCanister::schedule_metrics_sync(&CANISTER).await;
-                    metrics_sync_instructions = instruction_counter.lap();
-                    ic_cdk::println!("Successfully synced subnets metrics and local registry");
-                }
-                Err(e) => {
-                    ic_cdk::println!("Failed to sync local registry: {:?}", e)
-                }
-            }
-
-            telemetry::PROMETHEUS_METRICS.with_borrow_mut(|m| {
-                m.record_last_sync_instructions(
-                    instruction_counter.sum(),
-                    registry_sync_instructions,
-                    metrics_sync_instructions,
-                )
-            });
-        });
-    });
+pub fn schedule_timers() {
+    HourlySyncTask::new(&CANISTER).schedule(&METRICS_REGISTRY);
 }
 
 fn panic_if_caller_not_governance() {
@@ -109,11 +79,11 @@ async fn get_node_providers_monthly_xdr_rewards(
 }
 
 #[update]
-async fn get_node_providers_rewards(
+fn get_node_providers_rewards(
     request: GetNodeProvidersRewardsRequest,
 ) -> GetNodeProvidersRewardsResponse {
     panic_if_caller_not_governance();
-    NodeRewardsCanister::get_node_providers_rewards(&CANISTER, request).await
+    NodeRewardsCanister::get_node_providers_rewards(&CANISTER, request)
 }
 
 #[query]
diff --git a/rs/node_rewards/canister/src/metrics.rs b/rs/node_rewards/canister/src/metrics.rs
index 28b03e43ca..856be90a5e 100644
--- a/rs/node_rewards/canister/src/metrics.rs
+++ b/rs/node_rewards/canister/src/metrics.rs
@@ -53,7 +53,6 @@ where
     pub(crate) client: Box<dyn ManagementCanisterClient>,
     pub(crate) subnets_metrics:
         RefCell<StableBTreeMap<SubnetMetricsKey, SubnetMetricsValue, Memory>>,
-    pub(crate) subnets_to_retry: RefCell<StableBTreeMap<SubnetIdKey, RetryCount, Memory>>,
     pub(crate) last_timestamp_per_subnet: RefCell<StableBTreeMap<SubnetIdKey, UnixTsNanos, Memory>>,
 }
 
@@ -61,38 +60,21 @@ impl<Memory> MetricsManager<Memory>
 where
     Memory: ic_stable_structures::Memory + 'static,
 {
-    pub async fn retry_failed_subnets(&self) {
-        let subnets_to_retry: Vec<SubnetId> = self
-            .subnets_to_retry
-            .borrow()
-            .keys()
-            .map(|key| key.into())
-            .collect();
-
-        if !subnets_to_retry.is_empty() {
-            ic_cdk::println!("Retrying metrics for subnets: {:?}", subnets_to_retry);
-            self.update_subnets_metrics(subnets_to_retry).await;
-        }
-    }
-
     /// Fetches subnets metrics for the specified subnets from their last stored timestamp.
     async fn fetch_subnets_metrics(
         &self,
-        last_timestamp_per_subnet: &BTreeMap<SubnetId, Option<UnixTsNanos>>,
+        last_timestamp_per_subnet: &BTreeMap<SubnetId, UnixTsNanos>,
     ) -> BTreeMap<SubnetId, CallResult<Vec<NodeMetricsHistoryRecord>>> {
         let mut subnets_history = Vec::new();
+        ic_cdk::println!(
+            "Updating node metrics for {} subnets",
+            last_timestamp_per_subnet.keys().count()
+        );
 
         for (subnet_id, last_stored_ts) in last_timestamp_per_subnet {
-            let refresh_ts = last_stored_ts.unwrap_or_default();
-            ic_cdk::println!(
-                "Updating node metrics for subnet {}: Refreshing metrics from timestamp {}",
-                subnet_id,
-                refresh_ts
-            );
-
             let args = NodeMetricsHistoryArgs {
                 subnet_id: subnet_id.get().0,
-                start_at_timestamp_nanos: refresh_ts,
+                start_at_timestamp_nanos: *last_stored_ts,
             };
 
             subnets_history
@@ -105,20 +87,33 @@ where
             .collect()
     }
 
-    /// Updates the stored subnets metrics from remote management canisters.
-    ///
-    /// This function fetches the nodes metrics for the given subnets from the management canisters
-    /// updating the local metrics with the fetched metrics.
-    pub async fn update_subnets_metrics(&self, subnets: Vec<SubnetId>) {
-        let last_timestamp_per_subnet: BTreeMap<SubnetId, _> = subnets
+    fn last_timestamp_per_subnet(&self, subnets: Vec<SubnetId>) -> BTreeMap<SubnetId, UnixTsNanos> {
+        subnets
             .into_iter()
             .map(|subnet| {
-                let last_timestamp = self.last_timestamp_per_subnet.borrow().get(&subnet.into());
+                let last_timestamp = self
+                    .last_timestamp_per_subnet
+                    .borrow()
+                    .get(&subnet.into())
+                    .unwrap_or_default();
 
                 (subnet, last_timestamp)
             })
-            .collect();
+            .collect()
+    }
 
+    /// Updates the stored subnets metrics from remote management canisters.
+    ///
+    /// This function fetches the nodes metrics for the given subnets from the management canisters
+    /// updating the local metrics with the fetched metrics.
+    /// If all subnets metrics are fetched successfully, it returns the last date
+    /// for which metrics were updated.
+    pub async fn update_subnets_metrics(
+        &self,
+        subnets: Vec<SubnetId>,
+    ) -> Result<NaiveDate, String> {
+        let mut success = true;
+        let last_timestamp_per_subnet = self.last_timestamp_per_subnet(subnets.clone());
         let subnets_metrics = self.fetch_subnets_metrics(&last_timestamp_per_subnet).await;
         for (subnet_id, call_result) in subnets_metrics {
             match call_result {
@@ -154,30 +149,30 @@ where
                             );
                         }
                     }
-
-                    self.subnets_to_retry.borrow_mut().remove(&subnet_id.into());
                 }
                 Err((_, e)) => {
+                    success = false;
                     ic_cdk::println!(
                         "Error fetching metrics for subnet {}: ERROR: {}",
                         subnet_id,
                         e
                     );
-
-                    // The call failed, will retry fetching metrics for this subnet.
-                    let mut retry_count = self
-                        .subnets_to_retry
-                        .borrow()
-                        .get(&subnet_id.into())
-                        .unwrap_or_default();
-                    retry_count += 1;
-
-                    self.subnets_to_retry
-                        .borrow_mut()
-                        .insert(subnet_id.into(), retry_count);
                 }
             }
         }
+
+        if success {
+            let max_ts_update = self
+                .last_timestamp_per_subnet(subnets)
+                .into_values()
+                .max()
+                .unwrap_or_default();
+            let last_day_update = DateTime::from_timestamp_nanos(max_ts_update as i64).date_naive();
+
+            Ok(last_day_update)
+        } else {
+            Err("Failed to update metrics".to_string())
+        }
     }
 
     /// Computes daily node metrics for a specific date.
diff --git a/rs/node_rewards/canister/src/metrics/tests.rs b/rs/node_rewards/canister/src/metrics/tests.rs
index ff67195b52..ec29535588 100644
--- a/rs/node_rewards/canister/src/metrics/tests.rs
+++ b/rs/node_rewards/canister/src/metrics/tests.rs
@@ -41,7 +41,6 @@ impl MetricsManager<VM> {
         Self {
             client: Box::new(client),
             subnets_metrics: RefCell::new(crate::storage::stable_btreemap_init(MemoryId::new(0))),
-            subnets_to_retry: RefCell::new(crate::storage::stable_btreemap_init(MemoryId::new(1))),
             last_timestamp_per_subnet: RefCell::new(crate::storage::stable_btreemap_init(
                 MemoryId::new(2),
             )),
@@ -74,7 +73,7 @@ async fn subnet_metrics_added_correctly() {
 
     let subnet_1 = subnet_id(1);
 
-    mm.update_subnets_metrics(vec![subnet_1]).await;
+    mm.update_subnets_metrics(vec![subnet_1]).await.unwrap();
     for i in 0..days {
         let key = SubnetMetricsKey {
             timestamp_nanos: i * ONE_DAY_NANOS,
@@ -84,29 +83,6 @@ async fn subnet_metrics_added_correctly() {
     }
 }
 
-#[tokio::test]
-async fn subnets_to_retry_filled() {
-    let subnet_1 = subnet_id(1);
-    let mut mock = mock::MockCanisterClient::new();
-    mock.expect_node_metrics_history()
-        .times(1)
-        .return_const(CallResult::Err((
-            RejectionCode::Unknown,
-            "Error".to_string(),
-        )));
-    mock.expect_node_metrics_history()
-        .times(1)
-        .return_const(CallResult::Ok(node_metrics_history_gen(2)));
-
-    let mm = MetricsManager::new_test(mock);
-    mm.update_subnets_metrics(vec![subnet_1]).await;
-    assert_eq!(mm.subnets_to_retry.borrow().get(&subnet_1.into()), Some(1));
-
-    // Retry the subnet and success
-    mm.update_subnets_metrics(vec![subnet_1]).await;
-    assert_eq!(mm.subnets_to_retry.borrow().get(&subnet_1.into()), None);
-}
-
 #[tokio::test]
 async fn multiple_subnets_metrics_added_correctly() {
     let days = 30;
@@ -118,7 +94,9 @@ async fn multiple_subnets_metrics_added_correctly() {
     let subnet_1 = subnet_id(1);
     let subnet_2 = subnet_id(2);
 
-    mm.update_subnets_metrics(vec![subnet_1, subnet_2]).await;
+    mm.update_subnets_metrics(vec![subnet_1, subnet_2])
+        .await
+        .unwrap();
 
     for subnet in &[subnet_1, subnet_2] {
         for i in 0..days {
@@ -134,48 +112,6 @@ async fn multiple_subnets_metrics_added_correctly() {
     }
 }
 
-#[tokio::test]
-async fn retry_count_increments_on_failure() {
-    let mut mock = mock::MockCanisterClient::new();
-    mock.expect_node_metrics_history()
-        .return_const(CallResult::Err((
-            RejectionCode::Unknown,
-            "Temporary error".to_string(),
-        )));
-
-    let mm = MetricsManager::new_test(mock);
-    let subnet_1 = subnet_id(1);
-
-    for retry_attempt in 1..=3 {
-        mm.update_subnets_metrics(vec![subnet_1]).await;
-        assert_eq!(
-            mm.subnets_to_retry.borrow().get(&subnet_1.into()),
-            Some(retry_attempt),
-            "Retry count should be {retry_attempt}"
-        );
-    }
-}
-
-#[tokio::test]
-async fn no_metrics_added_when_call_fails() {
-    let mut mock = mock::MockCanisterClient::new();
-    let subnet_1 = subnet_id(1);
-
-    mock.expect_node_metrics_history()
-        .return_const(CallResult::Err((
-            RejectionCode::Unknown,
-            "Error".to_string(),
-        )));
-    let mm = MetricsManager::new_test(mock);
-
-    mm.update_subnets_metrics(vec![subnet_1]).await;
-
-    assert!(
-        mm.subnets_metrics.borrow().is_empty(),
-        "Metrics should be empty after a failed call"
-    );
-}
-
 #[tokio::test]
 async fn partial_failures_are_handled_correctly() {
     let subnet_1 = subnet_id(1);
@@ -191,17 +127,9 @@ async fn partial_failures_are_handled_correctly() {
 
     let mm = MetricsManager::new_test(mock);
 
-    mm.update_subnets_metrics(vec![subnet_1, subnet_2]).await;
+    let res = mm.update_subnets_metrics(vec![subnet_1, subnet_2]).await;
 
-    assert_eq!(
-        mm.subnets_to_retry.borrow().get(&subnet_1.into()),
-        Some(1),
-        "Subnet 1 should be in retry list"
-    );
-    assert!(
-        mm.subnets_to_retry.borrow().get(&subnet_2.into()).is_none(),
-        "Subnet 2 should not be in retry list"
-    );
+    assert!(res.is_err());
 
     let key = SubnetMetricsKey {
         timestamp_nanos: 0,
@@ -320,7 +248,7 @@ async fn _daily_metrics_correct_different_update_size(size: usize) {
     let mm = MetricsManager::new_test(mock);
 
     for _ in 0..MAX_TIMES {
-        mm.update_subnets_metrics(vec![subnet_id(1)]).await;
+        mm.update_subnets_metrics(vec![subnet_id(1)]).await.unwrap();
     }
     let daily_metrics: Vec<Vec<NodeMetricsDailyRaw>> =
         mm.metrics_by_subnet(&day_start).into_values().collect();
@@ -400,7 +328,9 @@ async fn daily_metrics_correct_2_subs() {
     let mm = MetricsManager::new_test(mock);
 
     for _ in 0..MAX_TIMES {
-        mm.update_subnets_metrics(vec![subnet_1, subnet_2]).await;
+        mm.update_subnets_metrics(vec![subnet_1, subnet_2])
+            .await
+            .unwrap();
     }
 
     let mut node_1_daily_metrics = Vec::new();
@@ -497,7 +427,8 @@ async fn daily_metrics_correct_overlapping_days() {
     let mm = MetricsManager::new_test(mock);
 
     for _ in 0..MAX_TIMES {
-        mm.update_subnets_metrics(vec![subnet_id(1), subnet_id(2)])
+        let _ = mm
+            .update_subnets_metrics(vec![subnet_id(1), subnet_id(2)])
             .await;
     }
 
diff --git a/rs/node_rewards/canister/src/storage.rs b/rs/node_rewards/canister/src/storage.rs
index d3ad21846c..fbd31b61fd 100644
--- a/rs/node_rewards/canister/src/storage.rs
+++ b/rs/node_rewards/canister/src/storage.rs
@@ -3,17 +3,20 @@ use ic_registry_canister_client::{
     RegistryDataStableMemory, StorableRegistryKey, StorableRegistryValue,
 };
 use ic_stable_structures::memory_manager::{MemoryId, MemoryManager, VirtualMemory};
-use ic_stable_structures::{DefaultMemoryImpl, StableBTreeMap, Storable};
+use ic_stable_structures::{DefaultMemoryImpl, StableBTreeMap, StableCell, Storable};
 use std::cell::RefCell;
 use std::rc::Rc;
 
 const REGISTRY_STORE_MEMORY_ID: MemoryId = MemoryId::new(0);
 const SUBNETS_METRICS_MEMORY_ID: MemoryId = MemoryId::new(1);
 const LAST_TIMESTAMP_PER_SUBNET_MEMORY_ID: MemoryId = MemoryId::new(2);
-const SUBNETS_TO_RETRY_MEMORY_ID: MemoryId = MemoryId::new(3);
+const LAST_DAY_SYNCED_MEMORY_ID: MemoryId = MemoryId::new(3);
 
 pub type VM = VirtualMemory<DefaultMemoryImpl>;
 
+#[derive(Clone)]
+pub struct NaiveDateStorable(pub chrono::NaiveDate);
+
 pub fn stable_btreemap_init<K: Storable + Clone + Ord, V: Storable>(
     memory_id: MemoryId,
 ) -> StableBTreeMap<K, V, VM> {
@@ -30,7 +33,6 @@ thread_local! {
     pub static METRICS_MANAGER: Rc<MetricsManager<VM>> = {
         let metrics_manager = MetricsManager {
             client: Box::new(ICCanisterClient),
-            subnets_to_retry: RefCell::new(stable_btreemap_init(SUBNETS_TO_RETRY_MEMORY_ID)),
             subnets_metrics: RefCell::new(stable_btreemap_init(SUBNETS_METRICS_MEMORY_ID)),
             last_timestamp_per_subnet: RefCell::new(stable_btreemap_init(LAST_TIMESTAMP_PER_SUBNET_MEMORY_ID)),
         };
@@ -38,6 +40,10 @@ thread_local! {
         Rc::new(metrics_manager)
     };
 
+    pub static LAST_DAY_SYNCED: RefCell<StableCell<Option<NaiveDateStorable>, VM>> = RefCell::new(MEMORY_MANAGER.with_borrow(|mm|
+            StableCell::init(mm.get(LAST_DAY_SYNCED_MEMORY_ID), None).expect("Could not initialize last_day_synced")
+        ));
+
     static REGISTRY_DATA_STORE_BTREE_MAP: RefCell<StableBTreeMap<StorableRegistryKey, StorableRegistryValue, VM>>
         = RefCell::new(MEMORY_MANAGER.with_borrow(|mm|
             StableBTreeMap::init(mm.get(REGISTRY_STORE_MEMORY_ID))
diff --git a/rs/node_rewards/canister/src/timer_tasks.rs b/rs/node_rewards/canister/src/timer_tasks.rs
new file mode 100644
index 0000000000..76ec46638e
--- /dev/null
+++ b/rs/node_rewards/canister/src/timer_tasks.rs
@@ -0,0 +1,66 @@
+use crate::canister::{NodeRewardsCanister, current_time};
+use ic_nervous_system_timer_task::RecurringSyncTask;
+use std::cell::RefCell;
+use std::thread::LocalKey;
+use std::time::Duration;
+
+const SECS_PER_HOUR: u64 = 3600;
+
+// This offset makes sure that the first sync of the day happens at 00:05, times that guarantees
+// All the subnets have collected metrics for the previous day
+const SYNC_OFFSET: u64 = 5 * 60; // 5 minutes in seconds
+
+#[derive(Copy, Clone)]
+pub struct HourlySyncTask {
+    canister: &'static LocalKey<RefCell<NodeRewardsCanister>>,
+}
+
+impl HourlySyncTask {
+    pub fn new(canister: &'static LocalKey<RefCell<NodeRewardsCanister>>) -> Self {
+        Self { canister }
+    }
+
+    fn default_delay() -> Duration {
+        let now_secs = current_time().as_secs_since_unix_epoch();
+        let since_hour = now_secs % SECS_PER_HOUR;
+
+        // Target is delaying execution until the next hour plus SYNC_OFFSET.
+        let next_sync_target_secs = if since_hour < SYNC_OFFSET {
+            now_secs - since_hour + SYNC_OFFSET
+        } else {
+            now_secs - since_hour + SECS_PER_HOUR + SYNC_OFFSET
+        };
+
+        Duration::from_secs(next_sync_target_secs - now_secs)
+    }
+}
+
+impl RecurringSyncTask for HourlySyncTask {
+    fn execute(self) -> (Duration, Self) {
+        ic_cdk::futures::spawn_017_compat(async move {
+            match NodeRewardsCanister::schedule_registry_sync(self.canister).await {
+                Ok(_) => {
+                    ic_cdk::println!("Successfully synced local registry");
+                    match NodeRewardsCanister::schedule_metrics_sync(self.canister).await {
+                        Ok(_) => {
+                            ic_cdk::println!("Successfully synced subnets metrics")
+                        }
+                        Err(e) => {
+                            ic_cdk::println!("Failed to sync subnets metrics: {:?}", e)
+                        }
+                    }
+                }
+                Err(e) => {
+                    ic_cdk::println!("Failed to sync local registry: {:?}", e)
+                }
+            };
+        });
+
+        (Self::default_delay(), self)
+    }
+
+    fn initial_delay(&self) -> Duration {
+        Duration::from_secs(0)
+    }
+    const NAME: &'static str = "hourly_sync";
+}
diff --git a/rs/node_rewards/canister/tests/get_node_providers_monthly_xdr_rewards.rs b/rs/node_rewards/canister/tests/get_node_providers_monthly_xdr_rewards.rs
index 725a212ef4..d5f69ddacb 100644
--- a/rs/node_rewards/canister/tests/get_node_providers_monthly_xdr_rewards.rs
+++ b/rs/node_rewards/canister/tests/get_node_providers_monthly_xdr_rewards.rs
@@ -90,10 +90,7 @@ async fn get_node_providers_rewards_calculation_is_only_callable_in_nonreplicate
     .unwrap()
     .0
     .unwrap_err();
-    assert_eq!(
-        err,
-        "Could not calculate rewards: \"No metrics found for day 2021-05-06\""
-    );
+    assert_eq!(err, "Metrics and registry are not synced up");
 
     // Replicated update call is not allowed.
     let err = update_candid::<_, (GetNodeProvidersRewardsCalculationResponse,)>(
diff --git a/rs/node_rewards/canister/tests/regisry_sync_test.rs b/rs/node_rewards/canister/tests/regisry_sync_test.rs
index 659ed17abd..9eb1b2265c 100644
--- a/rs/node_rewards/canister/tests/regisry_sync_test.rs
+++ b/rs/node_rewards/canister/tests/regisry_sync_test.rs
@@ -6,7 +6,6 @@ use ic_protobuf::registry::subnet::v1::{SubnetRecord, SubnetType};
 use ic_registry_keys::make_subnet_record_key;
 use ic_types::{PrincipalId, SubnetId};
 use pocket_ic::PocketIcBuilder;
-use std::time::Duration;
 
 #[tokio::test]
 async fn test_registry_value_syncing() {
@@ -30,8 +29,6 @@ async fn test_registry_value_syncing() {
 
     // This is the value from invariant_compliant_mutation
     let test_subnet_id = SubnetId::from(PrincipalId::new_subnet_test_id(999));
-    // We don't use agents here because this method is test-only, so we won't
-    // support it beyond this one test.
     let response = pocket_ic
         .query_call(
             canister_id,
@@ -42,26 +39,7 @@ async fn test_registry_value_syncing() {
         .await
         .unwrap();
 
-    let decoded = Decode!(&response, Result<Option<Vec<u8>>, String>).unwrap();
-    assert_eq!(decoded, Ok(None));
-
-    // Advance time and tick so the sync will run
-    for _ in 0..10 {
-        pocket_ic.advance_time(Duration::from_secs(60 * 60)).await;
-        pocket_ic.tick().await;
-    }
-
-    let response = pocket_ic
-        .query_call(
-            canister_id,
-            PrincipalId::new_anonymous().0,
-            "get_registry_value",
-            Encode!(&make_subnet_record_key(test_subnet_id)).unwrap(),
-        )
-        .await
-        .unwrap();
-
-    // Now we are asserting that there is something in this recod
+    // Now we are asserting that there is something in this record
     let decoded = Decode!(&response, Result<Option<Vec<u8>>, String>).unwrap();
     let unwrapped = decoded.unwrap().unwrap();
     // Assert that this Registry value is actually a valid sequence of bits
```

---

### Commit `0987d0ef4394c7934186a042046d297ee7b6242d`

**Author:** pietrodimarco-dfinity <124565147+pietrodimarco-dfinity@users.noreply.github.com>  
**Date:** 2025-10-14  
**Message:** chore(node-rewards-canister): Address pending TODOs (#7222)

**Files Changed:**
- `rs/node_rewards/canister/api/src/api_native_conversion.rs`
- `rs/node_rewards/canister/api/src/provider_rewards_calculation.rs`
- `rs/node_rewards/canister/node-rewards-canister.did`
- `rs/node_rewards/canister/src/canister/mod.rs`
- `rs/node_rewards/canister/src/main.rs`
- `rs/node_rewards/canister/tests/get_node_providers_monthly_xdr_rewards.rs`
- `rs/node_rewards/rewards_calculation/src/performance_based_algorithm/mod.rs`
- `rs/node_rewards/rewards_calculation/src/performance_based_algorithm/results.rs`
- `rs/node_rewards/rewards_calculation/src/performance_based_algorithm/v1.rs`

**Code Changes:**

```diff
commit 0987d0ef4394c7934186a042046d297ee7b6242d
Author: pietrodimarco-dfinity <124565147+pietrodimarco-dfinity@users.noreply.github.com>
Date:   Tue Oct 14 17:30:35 2025 +0200

    chore(node-rewards-canister): Address pending TODOs (#7222)
    
    Changes:
    
    - Refactored API types to use f64 and u64 instead of Decimals
    - Removed layer of indirection introduced with types XDRPermyriad and
    Percent. Using instead Decimals directly
    - Added units in performance based node rewards types
    - Removed unused API -> native_type conversion
    
    This PR introduce breaking changes to the API which is fine because not
    used

diff --git a/rs/node_rewards/canister/api/src/api_native_conversion.rs b/rs/node_rewards/canister/api/src/api_native_conversion.rs
index 9815939e56..11f9382f17 100644
--- a/rs/node_rewards/canister/api/src/api_native_conversion.rs
+++ b/rs/node_rewards/canister/api/src/api_native_conversion.rs
@@ -1,318 +1,200 @@
 use crate::provider_rewards_calculation::{
-    BaseRewardsSpec, DailyNodeProviderRewards, DailyNodeRewards, DailyResults, NodeMetricsDaily,
-    NodeStatus, Type3BaseRewardsSpec,
+    DailyNodeFailureRate, DailyNodeProviderRewards, DailyNodeRewards, DailyResults,
+    NodeMetricsDaily, NodeTypeRegionBaseRewards, Type3RegionBaseRewards,
 };
-use ic_base_types::{NodeId, SubnetId};
-use ic_nervous_system_proto::pb::v1::Decimal as DecimalProto;
-use ic_protobuf::registry::node::v1::NodeRewardType;
 use rewards_calculation::performance_based_algorithm::results as native_types;
-use rust_decimal::Decimal;
+use rust_decimal::prelude::ToPrimitive;
+use std::convert::TryFrom;
 
 // ================================================================================================
 // Conversion implementations for API types <-> Internal types
 // ================================================================================================
 
 // NodeMetricsDaily conversions
-impl From<native_types::NodeMetricsDaily> for NodeMetricsDaily {
-    fn from(src: native_types::NodeMetricsDaily) -> Self {
-        Self {
-            subnet_assigned: Some(src.subnet_assigned.get()),
-            subnet_assigned_fr_percent: Some(DecimalProto::from(src.subnet_assigned_fr)),
-            num_blocks_proposed: Some(src.num_blocks_proposed),
-            num_blocks_failed: Some(src.num_blocks_failed),
-            original_fr_percent: Some(DecimalProto::from(src.original_fr)),
-            relative_fr_percent: Some(DecimalProto::from(src.relative_fr)),
-        }
-    }
-}
-
-impl TryFrom<NodeMetricsDaily> for native_types::NodeMetricsDaily {
+impl TryFrom<native_types::NodeMetricsDaily> for NodeMetricsDaily {
     type Error = String;
 
-    fn try_from(src: NodeMetricsDaily) -> Result<Self, Self::Error> {
+    fn try_from(src: native_types::NodeMetricsDaily) -> Result<Self, Self::Error> {
         Ok(Self {
-            subnet_assigned: SubnetId::from(
-                src.subnet_assigned
-                    .ok_or("subnet_assigned is missing (from NodeMetricsDaily).")?,
-            ),
-            subnet_assigned_fr: Decimal::try_from(
+            subnet_assigned: Some(src.subnet_assigned.get()),
+            subnet_assigned_fr_percent: Some(
                 src.subnet_assigned_fr_percent
-                    .ok_or("subnet_assigned_fr_percent is missing (from NodeMetricsDaily).")?,
-            )?,
-            num_blocks_proposed: src
-                .num_blocks_proposed
-                .ok_or("num_blocks_proposed is missing (from NodeMetricsDaily).")?,
-            num_blocks_failed: src
-                .num_blocks_failed
-                .ok_or("num_blocks_failed is missing (from NodeMetricsDaily).")?,
-            original_fr: Decimal::try_from(
+                    .to_f64()
+                    .ok_or("Conversion to f64 failed (subnet_assigned_fr_percent)")?,
+            ),
+            num_blocks_proposed: Some(src.num_blocks_proposed),
+            num_blocks_failed: Some(src.num_blocks_failed),
+            original_fr_percent: Some(
                 src.original_fr_percent
-                    .ok_or("original_fr_percent is missing (from NodeMetricsDaily).")?,
-            )?,
-            relative_fr: Decimal::try_from(
+                    .to_f64()
+                    .ok_or("Conversion to f64 failed (original_fr_percent)")?,
+            ),
+            relative_fr_percent: Some(
                 src.relative_fr_percent
-                    .ok_or("relative_fr_percent is missing (from NodeMetricsDaily).")?,
-            )?,
+                    .to_f64()
+                    .ok_or("Conversion to f64 failed (relative_fr_percent)")?,
+            ),
         })
     }
 }
 
-// NodeStatus conversions
-impl From<native_types::NodeStatus> for NodeStatus {
-    fn from(src: native_types::NodeStatus) -> Self {
-        match src {
-            native_types::NodeStatus::Assigned { node_metrics } => Self::Assigned {
-                node_metrics: Some(NodeMetricsDaily::from(node_metrics)),
-            },
-            native_types::NodeStatus::Unassigned { extrapolated_fr } => Self::Unassigned {
-                extrapolated_fr_percent: Some(DecimalProto::from(extrapolated_fr)),
-            },
-        }
-    }
-}
-
-impl TryFrom<NodeStatus> for native_types::NodeStatus {
+// DailyNodeFailureRate conversions
+impl TryFrom<native_types::DailyNodeFailureRate> for DailyNodeFailureRate {
     type Error = String;
 
-    fn try_from(src: NodeStatus) -> Result<Self, Self::Error> {
+    fn try_from(src: native_types::DailyNodeFailureRate) -> Result<Self, Self::Error> {
         match src {
-            NodeStatus::Assigned { node_metrics } => Ok(Self::Assigned {
-                node_metrics: native_types::NodeMetricsDaily::try_from(
-                    node_metrics.ok_or("node_metrics is missing (from NodeStatus).")?,
-                )?,
-            }),
-            NodeStatus::Unassigned {
-                extrapolated_fr_percent,
-            } => Ok(Self::Unassigned {
-                extrapolated_fr: Decimal::try_from(
-                    extrapolated_fr_percent
-                        .ok_or("extrapolated_fr_percent is missing (from NodeStatus).")?,
-                )?,
-            }),
+            native_types::DailyNodeFailureRate::SubnetMember { node_metrics } => {
+                Ok(DailyNodeFailureRate::SubnetMember {
+                    node_metrics: Some(NodeMetricsDaily::try_from(node_metrics)?),
+                })
+            }
+            native_types::DailyNodeFailureRate::NonSubnetMember { extrapolated_fr } => {
+                Ok(DailyNodeFailureRate::NonSubnetMember {
+                    extrapolated_fr_percent: Some(
+                        extrapolated_fr
+                            .to_f64()
+                            .ok_or("Conversion to f64 failed (extrapolated_fr)")?,
+                    ),
+                })
+            }
         }
     }
 }
 
 // DailyNodeRewards conversions
-impl From<native_types::DailyNodeRewards> for DailyNodeRewards {
-    fn from(src: native_types::DailyNodeRewards) -> Self {
-        Self {
+impl TryFrom<native_types::DailyNodeRewards> for DailyNodeRewards {
+    type Error = String;
+
+    fn try_from(src: native_types::DailyNodeRewards) -> Result<Self, Self::Error> {
+        Ok(Self {
             node_id: Some(src.node_id.get()),
             node_reward_type: Some(src.node_reward_type.to_string()),
             region: Some(src.region),
             dc_id: Some(src.dc_id),
-            node_status: Some(NodeStatus::from(src.node_status)),
-            performance_multiplier_percent: Some(DecimalProto::from(src.performance_multiplier)),
-            rewards_reduction_percent: Some(DecimalProto::from(src.rewards_reduction)),
-            base_rewards_xdr_permyriad: Some(DecimalProto::from(src.base_rewards)),
-            adjusted_rewards_xdr_permyriad: Some(DecimalProto::from(src.adjusted_rewards)),
-        }
-    }
-}
-
-impl TryFrom<DailyNodeRewards> for native_types::DailyNodeRewards {
-    type Error = String;
-    fn try_from(src: DailyNodeRewards) -> Result<Self, Self::Error> {
-        Ok(Self {
-            node_id: NodeId::from(
-                src.node_id
-                    .ok_or("node_id is missing (from DailyNodeRewards).")?,
-            ),
-            node_reward_type: NodeRewardType::from(
-                src.node_reward_type
-                    .ok_or("node_reward_type is missing (from DailyNodeRewards).")?,
-            ),
-            region: src
-                .region
-                .ok_or("region is missing (from DailyNodeRewards).")?,
-            dc_id: src
-                .dc_id
-                .ok_or("dc_id is missing (from DailyNodeRewards).")?,
-            node_status: native_types::NodeStatus::try_from(
-                src.node_status
-                    .ok_or("node_status is missing (from DailyNodeRewards).")?,
-            )?,
-            performance_multiplier: Decimal::try_from(
+            daily_node_fr: Some(DailyNodeFailureRate::try_from(src.daily_node_fr)?),
+            performance_multiplier_percent: Some(
                 src.performance_multiplier_percent
-                    .ok_or("performance_multiplier_percent is missing (from DailyNodeRewards).")?,
-            )?,
-            rewards_reduction: Decimal::try_from(
+                    .to_f64()
+                    .ok_or("Conversion to f64 failed (performance_multiplier_percent)")?,
+            ),
+            rewards_reduction_percent: Some(
                 src.rewards_reduction_percent
-                    .ok_or("rewards_reduction_percent is missing (from DailyNodeRewards).")?,
-            )?,
-            base_rewards: Decimal::try_from(
+                    .to_f64()
+                    .ok_or("Conversion to f64 failed (rewards_reduction_percent)")?,
+            ),
+            base_rewards_xdr_permyriad: Some(
                 src.base_rewards_xdr_permyriad
-                    .ok_or("base_rewards_xdr_permyriad is missing (from DailyNodeRewards).")?,
-            )?,
-            adjusted_rewards: Decimal::try_from(
+                    .to_u64()
+                    .ok_or("Conversion to u64 failed (base_rewards_xdr_permyriad)")?,
+            ),
+            adjusted_rewards_xdr_permyriad: Some(
                 src.adjusted_rewards_xdr_permyriad
-                    .ok_or("adjusted_rewards_xdr_permyriad is missing (from DailyNodeRewards).")?,
-            )?,
+                    .to_u64()
+                    .ok_or("Conversion to u64 failed (adjusted_rewards_xdr_permyriad)")?,
+            ),
         })
     }
 }
 
-// BaseRewards conversions
-impl From<native_types::BaseRewardsSpec> for BaseRewardsSpec {
-    fn from(src: native_types::BaseRewardsSpec) -> Self {
-        Self {
-            monthly_xdr_permyriad: Some(DecimalProto::from(src.monthly)),
-            daily_xdr_permyriad: Some(DecimalProto::from(src.daily)),
-            node_reward_type: Some(src.node_reward_type.to_string()),
-            region: Some(src.region),
-        }
-    }
-}
-
-impl TryFrom<BaseRewardsSpec> for native_types::BaseRewardsSpec {
+// NodeTypeRegionBaseRewards conversions
+impl TryFrom<native_types::NodeTypeRegionBaseRewards> for NodeTypeRegionBaseRewards {
     type Error = String;
 
-    fn try_from(src: BaseRewardsSpec) -> Result<Self, Self::Error> {
+    fn try_from(src: native_types::NodeTypeRegionBaseRewards) -> Result<Self, Self::Error> {
         Ok(Self {
-            node_reward_type: NodeRewardType::from(
-                src.node_reward_type
-                    .ok_or("node_reward_type is missing (from BaseRewards).")?,
-            ),
-            region: src.region.ok_or("region is missing (from BaseRewards).")?,
-            monthly: Decimal::try_from(
+            monthly_xdr_permyriad: Some(
                 src.monthly_xdr_permyriad
-                    .ok_or("monthly_xdr_permyriad is missing (from BaseRewards).")?,
-            )?,
-            daily: Decimal::try_from(
+                    .to_u64()
+                    .ok_or("Conversion to f64 failed (monthly_xdr_permyriad)")?,
+            ),
+            daily_xdr_permyriad: Some(
                 src.daily_xdr_permyriad
-                    .ok_or("daily_xdr_permyriad is missing (from BaseRewards).")?,
-            )?,
-        })
-    }
-}
-
-// Type3BaseRewards conversions
-impl From<native_types::Type3BaseRewards> for Type3BaseRewardsSpec {
-    fn from(src: native_types::Type3BaseRewards) -> Self {
-        Self {
+                    .to_u64()
+                    .ok_or("Conversion to f64 failed (daily_xdr_permyriad)")?,
+            ),
+            node_reward_type: Some(src.node_reward_type.to_string()),
             region: Some(src.region),
-            nodes_count: Some(src.nodes_count as u64),
-            avg_rewards_xdr_permyriad: Some(DecimalProto::from(src.avg_rewards)),
-            avg_coefficient_percent: Some(DecimalProto::from(src.avg_coefficient)),
-            value_xdr_permyriad: Some(DecimalProto::from(src.value)),
-        }
+        })
     }
 }
 
-impl TryFrom<Type3BaseRewardsSpec> for native_types::Type3BaseRewards {
+// Type3RegionBaseRewards conversions
+impl TryFrom<native_types::Type3RegionBaseRewards> for Type3RegionBaseRewards {
     type Error = String;
 
-    fn try_from(value: Type3BaseRewardsSpec) -> Result<Self, Self::Error> {
+    fn try_from(src: native_types::Type3RegionBaseRewards) -> Result<Self, Self::Error> {
         Ok(Self {
-            region: value
-                .region
-                .ok_or("region is missing (from Type3BaseRewards).")?,
-            nodes_count: value
-                .nodes_count
-                .ok_or("nodes_count is missing (from Type3BaseRewards).")?
-                as usize,
-            avg_rewards: Decimal::try_from(
-                value
-                    .avg_rewards_xdr_permyriad
-                    .ok_or("avg_rewards_xdr_permyriad is missing (from Type3BaseRewards).")?,
-            )?,
-            avg_coefficient: Decimal::try_from(
-                value
-                    .avg_coefficient_percent
-                    .ok_or("avg_coefficient_percent is missing (from Type3BaseRewards).")?,
-            )?,
-            value: Decimal::try_from(
-                value
-                    .value_xdr_permyriad
-                    .ok_or("value_xdr_permyriad is missing (from Type3BaseRewards).")?,
-            )?,
+            region: Some(src.region),
+            nodes_count: Some(src.nodes_count as u64),
+            avg_rewards_xdr_permyriad: Some(
+                src.avg_rewards_xdr_permyriad
+                    .to_u64()
+                    .ok_or("Conversion to u64 failed (avg_rewards_xdr_permyriad)")?,
+            ),
+            avg_coefficient_percent: Some(
+                src.avg_coefficient_percent
+                    .to_f64()
+                    .ok_or("Conversion to f64 failed (avg_coefficient_percent)")?,
+            ),
+            daily_xdr_permyriad: Some(
+                src.daily_xdr_permyriad
+                    .to_u64()
+                    .ok_or("Conversion to u64 failed (daily_xdr_permyriad)")?,
+            ),
         })
     }
 }
 
 // DailyNodeProviderRewards conversions
-impl From<native_types::DailyNodeProviderRewards> for DailyNodeProviderRewards {
-    fn from(src: native_types::DailyNodeProviderRewards) -> Self {
-        Self {
-            rewards_total_xdr_permyriad: Some(DecimalProto::from(src.rewards_total)),
-            base_rewards: src
-                .base_rewards
-                .into_iter()
-                .map(BaseRewardsSpec::from)
-                .collect(),
-            base_rewards_type3: src
-                .type3_base_rewards
-                .into_iter()
-                .map(Type3BaseRewardsSpec::from)
-                .collect(),
-            daily_nodes_rewards: src
-                .daily_nodes_rewards
-                .into_iter()
-                .map(DailyNodeRewards::from)
-                .collect(),
-        }
-    }
-}
-
-impl TryFrom<DailyNodeProviderRewards> for native_types::DailyNodeProviderRewards {
+impl TryFrom<native_types::DailyNodeProviderRewards> for DailyNodeProviderRewards {
     type Error = String;
 
-    fn try_from(src: DailyNodeProviderRewards) -> Result<Self, Self::Error> {
+    fn try_from(src: native_types::DailyNodeProviderRewards) -> Result<Self, Self::Error> {
         Ok(Self {
-            rewards_total: Decimal::try_from(src.rewards_total_xdr_permyriad.ok_or(
-                "rewards_total_xdr_permyriad is missing (from DailyNodeProviderRewards).",
-            )?)?,
+            rewards_total_xdr_permyriad: Some(
+                src.rewards_total_xdr_permyriad
+                    .to_u64()
+                    .ok_or("Conversion to u64 failed (rewards_total_xdr_permyriad)")?,
+            ),
             base_rewards: src
                 .base_rewards
                 .into_iter()
-                .map(native_types::BaseRewardsSpec::try_from)
+                .map(NodeTypeRegionBaseRewards::try_from)
                 .collect::<Result<_, _>>()?,
-            type3_base_rewards: src
-                .base_rewards_type3
+            base_rewards_type3: src
+                .type3_base_rewards
                 .into_iter()
-                .map(native_types::Type3BaseRewards::try_from)
+                .map(Type3RegionBaseRewards::try_from)
                 .collect::<Result<_, _>>()?,
             daily_nodes_rewards: src
                 .daily_nodes_rewards
                 .into_iter()
-                .map(native_types::DailyNodeRewards::try_from)
+                .map(DailyNodeRewards::try_from)
                 .collect::<Result<_, _>>()?,
         })
     }
 }
 
 // DailyResults conversions
-impl From<native_types::DailyResults> for DailyResults {
-    fn from(src: native_types::DailyResults) -> Self {
-        Self {
-            subnets_fr: src
-                .subnets_fr
-                .into_iter()
-                .map(|(k, v)| (k, DecimalProto::from(v)))
-                .collect(),
-            provider_results: src
-                .provider_results
-                .into_iter()
-                .map(|(k, v)| (k, DailyNodeProviderRewards::from(v)))
-                .collect(),
-        }
-    }
-}
-
-impl TryFrom<DailyResults> for native_types::DailyResults {
+impl TryFrom<native_types::DailyResults> for DailyResults {
     type Error = String;
 
-    fn try_from(src: DailyResults) -> Result<Self, Self::Error> {
+    fn try_from(src: native_types::DailyResults) -> Result<Self, Self::Error> {
         Ok(Self {
             subnets_fr: src
-                .subnets_fr
+                .subnets_fr_percent
                 .into_iter()
-                .map(|(k, v)| Decimal::try_from(v).map(|dec| (k, dec)))
+                .map(|(k, v)| {
+                    v.to_f64()
+                        .map(|v| (k, v))
+                        .ok_or("Conversion to f64 failed (subnets_fr_percent)")
+                })
                 .collect::<Result<_, _>>()?,
             provider_results: src
                 .provider_results
                 .into_iter()
-                .map(|(k, v)| native_types::DailyNodeProviderRewards::try_from(v).map(|v| (k, v)))
+                .map(|(k, v)| DailyNodeProviderRewards::try_from(v).map(|v| (k, v)))
                 .collect::<Result<_, _>>()?,
         })
     }
diff --git a/rs/node_rewards/canister/api/src/provider_rewards_calculation.rs b/rs/node_rewards/canister/api/src/provider_rewards_calculation.rs
index 1e41f9f506..00dd628a0f 100644
--- a/rs/node_rewards/canister/api/src/provider_rewards_calculation.rs
+++ b/rs/node_rewards/canister/api/src/provider_rewards_calculation.rs
@@ -1,7 +1,6 @@
 pub use crate::DateUtc;
 use candid::{CandidType, Deserialize};
 use ic_base_types::{PrincipalId, SubnetId};
-use ic_nervous_system_proto::pb::v1::Decimal;
 use std::collections::BTreeMap;
 
 #[derive(CandidType, Clone, Deserialize)]
@@ -10,7 +9,7 @@ pub struct GetNodeProvidersRewardsCalculationRequest {
 }
 
 // TODO: Remove useless level of indirection: https://github.com/dfinity/ic/pull/7071/files#r2406450031
-pub type GetNodeProviderRewardsCalculationResponse = Result<DailyResults, String>;
+pub type GetNodeProvidersRewardsCalculationResponse = Result<DailyResults, String>;
 
 // These are API-facing types with all fields wrapped in `Option`
 // to ensure forward compatibility. This way, new fields can be added
@@ -20,19 +19,19 @@ pub type GetNodeProviderRewardsCalculationResponse = Result<DailyResults, String
 #[derive(candid::CandidType, candid::Deserialize, Clone, PartialEq, Debug)]
 pub struct NodeMetricsDaily {
     pub subnet_assigned: Option<PrincipalId>,
-    pub subnet_assigned_fr_percent: Option<Decimal>,
+    pub subnet_assigned_fr_percent: Option<f64>,
     pub num_blocks_proposed: Option<u64>,
     pub num_blocks_failed: Option<u64>,
-    pub original_fr_percent: Option<Decimal>,
-    pub relative_fr_percent: Option<Decimal>,
+    pub original_fr_percent: Option<f64>,
+    pub relative_fr_percent: Option<f64>,
 }
 #[derive(candid::CandidType, candid::Deserialize, Clone, PartialEq, Debug)]
-pub enum NodeStatus {
-    Assigned {
+pub enum DailyNodeFailureRate {
+    SubnetMember {
         node_metrics: Option<NodeMetricsDaily>,
     },
-    Unassigned {
-        extrapolated_fr_percent: Option<Decimal>,
+    NonSubnetMember {
+        extrapolated_fr_percent: Option<f64>,
     },
 }
 #[derive(candid::CandidType, candid::Deserialize, Clone, PartialEq, Debug)]
@@ -41,36 +40,36 @@ pub struct DailyNodeRewards {
     pub node_reward_type: Option<String>,
     pub region: Option<String>,
     pub dc_id: Option<String>,
-    pub node_status: Option<NodeStatus>,
-    pub performance_multiplier_percent: Option<Decimal>,
-    pub rewards_reduction_percent: Option<Decimal>,
-    pub base_rewards_xdr_permyriad: Option<Decimal>,
-    pub adjusted_rewards_xdr_permyriad: Option<Decimal>,
+    pub daily_node_fr: Option<DailyNodeFailureRate>,
+    pub performance_multiplier_percent: Option<f64>,
+    pub rewards_reduction_percent: Option<f64>,
+    pub base_rewards_xdr_permyriad: Option<u64>,
+    pub adjusted_rewards_xdr_permyriad: Option<u64>,
 }
 #[derive(candid::CandidType, candid::Deserialize, Clone, PartialEq, Debug)]
-pub struct BaseRewardsSpec {
-    pub monthly_xdr_permyriad: Option<Decimal>,
-    pub daily_xdr_permyriad: Option<Decimal>,
+pub struct NodeTypeRegionBaseRewards {
+    pub monthly_xdr_permyriad: Option<u64>,
+    pub daily_xdr_permyriad: Option<u64>,
     pub node_reward_type: Option<String>,
     pub region: Option<String>,
 }
 #[derive(candid::CandidType, candid::Deserialize, Clone, PartialEq, Debug)]
-pub struct Type3BaseRewardsSpec {
+pub struct Type3RegionBaseRewards {
     pub region: Option<String>,
     pub nodes_count: Option<u64>,
-    pub avg_rewards_xdr_permyriad: Option<Decimal>,
-    pub avg_coefficient_percent: Option<Decimal>,
-    pub value_xdr_permyriad: Option<Decimal>,
+    pub avg_rewards_xdr_permyriad: Option<u64>,
+    pub avg_coefficient_percent: Option<f64>,
+    pub daily_xdr_permyriad: Option<u64>,
 }
 #[derive(candid::CandidType, candid::Deserialize, Clone, PartialEq, Debug)]
 pub struct DailyNodeProviderRewards {
-    pub rewards_total_xdr_permyriad: Option<Decimal>,
-    pub base_rewards: Vec<BaseRewardsSpec>,
-    pub base_rewards_type3: Vec<Type3BaseRewardsSpec>,
+    pub rewards_total_xdr_permyriad: Option<u64>,
+    pub base_rewards: Vec<NodeTypeRegionBaseRewards>,
+    pub base_rewards_type3: Vec<Type3RegionBaseRewards>,
     pub daily_nodes_rewards: Vec<DailyNodeRewards>,
 }
 #[derive(candid::CandidType, candid::Deserialize, Clone, PartialEq, Debug)]
 pub struct DailyResults {
-    pub subnets_fr: BTreeMap<SubnetId, Decimal>,
+    pub subnets_fr: BTreeMap<SubnetId, f64>,
     pub provider_results: BTreeMap<PrincipalId, DailyNodeProviderRewards>,
 }
diff --git a/rs/node_rewards/canister/node-rewards-canister.did b/rs/node_rewards/canister/node-rewards-canister.did
index 85fd0c27a9..c934ddf5d8 100644
--- a/rs/node_rewards/canister/node-rewards-canister.did
+++ b/rs/node_rewards/canister/node-rewards-canister.did
@@ -1,9 +1,5 @@
 // get_node_providers_rewards_calculation
 
-type Decimal = record {
-  human_readable: opt text;
-};
-
 type DateUtc = record {
   day: opt nat32;
   month: opt nat32;
@@ -12,16 +8,16 @@ type DateUtc = record {
 
 type NodeMetricsDaily = record {
   subnet_assigned: opt principal;
-  subnet_assigned_fr_percent: opt Decimal;
+  subnet_assigned_fr_percent: opt float64;
   num_blocks_proposed: opt nat64;
   num_blocks_failed: opt nat64;
-  original_fr_percent: opt Decimal;
-  relative_fr_percent: opt Decimal;
+  original_fr_percent: opt float64;
+  relative_fr_percent: opt float64;
 };
 
-type NodeStatus = variant {
-  Assigned: record { node_metrics: opt NodeMetricsDaily };
-  Unassigned: record { extrapolated_fr_percent: opt Decimal };
+type DailyNodeFailureRate = variant {
+  SubnetMember: record { node_metrics: opt NodeMetricsDaily };
+  NonSubnetMember: record { extrapolated_fr_percent: opt float64 };
 };
 
 type DailyNodeRewards = record {
@@ -29,41 +25,41 @@ type DailyNodeRewards = record {
   node_reward_type: opt text;
   region: opt text;
   dc_id: opt text;
-  node_status: opt NodeStatus;
-  performance_multiplier_percent: opt Decimal;
-  rewards_reduction_percent: opt Decimal;
-  base_rewards_xdr_permyriad: opt Decimal;
-  adjusted_rewards_xdr_permyriad: opt Decimal;
+  daily_node_fr: opt DailyNodeFailureRate;
+  performance_multiplier_percent: opt float64;
+  rewards_reduction_percent: opt float64;
+  base_rewards_xdr_permyriad: opt nat64;
+  adjusted_rewards_xdr_permyriad: opt nat64;
 };
 
-type BaseRewardsSpec = record {
-  monthly_xdr_permyriad: opt Decimal;
-  daily_xdr_permyriad: opt Decimal;
+type NodeTypeRegionBaseRewards = record {
+  monthly_xdr_permyriad: opt nat64;
+  daily_xdr_permyriad: opt nat64;
   node_reward_type: opt text;
   region: opt text;
 };
 
-type Type3BaseRewardsSpec = record {
+type Type3BaseRewards = record {
   region: opt text;
   nodes_count: opt nat64;
-  avg_rewards_xdr_permyriad: opt Decimal;
-  avg_coefficient_percent: opt Decimal;
-  value_xdr_permyriad: opt Decimal;
+  avg_rewards_xdr_permyriad: opt nat64;
+  avg_coefficient_percent: opt float64;
+  daily_xdr_permyriad: opt nat64;
 };
 
 type DailyNodeProviderRewards = record {
-  rewards_total_xdr_permyriad: opt Decimal;
-  base_rewards: vec BaseRewardsSpec;
-  base_rewards_type3: vec Type3BaseRewardsSpec;
+  rewards_total_xdr_permyriad: opt nat64;
+  base_rewards: vec NodeTypeRegionBaseRewards;
+  base_rewards_type3: vec Type3BaseRewards;
   daily_nodes_rewards: vec DailyNodeRewards;
 };
 
 type DailyResults = record {
-    subnets_fr: vec record { principal; Decimal };
+    subnets_fr: vec record { principal; float64 };
     provider_results: vec record { principal; DailyNodeProviderRewards };
 };
 
-type GetNodeProviderRewardsCalculationResponse = variant { Ok: DailyResults; Err: text };
+type GetNodeProvidersRewardsCalculationResponse = variant { Ok: DailyResults; Err: text };
 
 type GetNodeProvidersRewardsCalculationRequest = record {
   day: DateUtc;
@@ -107,5 +103,5 @@ service: () -> {
         GetNodeProvidersMonthlyXdrRewardsResponse
     );
     get_node_providers_rewards: (GetNodeProvidersRewardsRequest) -> (GetNodeProvidersRewardsResponse);
-    get_node_providers_rewards_calculation: (GetNodeProvidersRewardsCalculationRequest) -> (GetNodeProviderRewardsCalculationResponse) query;
+    get_node_providers_rewards_calculation: (GetNodeProvidersRewardsCalculationRequest) -> (GetNodeProvidersRewardsCalculationResponse) query;
 }
diff --git a/rs/node_rewards/canister/src/canister/mod.rs b/rs/node_rewards/canister/src/canister/mod.rs
index 7d37f3f77a..f8f23e02d2 100644
--- a/rs/node_rewards/canister/src/canister/mod.rs
+++ b/rs/node_rewards/canister/src/canister/mod.rs
@@ -10,8 +10,8 @@ use ic_node_rewards_canister_api::monthly_rewards::{
     NodeProvidersMonthlyXdrRewards,
 };
 use ic_node_rewards_canister_api::provider_rewards_calculation::{
-    DailyResults, GetNodeProviderRewardsCalculationResponse,
-    GetNodeProvidersRewardsCalculationRequest,
+    DailyResults, GetNodeProvidersRewardsCalculationRequest,
+    GetNodeProvidersRewardsCalculationResponse,
 };
 use ic_node_rewards_canister_api::providers_rewards::{
     GetNodeProvidersRewardsRequest, GetNodeProvidersRewardsResponse, NodeProvidersRewards,
@@ -292,7 +292,7 @@ impl NodeRewardsCanister {
     pub fn get_node_providers_rewards_calculation(
         canister: &'static LocalKey<RefCell<NodeRewardsCanister>>,
         request: GetNodeProvidersRewardsCalculationRequest,
-    ) -> GetNodeProviderRewardsCalculationResponse {
+    ) -> GetNodeProvidersRewardsCalculationResponse {
         let request_inner = GetNodeProvidersRewardsRequest {
             from_day: request.day,
             to_day: request.day,
@@ -305,7 +305,7 @@ impl NodeRewardsCanister {
             .daily_results
             .remove(&day)
             .ok_or("Could not find daily results for the requested day")?;
-        Ok(DailyResults::from(daily_results))
+        DailyResults::try_from(daily_results)
     }
 }
 
diff --git a/rs/node_rewards/canister/src/main.rs b/rs/node_rewards/canister/src/main.rs
index 9a9a59d0a6..7b9de699a8 100644
--- a/rs/node_rewards/canister/src/main.rs
+++ b/rs/node_rewards/canister/src/main.rs
@@ -9,7 +9,7 @@ use ic_node_rewards_canister_api::monthly_rewards::{
     GetNodeProvidersMonthlyXdrRewardsRequest, GetNodeProvidersMonthlyXdrRewardsResponse,
 };
 use ic_node_rewards_canister_api::provider_rewards_calculation::{
-    GetNodeProviderRewardsCalculationResponse, GetNodeProvidersRewardsCalculationRequest,
+    GetNodeProvidersRewardsCalculationRequest, GetNodeProvidersRewardsCalculationResponse,
 };
 use ic_node_rewards_canister_api::providers_rewards::{
     GetNodeProvidersRewardsRequest, GetNodeProvidersRewardsResponse,
@@ -119,7 +119,7 @@ async fn get_node_providers_rewards(
 #[query]
 fn get_node_providers_rewards_calculation(
     request: GetNodeProvidersRewardsCalculationRequest,
-) -> GetNodeProviderRewardsCalculationResponse {
+) -> GetNodeProvidersRewardsCalculationResponse {
     if in_replicated_execution() {
         return Err(
             "Replicated execution of this method is not allowed. Use a non-replicated query call."
diff --git a/rs/node_rewards/canister/tests/get_node_providers_monthly_xdr_rewards.rs b/rs/node_rewards/canister/tests/get_node_providers_monthly_xdr_rewards.rs
index 897bb5042f..725a212ef4 100644
--- a/rs/node_rewards/canister/tests/get_node_providers_monthly_xdr_rewards.rs
+++ b/rs/node_rewards/canister/tests/get_node_providers_monthly_xdr_rewards.rs
@@ -6,7 +6,7 @@ use ic_nns_test_utils::common::build_node_rewards_test_wasm;
 use ic_node_rewards_canister_api::DateUtc;
 use ic_node_rewards_canister_api::monthly_rewards::GetNodeProvidersMonthlyXdrRewardsRequest;
 use ic_node_rewards_canister_api::provider_rewards_calculation::{
-    GetNodeProviderRewardsCalculationResponse, GetNodeProvidersRewardsCalculationRequest,
+    GetNodeProvidersRewardsCalculationRequest, GetNodeProvidersRewardsCalculationResponse,
 };
 use ic_types::PrincipalId;
 use pocket_ic::PocketIcBuilder;
@@ -80,7 +80,7 @@ async fn get_node_providers_rewards_calculation_is_only_callable_in_nonreplicate
     let request = GetNodeProvidersRewardsCalculationRequest { day };
 
     // Non-replicated query call is allowed.
-    let err = query_candid::<_, (GetNodeProviderRewardsCalculationResponse,)>(
+    let err = query_candid::<_, (GetNodeProvidersRewardsCalculationResponse,)>(
         &pocket_ic,
         node_rewards_id,
         "get_node_providers_rewards_calculation",
@@ -96,7 +96,7 @@ async fn get_node_providers_rewards_calculation_is_only_callable_in_nonreplicate
     );
 
     // Replicated update call is not allowed.
-    let err = update_candid::<_, (GetNodeProviderRewardsCalculationResponse,)>(
+    let err = update_candid::<_, (GetNodeProvidersRewardsCalculationResponse,)>(
         &pocket_ic,
         node_rewards_id,
         "get_node_providers_rewards_calculation",
diff --git a/rs/node_rewards/rewards_calculation/src/performance_based_algorithm/mod.rs b/rs/node_rewards/rewards_calculation/src/performance_based_algorithm/mod.rs
index 7ca9d317f6..0b7d232026 100644
--- a/rs/node_rewards/rewards_calculation/src/performance_based_algorithm/mod.rs
+++ b/rs/node_rewards/rewards_calculation/src/performance_based_algorithm/mod.rs
@@ -1,6 +1,6 @@
 use crate::performance_based_algorithm::results::{
-    BaseRewardsSpec, DailyNodeProviderRewards, DailyNodeRewards, DailyResults, NodeMetricsDaily,
-    NodeStatus, Percent, RewardsCalculatorResults, Type3BaseRewards, XDRPermyriad,
+    DailyNodeFailureRate, DailyNodeProviderRewards, DailyNodeRewards, DailyResults,
+    NodeMetricsDaily, NodeTypeRegionBaseRewards, RewardsCalculatorResults, Type3RegionBaseRewards,
 };
 use crate::types::{NodeMetricsDailyRaw, Region, RewardableNode};
 use chrono::NaiveDate;
@@ -46,28 +46,28 @@ pub mod v1;
 
 #[derive(Default)]
 struct FailureRateResults {
-    subnets_fr: BTreeMap<SubnetId, Percent>,
+    subnets_fr: BTreeMap<SubnetId, Decimal>,
     nodes_metrics_daily: BTreeMap<NodeId, NodeMetricsDaily>,
 }
 
 #[derive(Default)]
 struct PerformanceMultiplierResults {
-    reward_reduction: BTreeMap<NodeId, Percent>,
-    performance_multiplier: BTreeMap<NodeId, Percent>,
+    reward_reduction: BTreeMap<NodeId, Decimal>,
+    performance_multiplier: BTreeMap<NodeId, Decimal>,
 }
 
 #[derive(Default)]
 struct BaseRewardsResults {
-    base_rewards: Vec<BaseRewardsSpec>,
-    base_rewards_type3: Vec<Type3BaseRewards>,
-    base_rewards_per_node: BTreeMap<NodeId, XDRPermyriad>,
+    base_rewards: Vec<NodeTypeRegionBaseRewards>,
+    base_rewards_type3: Vec<Type3RegionBaseRewards>,
+    base_rewards_per_node: BTreeMap<NodeId, Decimal>,
 }
 
 type RewardsCoefficientPercent = Decimal;
 
 #[derive(Default)]
 struct AdjustedRewardsResults {
-    adjusted_rewards: BTreeMap<NodeId, XDRPermyriad>,
+    adjusted_rewards: BTreeMap<NodeId, Decimal>,
 }
 
 pub trait DataProvider {
@@ -129,8 +129,8 @@ trait PerformanceBasedAlgorithm {
             for (provider_id, provider_rewards) in &result_for_day.provider_results {
                 total_rewards_per_provider
                     .entry(*provider_id)
-                    .and_modify(|total| *total += provider_rewards.rewards_total)
-                    .or_insert(provider_rewards.rewards_total);
+                    .and_modify(|total| *total += provider_rewards.rewards_total_xdr_permyriad)
+                    .or_insert(provider_rewards.rewards_total_xdr_permyriad);
             }
             daily_results.insert(day, result_for_day);
         }
@@ -172,7 +172,7 @@ trait PerformanceBasedAlgorithm {
         }
 
         Ok(DailyResults {
-            subnets_fr,
+            subnets_fr_percent: subnets_fr,
             provider_results: results_per_provider,
         })
     }
@@ -191,7 +191,7 @@ trait PerformanceBasedAlgorithm {
 
         let relative_nodes_fr: BTreeMap<NodeId, Decimal> = provider_nodes_metrics_daily
             .iter()
-            .map(|(node_id, metrics)| (*node_id, metrics.relative_fr))
+            .map(|(node_id, metrics)| (*node_id, metrics.relative_fr_percent))
             .collect();
 
         // Calculate extrapolated failure rate for unassigned nodes
@@ -297,11 +297,11 @@ trait PerformanceBasedAlgorithm {
                     node_id,
                     NodeMetricsDaily {
                         subnet_assigned: subnet_id,
-                        subnet_assigned_fr: subnet_fr,
+                        subnet_assigned_fr_percent: subnet_fr,
                         num_blocks_proposed,
                         num_blocks_failed,
-                        original_fr,
-                        relative_fr,
+                        original_fr_percent: original_fr,
+                        relative_fr_percent: relative_fr,
                     },
                 );
             }
@@ -467,12 +467,12 @@ trait PerformanceBasedAlgorithm {
             .into_iter()
             .map(
                 |(region, (daily_rewards, nodes_count, avg_rewards, avg_coefficient))| {
-                    Type3BaseRewards {
+                    Type3RegionBaseRewards {
                         region,
                         nodes_count,
-                        avg_rewards,
-                        avg_coefficient,
-                        value: daily_rewards,
+                        avg_rewards_xdr_permyriad: avg_rewards,
+                        avg_coefficient_percent: avg_coefficient,
+                        daily_xdr_permyriad: daily_rewards,
                     }
                 },
             )
@@ -481,11 +481,13 @@ trait PerformanceBasedAlgorithm {
         let base_rewards = base_rewards
             .into_iter()
             .map(
-                |((node_reward_type, region), (daily_rewards, monthly_rewards))| BaseRewardsSpec {
-                    node_reward_type,
-                    region,
-                    monthly: monthly_rewards,
-                    daily: daily_rewards,
+                |((node_reward_type, region), (daily_rewards, monthly_rewards))| {
+                    NodeTypeRegionBaseRewards {
+                        node_reward_type,
+                        region,
+                        monthly_xdr_permyriad: monthly_rewards,
+                        daily_xdr_permyriad: daily_rewards,
+                    }
                 },
             )
             .collect();
@@ -524,23 +526,23 @@ trait PerformanceBasedAlgorithm {
     fn build_provider_rewards_summary(
         rewardable_nodes: Vec<RewardableNode>,
         mut provider_nodes_metrics_daily: BTreeMap<NodeId, NodeMetricsDaily>,
-        extrapolated_fr: Percent,
-        mut reward_reduction: BTreeMap<NodeId, Percent>,
-        mut performance_multiplier: BTreeMap<NodeId, Percent>,
-        mut base_rewards_per_node: BTreeMap<NodeId, XDRPermyriad>,
-        mut adjusted_rewards: BTreeMap<NodeId, XDRPermyriad>,
-        base_rewards: Vec<BaseRewardsSpec>,
-        base_rewards_type3: Vec<Type3BaseRewards>,
+        extrapolated_fr: Decimal,
+        mut reward_reduction: BTreeMap<NodeId, Decimal>,
+        mut performance_multiplier: BTreeMap<NodeId, Decimal>,
+        mut base_rewards_per_node: BTreeMap<NodeId, Decimal>,
+        mut adjusted_rewards: BTreeMap<NodeId, Decimal>,
+        base_rewards: Vec<NodeTypeRegionBaseRewards>,
+        base_rewards_type3: Vec<Type3RegionBaseRewards>,
     ) -> DailyNodeProviderRewards {
         let mut results_by_node = Vec::new();
-        let mut rewards_total = Decimal::ZERO;
+        let mut rewards_total_xdr_permyriad = Decimal::ZERO;
 
         for node in rewardable_nodes {
             let node_status =
                 if let Some(node_metrics) = provider_nodes_metrics_daily.remove(&node.node_id) {
-                    NodeStatus::Assigned { node_metrics }
+                    DailyNodeFailureRate::SubnetMember { node_metrics }
                 } else {
-                    NodeStatus::Unassigned { extrapolated_fr }
+                    DailyNodeFailureRate::NonSubnetMember { extrapolated_fr }
                 };
 
             let rewards_reduction_percent = reward_reduction
@@ -559,23 +561,23 @@ trait PerformanceBasedAlgorithm {
                 .remove(&node.node_id)
                 .expect("Adjusted rewards should be present in rewards");
 
-            rewards_total += adjusted_rewards_xdr_permyriad;
+            rewards_total_xdr_permyriad += adjusted_rewards_xdr_permyriad;
 
             results_by_node.push(DailyNodeRewards {
                 node_id: node.node_id,
                 node_reward_type: node.node_reward_type,
                 region: node.region,
                 dc_id: node.dc_id,
-                node_status,
-                performance_multiplier: performance_multiplier_percent,
-                rewards_reduction: rewards_reduction_percent,
-                base_rewards: base_rewards_xdr_permyriad,
-                adjusted_rewards: adjusted_rewards_xdr_permyriad,
+                daily_node_fr: node_status,
+                performance_multiplier_percent,
+                rewards_reduction_percent,
+                base_rewards_xdr_permyriad,
+                adjusted_rewards_xdr_permyriad,
             });
         }
 
         DailyNodeProviderRewards {
-            rewards_total,
+            rewards_total_xdr_permyriad,
             base_rewards,
             type3_base_rewards: base_rewards_type3,
             daily_nodes_rewards: results_by_node,
diff --git a/rs/node_rewards/rewards_calculation/src/performance_based_algorithm/results.rs b/rs/node_rewards/rewards_calculation/src/performance_based_algorithm/results.rs
index e384825ae3..6b368e68b7 100644
--- a/rs/node_rewards/rewards_calculation/src/performance_based_algorithm/results.rs
+++ b/rs/node_rewards/rewards_calculation/src/performance_based_algorithm/results.rs
@@ -5,10 +5,6 @@ use rust_decimal::Decimal;
 use serde::{Deserialize, Serialize};
 use std::collections::BTreeMap;
 
-// TODO: Remove these types in favor of Decimal. Also fields renaming to include units
-// https://github.com/dfinity/ic/pull/7071/files#r2406492271
-pub type XDRPermyriad = Decimal; // Rewards unit in XDR scaled by 1/10,000 (permyriad)
-pub type Percent = Decimal;
 pub type Region = String;
 
 #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
@@ -23,7 +19,7 @@ pub struct NodeMetricsDaily {
     /// This is the SUBNET_FAILURE_RATE_PERCENTILE of the original_fr all nodes in the subnet.
     /// It is used to adjust individual node failure rates to account for systematic issues
     /// affecting the whole subnet.
-    pub subnet_assigned_fr: Percent,
+    pub subnet_assigned_fr_percent: Decimal,
 
     /// Number of blocks successfully proposed by this node on this day
     pub num_blocks_proposed: u64,
@@ -35,27 +31,27 @@ pub struct NodeMetricsDaily {
     ///
     /// Calculated as `num_blocks_failed / (num_blocks_proposed + num_blocks_failed)`.
     /// Represents the failure rate of the node before any subnet-level adjustments.
-    pub original_fr: Percent,
+    pub original_fr_percent: Decimal,
 
     /// Relative Failure Rate
     ///
     /// Failure rate adjusted for subnet performance.
-    /// Calculated as `max(0, original_fr - subnet_assigned_fr)`.
+    /// Calculated as `max(0, original_fr - subnet_assigned_fr_percent)`.
     /// TODO: Link documentation about performance based rewards algorithm
-    pub relative_fr: Percent,
+    pub relative_fr_percent: Decimal,
 }
 
-// TODO: Renaming to NodeProductivity: https://github.com/dfinity/ic/pull/7071/files#r2406794563
+// TODO: Link documentation about performance based rewards algorithm
 #[derive(Serialize, Deserialize, Debug, PartialEq, Clone)]
-pub enum NodeStatus {
+pub enum DailyNodeFailureRate {
     /// Node is assigned to a subnet with recorded metrics
-    Assigned { node_metrics: NodeMetricsDaily },
+    SubnetMember { node_metrics: NodeMetricsDaily },
 
     /// Node is unassigned; only extrapolated failure rate is available
-    Unassigned {
+    NonSubnetMember {
         /// Extrapolated Failure Rate (EFR)
         /// Used to estimate the node's performance when unassigned
-        extrapolated_fr: Percent,
+        extrapolated_fr: Decimal,
     },
 }
 
@@ -73,28 +69,28 @@ pub struct DailyNodeRewards {
     /// TODO: Link to documentation about performance based rewards
     pub dc_id: String,
 
-    /// Node status, assigned or unassigned, with associated metrics
-    pub node_status: NodeStatus,
+    /// Daily node failure rate
+    pub daily_node_fr: DailyNodeFailureRate,
 
     /// Performance multiplier (1 - rewards_reduction)
     ///
     /// Represents how rewards are adjusted based on node performance
-    pub performance_multiplier: Percent,
+    pub performance_multiplier_percent: Decimal,
 
     /// Rewards reduction applied due to failure rates
     // TODO: Link to documentation about performance based rewards
-    pub rewards_reduction: Percent,
+    pub rewards_reduction_percent: Decimal,
 
     /// Base rewards before applying performance multipliers
-    pub base_rewards: XDRPermyriad,
+    pub base_rewards_xdr_permyriad: Decimal,
 
     /// Rewards adjusted by the performance multiplier
-    pub adjusted_rewards: XDRPermyriad,
+    pub adjusted_rewards_xdr_permyriad: Decimal,
 }
 
 /// Base rewards for NON type 3 nodes.
 #[derive(Serialize, Deserialize, Debug, PartialEq, Clone)]
-pub struct BaseRewardsSpec {
+pub struct NodeTypeRegionBaseRewards {
     /// NodeRewardType
     pub node_reward_type: NodeRewardType,
 
@@ -102,10 +98,10 @@ pub struct BaseRewardsSpec {
     pub region: Region,
 
     /// Monthly base rewards in XDR permyriad
-    pub monthly: XDRPermyriad,
+    pub monthly_xdr_permyriad: Decimal,
 
     /// Daily base rewards in XDR permyriad
-    pub daily: XDRPermyriad,
+    pub daily_xdr_permyriad: Decimal,
 }
 
 /// Base rewards for a Type 3 node.
@@ -114,7 +110,7 @@ pub struct BaseRewardsSpec {
 /// For nodes which are type3 special logic is applied to compute base rewards.
 /// Check the documentation of the performance-based rewards algorithm for details.
 #[derive(Serialize, Deserialize, Debug, PartialEq, Clone)]
-pub struct Type3BaseRewards {
+pub struct Type3RegionBaseRewards {
     /// Region for which the rewards are calculated
     pub region: Region,
 
@@ -122,25 +118,25 @@ pub struct Type3BaseRewards {
     pub nodes_count: usize,
 
     /// Average rewards for nodes in this region
-    pub avg_rewards: XDRPermyriad,
+    pub avg_rewards_xdr_permyriad: Decimal,
 
     /// Average performance coefficient applied to nodes
-    pub avg_coefficient: Percent,
+    pub avg_coefficient_percent: Decimal,
 
     /// Base rewards value for Type 3 nodes
-    pub value: XDRPermyriad,
+    pub daily_xdr_permyriad: Decimal,
 }
 
 #[derive(Serialize, Deserialize, Debug, PartialEq, Clone)]
 pub struct DailyNodeProviderRewards {
     /// Total rewards across all nodes for this provider in XDR permyriad
-    pub rewards_total: XDRPermyriad,
+    pub rewards_total_xdr_permyriad: Decimal,
 
     /// Base rewards broken down by node type and region
-    pub base_rewards: Vec<BaseRewardsSpec>,
+    pub base_rewards: Vec<NodeTypeRegionBaseRewards>,
 
     /// Base rewards broken down by "type 3" grouping (region aggregates)
-    pub type3_base_rewards: Vec<Type3BaseRewards>,
+    pub type3_base_rewards: Vec<Type3RegionBaseRewards>,
 
     /// Daily rewards for each node managed by this provider
     pub daily_nodes_rewards: Vec<DailyNodeRewards>,
@@ -149,7 +145,7 @@ pub struct DailyNodeProviderRewards {
 #[derive(Serialize, Deserialize)]
 pub struct DailyResults {
     /// Failure rates for all subnets on this day
-    pub subnets_fr: BTreeMap<SubnetId, Percent>,
+    pub subnets_fr_percent: BTreeMap<SubnetId, Decimal>,
 
     /// Rewards for all node providers on this day
     pub provider_results: BTreeMap<PrincipalId, DailyNodeProviderRewards>,
diff --git a/rs/node_rewards/rewards_calculation/src/performance_based_algorithm/v1.rs b/rs/node_rewards/rewards_calculation/src/performance_based_algorithm/v1.rs
index dc260d44d7..0e2bfef9ee 100644
--- a/rs/node_rewards/rewards_calculation/src/performance_based_algorithm/v1.rs
+++ b/rs/node_rewards/rewards_calculation/src/performance_based_algorithm/v1.rs
@@ -107,12 +107,12 @@ mod tests {
         let original_nodes_fr: BTreeMap<_, _> = result
             .nodes_metrics_daily
             .iter()
-            .map(|(k, v)| (*k, v.original_fr))
+            .map(|(k, v)| (*k, v.original_fr_percent))
             .collect();
         let relative_nodes_fr: BTreeMap<_, _> = result
             .nodes_metrics_daily
             .iter()
-            .map(|(k, v)| (*k, v.relative_fr))
+            .map(|(k, v)| (*k, v.relative_fr_percent))
             .collect();
 
         // --- Assertions for Day 1, Subnet 1 ---
@@ -148,12 +148,12 @@ mod tests {
         let original_nodes_fr: BTreeMap<_, _> = result
             .nodes_metrics_daily
             .iter()
-            .map(|(k, v)| (*k, v.original_fr))
+            .map(|(k, v)| (*k, v.original_fr_percent))
             .collect();
         let relative_nodes_fr: BTreeMap<_, _> = result
             .nodes_metrics_daily
             .iter()
-            .map(|(k, v)| (*k, v.relative_fr))
+            .map(|(k, v)| (*k, v.relative_fr_percent))
             .collect();
 
         // --- Assertions for Day 2, Subnet 1 ---
```

---

### Commit `55d5612325bfea80a32845c0eec023ed58c4d173`

**Author:** pietrodimarco-dfinity <124565147+pietrodimarco-dfinity@users.noreply.github.com>  
**Date:** 2025-10-13  
**Message:** feat(node-rewards-canister): Compute rewards over single day for all node providers (#7071)

**Files Changed:**
- `rs/node_rewards/canister/CHANGELOG.md`
- `rs/node_rewards/canister/api/BUILD.bazel`
- `rs/node_rewards/canister/api/Cargo.toml`
- `rs/node_rewards/canister/api/src/api_native_conversion.rs`
- `rs/node_rewards/canister/api/src/lib.rs`
- `rs/node_rewards/canister/api/src/provider_rewards_calculation.rs`
- `rs/node_rewards/canister/node-rewards-canister.did`
- `rs/node_rewards/canister/src/api_conversion.rs`
- `rs/node_rewards/canister/src/canister/mod.rs`
- `rs/node_rewards/canister/src/lib.rs`
- `rs/node_rewards/canister/src/main.rs`
- `rs/node_rewards/canister/tests/get_node_providers_monthly_xdr_rewards.rs`
- `rs/node_rewards/rewards_calculation/src/performance_based_algorithm/mod.rs`
- `rs/node_rewards/rewards_calculation/src/performance_based_algorithm/results.rs`
- `rs/node_rewards/rewards_calculation/src/performance_based_algorithm/v1.rs`

**Code Changes:**

```diff
commit 55d5612325bfea80a32845c0eec023ed58c4d173
Author: pietrodimarco-dfinity <124565147+pietrodimarco-dfinity@users.noreply.github.com>
Date:   Mon Oct 13 15:35:54 2025 +0200

    feat(node-rewards-canister): Compute rewards over single day for all node providers (#7071)
    
    Modified the `get_rewards_calculation` API.
    No external changes, as the API is not yet in use.
    
    Changes include:
    - Compute rewards for all node providers over a single day, instead of
    calculating the full reward period for a single provider.
    - Add detailed comments explaining the attributes in the rewards
    calculation results.
    - Move API type conversions to the appropriate module for better
    organization.

diff --git a/rs/node_rewards/canister/CHANGELOG.md b/rs/node_rewards/canister/CHANGELOG.md
index fb9ef5a1ea..944c5341ef 100644
--- a/rs/node_rewards/canister/CHANGELOG.md
+++ b/rs/node_rewards/canister/CHANGELOG.md
@@ -2,7 +2,6 @@
 
 INSERT NEW RELEASES HERE
 
-
 # 2025-09-06: Proposal 138378
 
 https://dashboard.internetcomputer.org/proposal/138378
@@ -26,10 +25,10 @@ http://dashboard.internetcomputer.org/proposal/138288
 
 * Fix rewards calculation algorithm to extrapolate with 0% failure rate node's performance for node providers with no
   assigned nodes on a given day.
-* Replicated execution of the query endpoints `get_node_provider_rewards_calculation` and `get_historical_reward_periods`
+* Replicated execution of the query endpoints `get_node_providers_rewards_calculation` and
+  `get_historical_reward_periods`
   is disabled.
 
-
 # 2025-08-15: Proposal 137910
 
 http://dashboard.internetcomputer.org/proposal/137910
diff --git a/rs/node_rewards/canister/api/BUILD.bazel b/rs/node_rewards/canister/api/BUILD.bazel
index d178c2ea23..381e0b7789 100644
--- a/rs/node_rewards/canister/api/BUILD.bazel
+++ b/rs/node_rewards/canister/api/BUILD.bazel
@@ -6,10 +6,12 @@ DEPENDENCIES = [
     # Keep sorted.
     "//rs/nervous_system/proto",
     "//rs/node_rewards/rewards_calculation",
+    "//rs/protobuf",
     "//rs/types/base_types",
     "@crate_index//:candid",
     "@crate_index//:chrono_canisters",
     "@crate_index//:ic-cdk",
+    "@crate_index//:rust_decimal",
     "@crate_index//:serde",
 ]
 
diff --git a/rs/node_rewards/canister/api/Cargo.toml b/rs/node_rewards/canister/api/Cargo.toml
index 804ca0cc8f..f60e0508a4 100644
--- a/rs/node_rewards/canister/api/Cargo.toml
+++ b/rs/node_rewards/canister/api/Cargo.toml
@@ -14,5 +14,7 @@ candid = { workspace = true }
 ic-base-types = { path = "../../../types/base_types" }
 rewards-calculation = { path = "../../rewards_calculation" }
 ic-nervous-system-proto = { path = "../../../nervous_system/proto" }
+ic-protobuf = { path = "../../../protobuf" }
 serde = { workspace = true }
 chrono = { workspace = true }
+rust_decimal = "1.37.1"
diff --git a/rs/node_rewards/canister/api/src/api_native_conversion.rs b/rs/node_rewards/canister/api/src/api_native_conversion.rs
new file mode 100644
index 0000000000..9815939e56
--- /dev/null
+++ b/rs/node_rewards/canister/api/src/api_native_conversion.rs
@@ -0,0 +1,319 @@
+use crate::provider_rewards_calculation::{
+    BaseRewardsSpec, DailyNodeProviderRewards, DailyNodeRewards, DailyResults, NodeMetricsDaily,
+    NodeStatus, Type3BaseRewardsSpec,
+};
+use ic_base_types::{NodeId, SubnetId};
+use ic_nervous_system_proto::pb::v1::Decimal as DecimalProto;
+use ic_protobuf::registry::node::v1::NodeRewardType;
+use rewards_calculation::performance_based_algorithm::results as native_types;
+use rust_decimal::Decimal;
+
+// ================================================================================================
+// Conversion implementations for API types <-> Internal types
+// ================================================================================================
+
+// NodeMetricsDaily conversions
+impl From<native_types::NodeMetricsDaily> for NodeMetricsDaily {
+    fn from(src: native_types::NodeMetricsDaily) -> Self {
+        Self {
+            subnet_assigned: Some(src.subnet_assigned.get()),
+            subnet_assigned_fr_percent: Some(DecimalProto::from(src.subnet_assigned_fr)),
+            num_blocks_proposed: Some(src.num_blocks_proposed),
+            num_blocks_failed: Some(src.num_blocks_failed),
+            original_fr_percent: Some(DecimalProto::from(src.original_fr)),
+            relative_fr_percent: Some(DecimalProto::from(src.relative_fr)),
+        }
+    }
+}
+
+impl TryFrom<NodeMetricsDaily> for native_types::NodeMetricsDaily {
+    type Error = String;
+
+    fn try_from(src: NodeMetricsDaily) -> Result<Self, Self::Error> {
+        Ok(Self {
+            subnet_assigned: SubnetId::from(
+                src.subnet_assigned
+                    .ok_or("subnet_assigned is missing (from NodeMetricsDaily).")?,
+            ),
+            subnet_assigned_fr: Decimal::try_from(
+                src.subnet_assigned_fr_percent
+                    .ok_or("subnet_assigned_fr_percent is missing (from NodeMetricsDaily).")?,
+            )?,
+            num_blocks_proposed: src
+                .num_blocks_proposed
+                .ok_or("num_blocks_proposed is missing (from NodeMetricsDaily).")?,
+            num_blocks_failed: src
+                .num_blocks_failed
+                .ok_or("num_blocks_failed is missing (from NodeMetricsDaily).")?,
+            original_fr: Decimal::try_from(
+                src.original_fr_percent
+                    .ok_or("original_fr_percent is missing (from NodeMetricsDaily).")?,
+            )?,
+            relative_fr: Decimal::try_from(
+                src.relative_fr_percent
+                    .ok_or("relative_fr_percent is missing (from NodeMetricsDaily).")?,
+            )?,
+        })
+    }
+}
+
+// NodeStatus conversions
+impl From<native_types::NodeStatus> for NodeStatus {
+    fn from(src: native_types::NodeStatus) -> Self {
+        match src {
+            native_types::NodeStatus::Assigned { node_metrics } => Self::Assigned {
+                node_metrics: Some(NodeMetricsDaily::from(node_metrics)),
+            },
+            native_types::NodeStatus::Unassigned { extrapolated_fr } => Self::Unassigned {
+                extrapolated_fr_percent: Some(DecimalProto::from(extrapolated_fr)),
+            },
+        }
+    }
+}
+
+impl TryFrom<NodeStatus> for native_types::NodeStatus {
+    type Error = String;
+
+    fn try_from(src: NodeStatus) -> Result<Self, Self::Error> {
+        match src {
+            NodeStatus::Assigned { node_metrics } => Ok(Self::Assigned {
+                node_metrics: native_types::NodeMetricsDaily::try_from(
+                    node_metrics.ok_or("node_metrics is missing (from NodeStatus).")?,
+                )?,
+            }),
+            NodeStatus::Unassigned {
+                extrapolated_fr_percent,
+            } => Ok(Self::Unassigned {
+                extrapolated_fr: Decimal::try_from(
+                    extrapolated_fr_percent
+                        .ok_or("extrapolated_fr_percent is missing (from NodeStatus).")?,
+                )?,
+            }),
+        }
+    }
+}
+
+// DailyNodeRewards conversions
+impl From<native_types::DailyNodeRewards> for DailyNodeRewards {
+    fn from(src: native_types::DailyNodeRewards) -> Self {
+        Self {
+            node_id: Some(src.node_id.get()),
+            node_reward_type: Some(src.node_reward_type.to_string()),
+            region: Some(src.region),
+            dc_id: Some(src.dc_id),
+            node_status: Some(NodeStatus::from(src.node_status)),
+            performance_multiplier_percent: Some(DecimalProto::from(src.performance_multiplier)),
+            rewards_reduction_percent: Some(DecimalProto::from(src.rewards_reduction)),
+            base_rewards_xdr_permyriad: Some(DecimalProto::from(src.base_rewards)),
+            adjusted_rewards_xdr_permyriad: Some(DecimalProto::from(src.adjusted_rewards)),
+        }
+    }
+}
+
+impl TryFrom<DailyNodeRewards> for native_types::DailyNodeRewards {
+    type Error = String;
+    fn try_from(src: DailyNodeRewards) -> Result<Self, Self::Error> {
+        Ok(Self {
+            node_id: NodeId::from(
+                src.node_id
+                    .ok_or("node_id is missing (from DailyNodeRewards).")?,
+            ),
+            node_reward_type: NodeRewardType::from(
+                src.node_reward_type
+                    .ok_or("node_reward_type is missing (from DailyNodeRewards).")?,
+            ),
+            region: src
+                .region
+                .ok_or("region is missing (from DailyNodeRewards).")?,
+            dc_id: src
+                .dc_id
+                .ok_or("dc_id is missing (from DailyNodeRewards).")?,
+            node_status: native_types::NodeStatus::try_from(
+                src.node_status
+                    .ok_or("node_status is missing (from DailyNodeRewards).")?,
+            )?,
+            performance_multiplier: Decimal::try_from(
+                src.performance_multiplier_percent
+                    .ok_or("performance_multiplier_percent is missing (from DailyNodeRewards).")?,
+            )?,
+            rewards_reduction: Decimal::try_from(
+                src.rewards_reduction_percent
+                    .ok_or("rewards_reduction_percent is missing (from DailyNodeRewards).")?,
+            )?,
+            base_rewards: Decimal::try_from(
+                src.base_rewards_xdr_permyriad
+                    .ok_or("base_rewards_xdr_permyriad is missing (from DailyNodeRewards).")?,
+            )?,
+            adjusted_rewards: Decimal::try_from(
+                src.adjusted_rewards_xdr_permyriad
+                    .ok_or("adjusted_rewards_xdr_permyriad is missing (from DailyNodeRewards).")?,
+            )?,
+        })
+    }
+}
+
+// BaseRewards conversions
+impl From<native_types::BaseRewardsSpec> for BaseRewardsSpec {
+    fn from(src: native_types::BaseRewardsSpec) -> Self {
+        Self {
+            monthly_xdr_permyriad: Some(DecimalProto::from(src.monthly)),
+            daily_xdr_permyriad: Some(DecimalProto::from(src.daily)),
+            node_reward_type: Some(src.node_reward_type.to_string()),
+            region: Some(src.region),
+        }
+    }
+}
+
+impl TryFrom<BaseRewardsSpec> for native_types::BaseRewardsSpec {
+    type Error = String;
+
+    fn try_from(src: BaseRewardsSpec) -> Result<Self, Self::Error> {
+        Ok(Self {
+            node_reward_type: NodeRewardType::from(
+                src.node_reward_type
+                    .ok_or("node_reward_type is missing (from BaseRewards).")?,
+            ),
+            region: src.region.ok_or("region is missing (from BaseRewards).")?,
+            monthly: Decimal::try_from(
+                src.monthly_xdr_permyriad
+                    .ok_or("monthly_xdr_permyriad is missing (from BaseRewards).")?,
+            )?,
+            daily: Decimal::try_from(
+                src.daily_xdr_permyriad
+                    .ok_or("daily_xdr_permyriad is missing (from BaseRewards).")?,
+            )?,
+        })
+    }
+}
+
+// Type3BaseRewards conversions
+impl From<native_types::Type3BaseRewards> for Type3BaseRewardsSpec {
+    fn from(src: native_types::Type3BaseRewards) -> Self {
+        Self {
+            region: Some(src.region),
+            nodes_count: Some(src.nodes_count as u64),
+            avg_rewards_xdr_permyriad: Some(DecimalProto::from(src.avg_rewards)),
+            avg_coefficient_percent: Some(DecimalProto::from(src.avg_coefficient)),
+            value_xdr_permyriad: Some(DecimalProto::from(src.value)),
+        }
+    }
+}
+
+impl TryFrom<Type3BaseRewardsSpec> for native_types::Type3BaseRewards {
+    type Error = String;
+
+    fn try_from(value: Type3BaseRewardsSpec) -> Result<Self, Self::Error> {
+        Ok(Self {
+            region: value
+                .region
+                .ok_or("region is missing (from Type3BaseRewards).")?,
+            nodes_count: value
+                .nodes_count
+                .ok_or("nodes_count is missing (from Type3BaseRewards).")?
+                as usize,
+            avg_rewards: Decimal::try_from(
+                value
+                    .avg_rewards_xdr_permyriad
+                    .ok_or("avg_rewards_xdr_permyriad is missing (from Type3BaseRewards).")?,
+            )?,
+            avg_coefficient: Decimal::try_from(
+                value
+                    .avg_coefficient_percent
+                    .ok_or("avg_coefficient_percent is missing (from Type3BaseRewards).")?,
+            )?,
+            value: Decimal::try_from(
+                value
+                    .value_xdr_permyriad
+                    .ok_or("value_xdr_permyriad is missing (from Type3BaseRewards).")?,
+            )?,
+        })
+    }
+}
+
+// DailyNodeProviderRewards conversions
+impl From<native_types::DailyNodeProviderRewards> for DailyNodeProviderRewards {
+    fn from(src: native_types::DailyNodeProviderRewards) -> Self {
+        Self {
+            rewards_total_xdr_permyriad: Some(DecimalProto::from(src.rewards_total)),
+            base_rewards: src
+                .base_rewards
+                .into_iter()
+                .map(BaseRewardsSpec::from)
+                .collect(),
+            base_rewards_type3: src
+                .type3_base_rewards
+                .into_iter()
+                .map(Type3BaseRewardsSpec::from)
+                .collect(),
+            daily_nodes_rewards: src
+                .daily_nodes_rewards
+                .into_iter()
+                .map(DailyNodeRewards::from)
+                .collect(),
+        }
+    }
+}
+
+impl TryFrom<DailyNodeProviderRewards> for native_types::DailyNodeProviderRewards {
+    type Error = String;
+
+    fn try_from(src: DailyNodeProviderRewards) -> Result<Self, Self::Error> {
+        Ok(Self {
+            rewards_total: Decimal::try_from(src.rewards_total_xdr_permyriad.ok_or(
+                "rewards_total_xdr_permyriad is missing (from DailyNodeProviderRewards).",
+            )?)?,
+            base_rewards: src
+                .base_rewards
+                .into_iter()
+                .map(native_types::BaseRewardsSpec::try_from)
+                .collect::<Result<_, _>>()?,
+            type3_base_rewards: src
+                .base_rewards_type3
+                .into_iter()
+                .map(native_types::Type3BaseRewards::try_from)
+                .collect::<Result<_, _>>()?,
+            daily_nodes_rewards: src
+                .daily_nodes_rewards
+                .into_iter()
+                .map(native_types::DailyNodeRewards::try_from)
+                .collect::<Result<_, _>>()?,
+        })
+    }
+}
+
+// DailyResults conversions
+impl From<native_types::DailyResults> for DailyResults {
+    fn from(src: native_types::DailyResults) -> Self {
+        Self {
+            subnets_fr: src
+                .subnets_fr
+                .into_iter()
+                .map(|(k, v)| (k, DecimalProto::from(v)))
+                .collect(),
+            provider_results: src
+                .provider_results
+                .into_iter()
+                .map(|(k, v)| (k, DailyNodeProviderRewards::from(v)))
+                .collect(),
+        }
+    }
+}
+
+impl TryFrom<DailyResults> for native_types::DailyResults {
+    type Error = String;
+
+    fn try_from(src: DailyResults) -> Result<Self, Self::Error> {
+        Ok(Self {
+            subnets_fr: src
+                .subnets_fr
+                .into_iter()
+                .map(|(k, v)| Decimal::try_from(v).map(|dec| (k, dec)))
+                .collect::<Result<_, _>>()?,
+            provider_results: src
+                .provider_results
+                .into_iter()
+                .map(|(k, v)| native_types::DailyNodeProviderRewards::try_from(v).map(|v| (k, v)))
+                .collect::<Result<_, _>>()?,
+        })
+    }
+}
diff --git a/rs/node_rewards/canister/api/src/lib.rs b/rs/node_rewards/canister/api/src/lib.rs
index 291111bd85..906fae078b 100644
--- a/rs/node_rewards/canister/api/src/lib.rs
+++ b/rs/node_rewards/canister/api/src/lib.rs
@@ -2,6 +2,8 @@ pub mod monthly_rewards;
 pub mod provider_rewards_calculation;
 pub mod providers_rewards;
 
+mod api_native_conversion;
+
 use chrono::{DateTime, Datelike, NaiveDate};
 use std::fmt::Display;
 
diff --git a/rs/node_rewards/canister/api/src/provider_rewards_calculation.rs b/rs/node_rewards/canister/api/src/provider_rewards_calculation.rs
index d14dbb47ea..1e41f9f506 100644
--- a/rs/node_rewards/canister/api/src/provider_rewards_calculation.rs
+++ b/rs/node_rewards/canister/api/src/provider_rewards_calculation.rs
@@ -1,20 +1,22 @@
 pub use crate::DateUtc;
-use candid::{CandidType, Deserialize, Principal};
-use ic_base_types::PrincipalId;
+use candid::{CandidType, Deserialize};
+use ic_base_types::{PrincipalId, SubnetId};
 use ic_nervous_system_proto::pb::v1::Decimal;
+use std::collections::BTreeMap;
 
 #[derive(CandidType, Clone, Deserialize)]
-pub struct GetNodeProviderRewardsCalculationRequest {
-    pub from_day: DateUtc,
-    pub to_day: DateUtc,
-    pub provider_id: Principal,
+pub struct GetNodeProvidersRewardsCalculationRequest {
+    pub day: DateUtc,
 }
 
-pub type GetNodeProviderRewardsCalculationResponse = Result<Vec<NodeProviderRewardsDaily>, String>;
+// TODO: Remove useless level of indirection: https://github.com/dfinity/ic/pull/7071/files#r2406450031
+pub type GetNodeProviderRewardsCalculationResponse = Result<DailyResults, String>;
 
 // These are API-facing types with all fields wrapped in `Option`
 // to ensure forward compatibility. This way, new fields can be added
 // in the future without breaking clients that consume the API.
+//
+// Check rewards_calculation/performance_based_algorithm/results.rs for the explanations of the fields.
 #[derive(candid::CandidType, candid::Deserialize, Clone, PartialEq, Debug)]
 pub struct NodeMetricsDaily {
     pub subnet_assigned: Option<PrincipalId>,
@@ -34,7 +36,7 @@ pub enum NodeStatus {
     },
 }
 #[derive(candid::CandidType, candid::Deserialize, Clone, PartialEq, Debug)]
-pub struct NodeResults {
+pub struct DailyNodeRewards {
     pub node_id: Option<PrincipalId>,
     pub node_reward_type: Option<String>,
     pub region: Option<String>,
@@ -46,14 +48,14 @@ pub struct NodeResults {
     pub adjusted_rewards_xdr_permyriad: Option<Decimal>,
 }
 #[derive(candid::CandidType, candid::Deserialize, Clone, PartialEq, Debug)]
-pub struct BaseRewards {
+pub struct BaseRewardsSpec {
     pub monthly_xdr_permyriad: Option<Decimal>,
     pub daily_xdr_permyriad: Option<Decimal>,
     pub node_reward_type: Option<String>,
     pub region: Option<String>,
 }
 #[derive(candid::CandidType, candid::Deserialize, Clone, PartialEq, Debug)]
-pub struct BaseRewardsType3 {
+pub struct Type3BaseRewardsSpec {
     pub region: Option<String>,
     pub nodes_count: Option<u64>,
     pub avg_rewards_xdr_permyriad: Option<Decimal>,
@@ -61,15 +63,14 @@ pub struct BaseRewardsType3 {
     pub value_xdr_permyriad: Option<Decimal>,
 }
 #[derive(candid::CandidType, candid::Deserialize, Clone, PartialEq, Debug)]
-pub struct NodeProviderRewards {
+pub struct DailyNodeProviderRewards {
     pub rewards_total_xdr_permyriad: Option<Decimal>,
-    pub base_rewards: Vec<BaseRewards>,
-    pub base_rewards_type3: Vec<BaseRewardsType3>,
-    pub nodes_results: Vec<NodeResults>,
+    pub base_rewards: Vec<BaseRewardsSpec>,
+    pub base_rewards_type3: Vec<Type3BaseRewardsSpec>,
+    pub daily_nodes_rewards: Vec<DailyNodeRewards>,
 }
-
-#[derive(CandidType, candid::Deserialize, Clone, Debug)]
-pub struct NodeProviderRewardsDaily {
-    pub day_utc: Option<DateUtc>,
-    pub node_provider_rewards: Option<NodeProviderRewards>,
+#[derive(candid::CandidType, candid::Deserialize, Clone, PartialEq, Debug)]
+pub struct DailyResults {
+    pub subnets_fr: BTreeMap<SubnetId, Decimal>,
+    pub provider_results: BTreeMap<PrincipalId, DailyNodeProviderRewards>,
 }
diff --git a/rs/node_rewards/canister/node-rewards-canister.did b/rs/node_rewards/canister/node-rewards-canister.did
index f3dfb75a78..85fd0c27a9 100644
--- a/rs/node_rewards/canister/node-rewards-canister.did
+++ b/rs/node_rewards/canister/node-rewards-canister.did
@@ -1,4 +1,4 @@
-// get_node_provider_rewards_calculation
+// get_node_providers_rewards_calculation
 
 type Decimal = record {
   human_readable: opt text;
@@ -24,7 +24,7 @@ type NodeStatus = variant {
   Unassigned: record { extrapolated_fr_percent: opt Decimal };
 };
 
-type NodeResults = record {
+type DailyNodeRewards = record {
   node_id: opt principal;
   node_reward_type: opt text;
   region: opt text;
@@ -36,14 +36,14 @@ type NodeResults = record {
   adjusted_rewards_xdr_permyriad: opt Decimal;
 };
 
-type BaseRewards = record {
+type BaseRewardsSpec = record {
   monthly_xdr_permyriad: opt Decimal;
   daily_xdr_permyriad: opt Decimal;
   node_reward_type: opt text;
   region: opt text;
 };
 
-type BaseRewardsType3 = record {
+type Type3BaseRewardsSpec = record {
   region: opt text;
   nodes_count: opt nat64;
   avg_rewards_xdr_permyriad: opt Decimal;
@@ -51,24 +51,22 @@ type BaseRewardsType3 = record {
   value_xdr_permyriad: opt Decimal;
 };
 
-type NodeProviderRewards = record {
+type DailyNodeProviderRewards = record {
   rewards_total_xdr_permyriad: opt Decimal;
-  base_rewards: vec BaseRewards;
-  base_rewards_type3: vec BaseRewardsType3;
-  nodes_results: vec NodeResults;
+  base_rewards: vec BaseRewardsSpec;
+  base_rewards_type3: vec Type3BaseRewardsSpec;
+  daily_nodes_rewards: vec DailyNodeRewards;
 };
 
-type NodeProviderRewardsDaily = record {
-    day_utc: opt DateUtc;
-    node_provider_rewards: opt NodeProviderRewards;
+type DailyResults = record {
+    subnets_fr: vec record { principal; Decimal };
+    provider_results: vec record { principal; DailyNodeProviderRewards };
 };
 
-type GetNodeProviderRewardsCalculationResponse = variant { Ok: vec NodeProviderRewardsDaily; Err: text };
+type GetNodeProviderRewardsCalculationResponse = variant { Ok: DailyResults; Err: text };
 
-type GetNodeProviderRewardsCalculationRequest = record {
-  from_day: DateUtc;
-  to_day: DateUtc;
-  provider_id: principal;
+type GetNodeProvidersRewardsCalculationRequest = record {
+  day: DateUtc;
 };
 
 // get_node_providers_rewards
@@ -109,5 +107,5 @@ service: () -> {
         GetNodeProvidersMonthlyXdrRewardsResponse
     );
     get_node_providers_rewards: (GetNodeProvidersRewardsRequest) -> (GetNodeProvidersRewardsResponse);
-    get_node_provider_rewards_calculation: (GetNodeProviderRewardsCalculationRequest) -> (GetNodeProviderRewardsCalculationResponse) query;
+    get_node_providers_rewards_calculation: (GetNodeProvidersRewardsCalculationRequest) -> (GetNodeProviderRewardsCalculationResponse) query;
 }
diff --git a/rs/node_rewards/canister/src/api_conversion.rs b/rs/node_rewards/canister/src/api_conversion.rs
deleted file mode 100644
index 02079e373f..0000000000
--- a/rs/node_rewards/canister/src/api_conversion.rs
+++ /dev/null
@@ -1,96 +0,0 @@
-use ic_base_types::PrincipalId;
-use ic_node_rewards_canister_api::provider_rewards_calculation::{
-    BaseRewards as BaseRewardsCandid, BaseRewardsType3 as BaseRewardsType3Candid,
-    GetNodeProviderRewardsCalculationResponse, NodeMetricsDaily as NodeMetricsDailyCandid,
-    NodeProviderRewards as NodeProviderRewardsCandid, NodeProviderRewardsDaily,
-    NodeResults as NodeResultsCandid, NodeStatus as NodeStatusCandid,
-};
-use rewards_calculation::performance_based_algorithm::results::{
-    NodeStatus, RewardsCalculatorResults,
-};
-
-pub fn into_rewards_calculation_results(
-    results: RewardsCalculatorResults,
-    provider_id: PrincipalId,
-) -> GetNodeProviderRewardsCalculationResponse {
-    let mut daily_rewards: Vec<NodeProviderRewardsDaily> = Vec::new();
-
-    for (day, mut daily_results) in results.daily_results {
-        let daily_provider_results = daily_results
-            .provider_results
-            .remove(&provider_id)
-            .ok_or(format!("No results found for provider_id: {}", provider_id))?;
-
-        let nodes_results = daily_provider_results
-            .nodes_results
-            .iter()
-            .map(|nr| NodeResultsCandid {
-                node_id: Some(nr.node_id.get()),
-                node_reward_type: Some(nr.node_reward_type.to_string()),
-                region: Some(nr.region.clone()),
-                dc_id: Some(nr.dc_id.clone()),
-                node_status: match &nr.node_status {
-                    NodeStatus::Assigned { node_metrics } => Some(NodeStatusCandid::Assigned {
-                        node_metrics: Some(NodeMetricsDailyCandid {
-                            subnet_assigned: Some(node_metrics.subnet_assigned.get()),
-                            subnet_assigned_fr_percent: Some(
-                                node_metrics.subnet_assigned_fr.into(),
-                            ),
-                            num_blocks_proposed: Some(node_metrics.num_blocks_proposed),
-                            num_blocks_failed: Some(node_metrics.num_blocks_failed),
-                            original_fr_percent: Some(node_metrics.original_fr.into()),
-                            relative_fr_percent: Some(node_metrics.relative_fr.into()),
-                        }),
-                    }),
-                    NodeStatus::Unassigned { extrapolated_fr } => {
-                        Some(NodeStatusCandid::Unassigned {
-                            extrapolated_fr_percent: Some((*extrapolated_fr).into()),
-                        })
-                    }
-                },
-                performance_multiplier_percent: Some(nr.performance_multiplier.into()),
-                rewards_reduction_percent: Some(nr.rewards_reduction.into()),
-                base_rewards_xdr_permyriad: Some(nr.base_rewards.into()),
-                adjusted_rewards_xdr_permyriad: Some(nr.adjusted_rewards.into()),
-            })
-            .collect();
-
-        // Map BaseRewards
-        let base_rewards = daily_provider_results
-            .base_rewards
-            .iter()
-            .map(|br| BaseRewardsCandid {
-                monthly_xdr_permyriad: Some(br.monthly.into()),
-                daily_xdr_permyriad: Some(br.daily.into()),
-                node_reward_type: Some(br.node_reward_type.to_string()),
-                region: Some(br.region.clone()),
-            })
-            .collect();
-
-        // Map BaseRewardsType3
-        let base_rewards_type3 = daily_provider_results
-            .base_rewards_type3
-            .iter()
-            .map(|br3| BaseRewardsType3Candid {
-                region: Some(br3.region.clone()),
-                nodes_count: Some(br3.nodes_count as u64),
-                avg_rewards_xdr_permyriad: Some(br3.avg_rewards.into()),
-                avg_coefficient_percent: Some(br3.avg_coefficient.into()),
-                value_xdr_permyriad: Some(br3.value.into()),
-            })
-            .collect();
-
-        let node_provider_rewards = NodeProviderRewardsCandid {
-            rewards_total_xdr_permyriad: Some(daily_provider_results.rewards_total.into()),
-            base_rewards,
-            base_rewards_type3,
-            nodes_results,
-        };
-
-        daily_rewards.push(NodeProviderRewardsDaily {
-            day_utc: Some(day.into()),
-            node_provider_rewards: Some(node_provider_rewards),
-        });
-    }
-    Ok(daily_rewards)
-}
diff --git a/rs/node_rewards/canister/src/canister/mod.rs b/rs/node_rewards/canister/src/canister/mod.rs
index 5ab8ca38fb..7d37f3f77a 100644
--- a/rs/node_rewards/canister/src/canister/mod.rs
+++ b/rs/node_rewards/canister/src/canister/mod.rs
@@ -1,4 +1,3 @@
-use crate::api_conversion::into_rewards_calculation_results;
 use crate::chrono_utils::last_unix_timestamp_nanoseconds;
 use crate::metrics::MetricsManager;
 use crate::registry_querier::RegistryQuerier;
@@ -11,7 +10,8 @@ use ic_node_rewards_canister_api::monthly_rewards::{
     NodeProvidersMonthlyXdrRewards,
 };
 use ic_node_rewards_canister_api::provider_rewards_calculation::{
-    GetNodeProviderRewardsCalculationRequest, GetNodeProviderRewardsCalculationResponse,
+    DailyResults, GetNodeProviderRewardsCalculationResponse,
+    GetNodeProvidersRewardsCalculationRequest,
 };
 use ic_node_rewards_canister_api::providers_rewards::{
     GetNodeProvidersRewardsRequest, GetNodeProvidersRewardsResponse, NodeProvidersRewards,
@@ -145,13 +145,12 @@ impl NodeRewardsCanister {
     fn calculate_rewards(
         &self,
         request: GetNodeProvidersRewardsRequest,
-        provider_filter: Option<PrincipalId>,
     ) -> Result<RewardsCalculatorResults, String> {
         let start_day = NaiveDate::try_from(request.from_day)?;
         let end_day = NaiveDate::try_from(request.to_day)?;
         Self::validate_reward_period(&start_day, &end_day)?;
 
-        RewardsCalculationV1::calculate_rewards(&start_day, &end_day, provider_filter, self)
+        RewardsCalculationV1::calculate_rewards(&start_day, &end_day, self)
             .map_err(|e| format!("Could not calculate rewards: {e:?}"))
     }
 }
@@ -190,22 +189,6 @@ impl rewards_calculation::performance_based_algorithm::DataProvider for &NodeRew
             .get_rewardable_nodes_per_provider(date, None)
             .map_err(|e| format!("Could not get rewardable nodes: {e:?}"))
     }
-
-    fn get_provider_rewardable_nodes(
-        &self,
-        date: &NaiveDate,
-        provider_id: &PrincipalId,
-    ) -> Result<Vec<RewardableNode>, String> {
-        let mut all_rewardable_nodes = self.get_rewardable_nodes(date)?;
-        let rewardable_nodes = all_rewardable_nodes.remove(provider_id).ok_or_else(|| {
-            format!(
-                "No rewardable nodes found for provider {} for day {}",
-                provider_id,
-                date.format("%Y-%m-%d")
-            )
-        })?;
-        Ok(rewardable_nodes)
-    }
 }
 
 // Exposed API Methods
@@ -293,7 +276,7 @@ impl NodeRewardsCanister {
                 )
             })?;
         NodeRewardsCanister::schedule_metrics_sync(canister).await;
-        let result = canister.with_borrow(|canister| canister.calculate_rewards(request, None))?;
+        let result = canister.with_borrow(|canister| canister.calculate_rewards(request))?;
 
         let rewards_xdr_permyriad = result
             .total_rewards_xdr_permyriad
@@ -306,18 +289,23 @@ impl NodeRewardsCanister {
         })
     }
 
-    pub fn get_node_provider_rewards_calculation(
+    pub fn get_node_providers_rewards_calculation(
         canister: &'static LocalKey<RefCell<NodeRewardsCanister>>,
-        request: GetNodeProviderRewardsCalculationRequest,
+        request: GetNodeProvidersRewardsCalculationRequest,
     ) -> GetNodeProviderRewardsCalculationResponse {
-        let provider_id = PrincipalId::from(request.provider_id);
         let request_inner = GetNodeProvidersRewardsRequest {
-            from_day: request.from_day,
-            to_day: request.to_day,
+            from_day: request.day,
+            to_day: request.day,
         };
-        let result = canister
-            .with_borrow(|canister| canister.calculate_rewards(request_inner, Some(provider_id)))?;
-        into_rewards_calculation_results(result, provider_id)
+        let mut result =
+            canister.with_borrow(|canister| canister.calculate_rewards(request_inner))?;
+
+        let day = NaiveDate::try_from(request.day)?;
+        let daily_results = result
+            .daily_results
+            .remove(&day)
+            .ok_or("Could not find daily results for the requested day")?;
+        Ok(DailyResults::from(daily_results))
     }
 }
 
diff --git a/rs/node_rewards/canister/src/lib.rs b/rs/node_rewards/canister/src/lib.rs
index b86c3d9dcc..a1161a5093 100644
--- a/rs/node_rewards/canister/src/lib.rs
+++ b/rs/node_rewards/canister/src/lib.rs
@@ -13,7 +13,6 @@ use ic_stable_structures::storable::Bound;
 use prost::Message;
 use std::borrow::Cow;
 
-pub mod api_conversion;
 pub mod canister;
 mod chrono_utils;
 pub mod metrics;
diff --git a/rs/node_rewards/canister/src/main.rs b/rs/node_rewards/canister/src/main.rs
index e05229c245..9a9a59d0a6 100644
--- a/rs/node_rewards/canister/src/main.rs
+++ b/rs/node_rewards/canister/src/main.rs
@@ -9,7 +9,7 @@ use ic_node_rewards_canister_api::monthly_rewards::{
     GetNodeProvidersMonthlyXdrRewardsRequest, GetNodeProvidersMonthlyXdrRewardsResponse,
 };
 use ic_node_rewards_canister_api::provider_rewards_calculation::{
-    GetNodeProviderRewardsCalculationRequest, GetNodeProviderRewardsCalculationResponse,
+    GetNodeProviderRewardsCalculationResponse, GetNodeProvidersRewardsCalculationRequest,
 };
 use ic_node_rewards_canister_api::providers_rewards::{
     GetNodeProvidersRewardsRequest, GetNodeProvidersRewardsResponse,
@@ -117,8 +117,8 @@ async fn get_node_providers_rewards(
 }
 
 #[query]
-fn get_node_provider_rewards_calculation(
-    request: GetNodeProviderRewardsCalculationRequest,
+fn get_node_providers_rewards_calculation(
+    request: GetNodeProvidersRewardsCalculationRequest,
 ) -> GetNodeProviderRewardsCalculationResponse {
     if in_replicated_execution() {
         return Err(
@@ -127,7 +127,7 @@ fn get_node_provider_rewards_calculation(
         );
     }
 
-    NodeRewardsCanister::get_node_provider_rewards_calculation(&CANISTER, request)
+    NodeRewardsCanister::get_node_providers_rewards_calculation(&CANISTER, request)
 }
 
 #[cfg(test)]
diff --git a/rs/node_rewards/canister/tests/get_node_providers_monthly_xdr_rewards.rs b/rs/node_rewards/canister/tests/get_node_providers_monthly_xdr_rewards.rs
index 6370987988..897bb5042f 100644
--- a/rs/node_rewards/canister/tests/get_node_providers_monthly_xdr_rewards.rs
+++ b/rs/node_rewards/canister/tests/get_node_providers_monthly_xdr_rewards.rs
@@ -1,4 +1,4 @@
-use candid::{Encode, Principal};
+use candid::Encode;
 use ic_nervous_system_agent::AgentFor;
 use ic_nervous_system_agent::nns::node_rewards::get_node_providers_monthly_xdr_rewards;
 use ic_nns_constants::NODE_REWARDS_CANISTER_ID;
@@ -6,7 +6,7 @@ use ic_nns_test_utils::common::build_node_rewards_test_wasm;
 use ic_node_rewards_canister_api::DateUtc;
 use ic_node_rewards_canister_api::monthly_rewards::GetNodeProvidersMonthlyXdrRewardsRequest;
 use ic_node_rewards_canister_api::provider_rewards_calculation::{
-    GetNodeProviderRewardsCalculationRequest, GetNodeProviderRewardsCalculationResponse,
+    GetNodeProviderRewardsCalculationResponse, GetNodeProvidersRewardsCalculationRequest,
 };
 use ic_types::PrincipalId;
 use pocket_ic::PocketIcBuilder;
@@ -68,7 +68,7 @@ async fn get_node_providers_monthly_xdr_rewards_is_only_callable_by_governance()
 }
 
 #[tokio::test]
-async fn get_node_provider_rewards_calculation_is_only_callable_in_nonreplicated_mode() {
+async fn get_node_providers_rewards_calculation_is_only_callable_in_nonreplicated_mode() {
     let pocket_ic = setup_env().await;
     let node_rewards_id = NODE_REWARDS_CANISTER_ID.get().0;
 
@@ -77,17 +77,13 @@ async fn get_node_provider_rewards_calculation_is_only_callable_in_nonreplicated
     pocket_ic.tick().await;
     let day = DateUtc::from_unix_timestamp_nanoseconds(past_time_nanos);
 
-    let request = GetNodeProviderRewardsCalculationRequest {
-        from_day: day,
-        to_day: day,
-        provider_id: Principal::anonymous(),
-    };
+    let request = GetNodeProvidersRewardsCalculationRequest { day };
 
     // Non-replicated query call is allowed.
     let err = query_candid::<_, (GetNodeProviderRewardsCalculationResponse,)>(
         &pocket_ic,
         node_rewards_id,
-        "get_node_provider_rewards_calculation",
+        "get_node_providers_rewards_calculation",
         (request.clone(),),
     )
     .await
@@ -103,7 +99,7 @@ async fn get_node_provider_rewards_calculation_is_only_callable_in_nonreplicated
     let err = update_candid::<_, (GetNodeProviderRewardsCalculationResponse,)>(
         &pocket_ic,
         node_rewards_id,
-        "get_node_provider_rewards_calculation",
+        "get_node_providers_rewards_calculation",
         (request,),
     )
     .await
diff --git a/rs/node_rewards/rewards_calculation/src/performance_based_algorithm/mod.rs b/rs/node_rewards/rewards_calculation/src/performance_based_algorithm/mod.rs
index c84eb6ea8d..7ca9d317f6 100644
--- a/rs/node_rewards/rewards_calculation/src/performance_based_algorithm/mod.rs
+++ b/rs/node_rewards/rewards_calculation/src/performance_based_algorithm/mod.rs
@@ -1,6 +1,6 @@
 use crate::performance_based_algorithm::results::{
-    BaseRewards, BaseRewardsType3, DailyResults, NodeMetricsDaily, NodeProviderRewards,
-    NodeResults, NodeStatus, Percent, RewardsCalculatorResults, XDRPermyriad,
+    BaseRewardsSpec, DailyNodeProviderRewards, DailyNodeRewards, DailyResults, NodeMetricsDaily,
+    NodeStatus, Percent, RewardsCalculatorResults, Type3BaseRewards, XDRPermyriad,
 };
 use crate::types::{NodeMetricsDailyRaw, Region, RewardableNode};
 use chrono::NaiveDate;
@@ -8,7 +8,6 @@ use ic_base_types::{NodeId, PrincipalId, SubnetId};
 use ic_protobuf::registry::node::v1::NodeRewardType;
 use ic_protobuf::registry::node_rewards::v2::NodeRewardsTable;
 use itertools::Itertools;
-use maplit::btreemap;
 use rust_decimal::Decimal;
 use rust_decimal::prelude::ToPrimitive;
 use rust_decimal_macros::dec;
@@ -59,8 +58,8 @@ struct PerformanceMultiplierResults {
 
 #[derive(Default)]
 struct BaseRewardsResults {
-    base_rewards: Vec<BaseRewards>,
-    base_rewards_type3: Vec<BaseRewardsType3>,
+    base_rewards: Vec<BaseRewardsSpec>,
+    base_rewards_type3: Vec<Type3BaseRewards>,
     base_rewards_per_node: BTreeMap<NodeId, XDRPermyriad>,
 }
 
@@ -83,12 +82,6 @@ pub trait DataProvider {
         &self,
         date: &NaiveDate,
     ) -> Result<BTreeMap<PrincipalId, Vec<RewardableNode>>, String>;
-
-    fn get_provider_rewardable_nodes(
-        &self,
-        date: &NaiveDate,
-        provider_id: &PrincipalId,
-    ) -> Result<Vec<RewardableNode>, String>;
 }
 
 trait PerformanceBasedAlgorithm {
@@ -118,7 +111,6 @@ trait PerformanceBasedAlgorithm {
     fn calculate_rewards(
         from_date: &NaiveDate,
         to_date: &NaiveDate,
-        node_provider_filter: Option<PrincipalId>,
         data_provider: impl DataProvider,
     ) -> Result<RewardsCalculatorResults, String> {
         if from_date > to_date {
@@ -131,8 +123,7 @@ trait PerformanceBasedAlgorithm {
 
         // Process each day in the reward period
         for day in reward_period {
-            let result_for_day =
-                Self::calculate_daily_rewards(&data_provider, &day, &node_provider_filter)?;
+            let result_for_day = Self::calculate_daily_rewards(&data_provider, &day)?;
 
             // Accumulate total rewards per provider across all days
             for (provider_id, provider_rewards) in &result_for_day.provider_results {
@@ -158,17 +149,10 @@ trait PerformanceBasedAlgorithm {
     fn calculate_daily_rewards(
         data_provider: &impl DataProvider,
         date: &NaiveDate,
-        node_provider_filter: &Option<PrincipalId>,
     ) -> Result<DailyResults, String> {
         let rewards_table = data_provider.get_rewards_table(date)?;
         let metrics_by_subnet = data_provider.get_daily_metrics_by_subnet(date)?;
-        let providers_rewardable_nodes = if let Some(provider_id) = node_provider_filter {
-            let rewardable_nodes =
-                data_provider.get_provider_rewardable_nodes(date, provider_id)?;
-            btreemap! { *provider_id => rewardable_nodes }
-        } else {
-            data_provider.get_rewardable_nodes(date)?
-        };
+        let providers_rewardable_nodes = data_provider.get_rewardable_nodes(date)?;
         let mut results_per_provider = BTreeMap::new();
 
         // Calculate failure rates for subnets and individual nodes
@@ -197,7 +181,7 @@ trait PerformanceBasedAlgorithm {
         rewards_table: &NodeRewardsTable,
         nodes_metrics_daily: &mut BTreeMap<NodeId, NodeMetricsDaily>,
         rewardable_nodes: Vec<RewardableNode>,
-    ) -> NodeProviderRewards {
+    ) -> DailyNodeProviderRewards {
         let mut provider_nodes_metrics_daily = BTreeMap::new();
         for node in &rewardable_nodes {
             if let Some(metrics) = nodes_metrics_daily.remove(&node.node_id) {
@@ -483,7 +467,7 @@ trait PerformanceBasedAlgorithm {
             .into_iter()
             .map(
                 |(region, (daily_rewards, nodes_count, avg_rewards, avg_coefficient))| {
-                    BaseRewardsType3 {
+                    Type3BaseRewards {
                         region,
                         nodes_count,
                         avg_rewards,
@@ -497,7 +481,7 @@ trait PerformanceBasedAlgorithm {
         let base_rewards = base_rewards
             .into_iter()
             .map(
-                |((node_reward_type, region), (daily_rewards, monthly_rewards))| BaseRewards {
+                |((node_reward_type, region), (daily_rewards, monthly_rewards))| BaseRewardsSpec {
                     node_reward_type,
                     region,
                     monthly: monthly_rewards,
@@ -545,9 +529,9 @@ trait PerformanceBasedAlgorithm {
         mut performance_multiplier: BTreeMap<NodeId, Percent>,
         mut base_rewards_per_node: BTreeMap<NodeId, XDRPermyriad>,
         mut adjusted_rewards: BTreeMap<NodeId, XDRPermyriad>,
-        base_rewards: Vec<BaseRewards>,
-        base_rewards_type3: Vec<BaseRewardsType3>,
-    ) -> NodeProviderRewards {
+        base_rewards: Vec<BaseRewardsSpec>,
+        base_rewards_type3: Vec<Type3BaseRewards>,
+    ) -> DailyNodeProviderRewards {
         let mut results_by_node = Vec::new();
         let mut rewards_total = Decimal::ZERO;
 
@@ -577,7 +561,7 @@ trait PerformanceBasedAlgorithm {
 
             rewards_total += adjusted_rewards_xdr_permyriad;
 
-            results_by_node.push(NodeResults {
+            results_by_node.push(DailyNodeRewards {
                 node_id: node.node_id,
                 node_reward_type: node.node_reward_type,
                 region: node.region,
@@ -590,11 +574,11 @@ trait PerformanceBasedAlgorithm {
             });
         }
 
-        NodeProviderRewards {
+        DailyNodeProviderRewards {
             rewards_total,
             base_rewards,
-            base_rewards_type3,
-            nodes_results: results_by_node,
+            type3_base_rewards: base_rewards_type3,
+            daily_nodes_rewards: results_by_node,
         }
     }
 }
diff --git a/rs/node_rewards/rewards_calculation/src/performance_based_algorithm/results.rs b/rs/node_rewards/rewards_calculation/src/performance_based_algorithm/results.rs
index 45eb704041..e384825ae3 100644
--- a/rs/node_rewards/rewards_calculation/src/performance_based_algorithm/results.rs
+++ b/rs/node_rewards/rewards_calculation/src/performance_based_algorithm/results.rs
@@ -5,71 +5,160 @@ use rust_decimal::Decimal;
 use serde::{Deserialize, Serialize};
 use std::collections::BTreeMap;
 
-pub type XDRPermyriad = Decimal;
+// TODO: Remove these types in favor of Decimal. Also fields renaming to include units
+// https://github.com/dfinity/ic/pull/7071/files#r2406492271
+pub type XDRPermyriad = Decimal; // Rewards unit in XDR scaled by 1/10,000 (permyriad)
 pub type Percent = Decimal;
 pub type Region = String;
 
 #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
 pub struct NodeMetricsDaily {
+    /// The subnet this node was assigned to on the given day.
+    /// This is determined by the subnet assigned to the node in the last registry version
+    /// before the next day's registry version was generated.
     pub subnet_assigned: SubnetId,
+
+    /// Subnet Assigned Failure Rate
+    ///
+    /// This is the SUBNET_FAILURE_RATE_PERCENTILE of the original_fr all nodes in the subnet.
+    /// It is used to adjust individual node failure rates to account for systematic issues
+    /// affecting the whole subnet.
     pub subnet_assigned_fr: Percent,
+
+    /// Number of blocks successfully proposed by this node on this day
     pub num_blocks_proposed: u64,
+
+    /// Number of blocks that failed to be included on this day
     pub num_blocks_failed: u64,
+
+    /// Original Failure Rate
+    ///
+    /// Calculated as `num_blocks_failed / (num_blocks_proposed + num_blocks_failed)`.
+    /// Represents the failure rate of the node before any subnet-level adjustments.
     pub original_fr: Percent,
+
+    /// Relative Failure Rate
+    ///
+    /// Failure rate adjusted for subnet performance.
+    /// Calculated as `max(0, original_fr - subnet_assigned_fr)`.
+    /// TODO: Link documentation about performance based rewards algorithm
     pub relative_fr: Percent,
 }
 
+// TODO: Renaming to NodeProductivity: https://github.com/dfinity/ic/pull/7071/files#r2406794563
 #[derive(Serialize, Deserialize, Debug, PartialEq, Clone)]
 pub enum NodeStatus {
+    /// Node is assigned to a subnet with recorded metrics
     Assigned { node_metrics: NodeMetricsDaily },
-    Unassigned { extrapolated_fr: Percent },
+
+    /// Node is unassigned; only extrapolated failure rate is available
+    Unassigned {
+        /// Extrapolated Failure Rate (EFR)
+        /// Used to estimate the node's performance when unassigned
+        extrapolated_fr: Percent,
+    },
 }
 
 #[derive(Serialize, Deserialize, Debug, PartialEq, Clone)]
-pub struct NodeResults {
+pub struct DailyNodeRewards {
     pub node_id: NodeId,
+
     pub node_reward_type: NodeRewardType,
+
+    /// Geographical region of the node
+    /// TODO: Link to documentation about performance based rewards
     pub region: String,
+
+    /// Data center identifier
+    /// TODO: Link to documentation about performance based rewards
     pub dc_id: String,
+
+    /// Node status, assigned or unassigned, with associated metrics
     pub node_status: NodeStatus,
+
+    /// Performance multiplier (1 - rewards_reduction)
+    ///
+    /// Represents how rewards are adjusted based on node performance
     pub performance_multiplier: Percent,
+
+    /// Rewards reduction applied due to failure rates
+    // TODO: Link to documentation about performance based rewards
     pub rewards_reduction: Percent,
+
+    /// Base rewards before applying performance multipliers
     pub base_rewards: XDRPermyriad,
+
+    /// Rewards adjusted by the performance multiplier
     pub adjusted_rewards: XDRPermyriad,
 }
 
+/// Base rewards for NON type 3 nodes.
 #[derive(Serialize, Deserialize, Debug, PartialEq, Clone)]
-pub struct BaseRewards {
+pub struct BaseRewardsSpec {
+    /// NodeRewardType
     pub node_reward_type: NodeRewardType,
+
+    /// Region for which base rewards are calculated
     pub region: Region,
+
+    /// Monthly base rewards in XDR permyriad
     pub monthly: XDRPermyriad,
+
+    /// Daily base rewards in XDR permyriad
     pub daily: XDRPermyriad,
 }
 
+/// Base rewards for a Type 3 node.
+///
+/// Type3 nodes are defined [rs/protobuf/src/gen/registry/registry.node.v1.rs]
+/// For nodes which are type3 special logic is applied to compute base rewards.
+/// Check the documentation of the performance-based rewards algorithm for details.
 #[derive(Serialize, Deserialize, Debug, PartialEq, Clone)]
-pub struct BaseRewardsType3 {
+pub struct Type3BaseRewards {
+    /// Region for which the rewards are calculated
     pub region: Region,
+
+    /// Number of nodes in the region
     pub nodes_count: usize,
+
+    /// Average rewards for nodes in this region
     pub avg_rewards: XDRPermyriad,
+
+    /// Average performance coefficient applied to nodes
     pub avg_coefficient: Percent,
+
+    /// Base rewards value for Type 3 nodes
     pub value: XDRPermyriad,
 }
 
 #[derive(Serialize, Deserialize, Debug, PartialEq, Clone)]
-pub struct NodeProviderRewards {
+pub struct DailyNodeProviderRewards {
+    /// Total rewards across all nodes for this provider in XDR permyriad
     pub rewards_total: XDRPermyriad,
-    pub base_rewards: Vec<BaseRewards>,
-    pub base_rewards_type3: Vec<BaseRewardsType3>,
-    pub nodes_results: Vec<NodeResults>,
+
+    /// Base rewards broken down by node type and region
+    pub base_rewards: Vec<BaseRewardsSpec>,
+
+    /// Base rewards broken down by "type 3" grouping (region aggregates)
+    pub type3_base_rewards: Vec<Type3BaseRewards>,
+
+    /// Daily rewards for each node managed by this provider
+    pub daily_nodes_rewards: Vec<DailyNodeRewards>,
 }
 
 #[derive(Serialize, Deserialize)]
 pub struct DailyResults {
+    /// Failure rates for all subnets on this day
     pub subnets_fr: BTreeMap<SubnetId, Percent>,
-    pub provider_results: BTreeMap<PrincipalId, NodeProviderRewards>,
+
+    /// Rewards for all node providers on this day
+    pub provider_results: BTreeMap<PrincipalId, DailyNodeProviderRewards>,
 }
 
 pub struct RewardsCalculatorResults {
+    /// Total rewards for each provider across the entire reward period
     pub total_rewards_xdr_permyriad: BTreeMap<PrincipalId, u64>,
+
+    /// Daily breakdown of results
     pub daily_results: BTreeMap<NaiveDate, DailyResults>,
 }
diff --git a/rs/node_rewards/rewards_calculation/src/performance_based_algorithm/v1.rs b/rs/node_rewards/rewards_calculation/src/performance_based_algorithm/v1.rs
index 6fb37bc87e..dc260d44d7 100644
--- a/rs/node_rewards/rewards_calculation/src/performance_based_algorithm/v1.rs
+++ b/rs/node_rewards/rewards_calculation/src/performance_based_algorithm/v1.rs
@@ -1,7 +1,6 @@
 use crate::performance_based_algorithm::results::RewardsCalculatorResults;
 use crate::performance_based_algorithm::{DataProvider, PerformanceBasedAlgorithm};
 use chrono::NaiveDate;
-use ic_base_types::PrincipalId;
 use rust_decimal::Decimal;
 use rust_decimal_macros::dec;
 
@@ -38,13 +37,11 @@ impl RewardsCalculationV1 {
     pub fn calculate_rewards(
         from_date: &NaiveDate,
         to_date: &NaiveDate,
-        node_provider_filter: Option<PrincipalId>,
         data_provider: impl DataProvider,
     ) -> Result<RewardsCalculatorResults, String> {
         <RewardsCalculationV1 as PerformanceBasedAlgorithm>::calculate_rewards(
             from_date,
             to_date,
-            node_provider_filter,
             data_provider,
         )
     }
```

---

### Commit `2851d16acbe87159f58348a9c9f4e10f34f488b9`

**Author:** pietrodimarco-dfinity <124565147+pietrodimarco-dfinity@users.noreply.github.com>  
**Date:** 2025-09-30  
**Message:** fix(node-rewards-canister): Discard DayUtc type in favor of NaiveDate (#6981)

**Files Changed:**
- `rs/node_rewards/canister/BUILD.bazel`
- `rs/node_rewards/canister/Cargo.toml`
- `rs/node_rewards/canister/api/BUILD.bazel`
- `rs/node_rewards/canister/api/Cargo.toml`
- `rs/node_rewards/canister/api/src/lib.rs`
- `rs/node_rewards/canister/api/src/provider_rewards_calculation.rs`
- `rs/node_rewards/canister/api/src/providers_rewards.rs`
- `rs/node_rewards/canister/node-rewards-canister.did`
- `rs/node_rewards/canister/src/canister/mod.rs`
- `rs/node_rewards/canister/src/canister/test/get_node_providers_rewards.rs`
- `rs/node_rewards/canister/src/chrono_utils.rs`
- `rs/node_rewards/canister/src/lib.rs`
- `rs/node_rewards/canister/src/metrics.rs`
- `rs/node_rewards/canister/src/metrics/tests.rs`
- `rs/node_rewards/canister/src/registry_querier.rs`
- `rs/node_rewards/canister/src/registry_querier/tests.rs`
- `rs/node_rewards/canister/tests/get_node_providers_monthly_xdr_rewards.rs`
- `rs/node_rewards/rewards_calculation/Cargo.toml`
- `rs/node_rewards/rewards_calculation/src/performance_based_algorithm/mod.rs`
- `rs/node_rewards/rewards_calculation/src/performance_based_algorithm/results.rs`
- `rs/node_rewards/rewards_calculation/src/performance_based_algorithm/v1.rs`
- `rs/node_rewards/rewards_calculation/src/types.rs`

**Code Changes:**

```diff
commit 2851d16acbe87159f58348a9c9f4e10f34f488b9
Author: pietrodimarco-dfinity <124565147+pietrodimarco-dfinity@users.noreply.github.com>
Date:   Tue Sep 30 18:12:47 2025 +0200

    fix(node-rewards-canister): Discard DayUtc type in favor of NaiveDate (#6981)
    
    This introduces some breaking changes to the Node Rewards canister API,
    however that's considered acceptable since nobody is calling it yet.
    
    Changes:
    
    - Removed completely `DayUtc` base custom type in favour of
    `chrono::NaiveDate`
    - Adapted DayUtc in API types to work with `chrono::NaiveDate`
    - Adapted tests

diff --git a/rs/node_rewards/canister/BUILD.bazel b/rs/node_rewards/canister/BUILD.bazel
index 5a7f643961..0e5213753b 100644
--- a/rs/node_rewards/canister/BUILD.bazel
+++ b/rs/node_rewards/canister/BUILD.bazel
@@ -19,6 +19,7 @@ DEPENDENCIES = [
     "//rs/types/base_types",
     "//rs/types/types",
     "@crate_index//:candid",
+    "@crate_index//:chrono_canisters",
     "@crate_index//:futures",
     "@crate_index//:ic-cdk",
     "@crate_index//:ic-cdk-timers",
@@ -39,7 +40,6 @@ DEV_DEPENDENCIES = [
     "//rs/registry/transport",
     "//rs/state_machine_tests",
     "@crate_index//:candid_parser",
-    "@crate_index//:chrono_canisters",
     "@crate_index//:futures-util",
     "@crate_index//:maplit",
     "@crate_index//:mockall",
diff --git a/rs/node_rewards/canister/Cargo.toml b/rs/node_rewards/canister/Cargo.toml
index c1df86922c..68435759ce 100644
--- a/rs/node_rewards/canister/Cargo.toml
+++ b/rs/node_rewards/canister/Cargo.toml
@@ -37,6 +37,7 @@ mockall = { workspace = true }
 prost = { workspace = true }
 rewards-calculation = { path = "../rewards_calculation" }
 itertools = { workspace = true }
+chrono = { workspace = true }
 
 [dev-dependencies]
 candid_parser = { workspace = true }
diff --git a/rs/node_rewards/canister/api/BUILD.bazel b/rs/node_rewards/canister/api/BUILD.bazel
index a577bcc4cc..d178c2ea23 100644
--- a/rs/node_rewards/canister/api/BUILD.bazel
+++ b/rs/node_rewards/canister/api/BUILD.bazel
@@ -8,6 +8,7 @@ DEPENDENCIES = [
     "//rs/node_rewards/rewards_calculation",
     "//rs/types/base_types",
     "@crate_index//:candid",
+    "@crate_index//:chrono_canisters",
     "@crate_index//:ic-cdk",
     "@crate_index//:serde",
 ]
diff --git a/rs/node_rewards/canister/api/Cargo.toml b/rs/node_rewards/canister/api/Cargo.toml
index decff706f9..804ca0cc8f 100644
--- a/rs/node_rewards/canister/api/Cargo.toml
+++ b/rs/node_rewards/canister/api/Cargo.toml
@@ -15,3 +15,4 @@ ic-base-types = { path = "../../../types/base_types" }
 rewards-calculation = { path = "../../rewards_calculation" }
 ic-nervous-system-proto = { path = "../../../nervous_system/proto" }
 serde = { workspace = true }
+chrono = { workspace = true }
diff --git a/rs/node_rewards/canister/api/src/lib.rs b/rs/node_rewards/canister/api/src/lib.rs
index 15ce9c70ea..291111bd85 100644
--- a/rs/node_rewards/canister/api/src/lib.rs
+++ b/rs/node_rewards/canister/api/src/lib.rs
@@ -2,7 +2,8 @@ pub mod monthly_rewards;
 pub mod provider_rewards_calculation;
 pub mod providers_rewards;
 
-use rewards_calculation::types as native_types;
+use chrono::{DateTime, Datelike, NaiveDate};
+use std::fmt::Display;
 
 // These are API-facing types with all fields wrapped in `Option`
 // to ensure deserialization always works
@@ -10,34 +11,56 @@ use rewards_calculation::types as native_types;
 #[derive(
     PartialOrd, Ord, Eq, candid::CandidType, candid::Deserialize, Clone, Copy, PartialEq, Debug,
 )]
-pub struct DayUtc {
-    last_ts_nanoseconds: Option<u64>,
+pub struct DateUtc {
+    pub day: Option<u32>,
+    pub month: Option<u32>,
+    pub year: Option<u32>,
 }
 
-impl DayUtc {
-    pub fn from_nanos(nanos_since_unix_epoch: u64) -> Self {
-        Self::from(native_types::DayUtc::from_nanos(nanos_since_unix_epoch))
-    }
-
-    pub fn from_secs(secs_since_unix_epoch: u64) -> Self {
-        Self::from(native_types::DayUtc::from_secs(secs_since_unix_epoch))
+impl Display for DateUtc {
+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+        write!(
+            f,
+            "{}-{}-{} UTC",
+            self.year.expect("Year is missing"),
+            self.month.expect("Month is missing"),
+            self.day.expect("Day is missing")
+        )
     }
 }
 
-impl From<native_types::DayUtc> for DayUtc {
-    fn from(day_utc: native_types::DayUtc) -> Self {
+impl From<NaiveDate> for DateUtc {
+    fn from(value: NaiveDate) -> Self {
         Self {
-            last_ts_nanoseconds: Some(day_utc.unix_timestamp_at_day_end_nanoseconds()),
+            day: Some(value.day()),
+            month: Some(value.month()),
+            year: Some(value.year() as u32),
         }
     }
 }
 
-impl From<DayUtc> for native_types::DayUtc {
-    fn from(day_utc: DayUtc) -> Self {
-        native_types::DayUtc::from_nanos(
-            day_utc
-                .last_ts_nanoseconds
-                .expect("last_ts_nanoseconds is None"),
+impl TryFrom<DateUtc> for NaiveDate {
+    type Error = String;
+
+    fn try_from(value: DateUtc) -> Result<Self, Self::Error> {
+        NaiveDate::from_ymd_opt(
+            value.year.expect("Year is missing") as i32,
+            value.month.expect("Month is missing"),
+            value.day.expect("Day is missing"),
         )
+        .ok_or(format!("Invalid date: {:?}", value))
+    }
+}
+
+impl DateUtc {
+    pub fn from_unix_timestamp_nanoseconds(value: u64) -> Self {
+        let naive_date = DateTime::from_timestamp_nanos(value as i64).date_naive();
+        Self::from(naive_date)
+    }
+    pub fn from_unix_timestamp_seconds(value: u64) -> Self {
+        let naive_date = DateTime::from_timestamp(value as i64, 0)
+            .unwrap()
+            .date_naive();
+        Self::from(naive_date)
     }
 }
diff --git a/rs/node_rewards/canister/api/src/provider_rewards_calculation.rs b/rs/node_rewards/canister/api/src/provider_rewards_calculation.rs
index 984536628c..d14dbb47ea 100644
--- a/rs/node_rewards/canister/api/src/provider_rewards_calculation.rs
+++ b/rs/node_rewards/canister/api/src/provider_rewards_calculation.rs
@@ -1,12 +1,12 @@
-pub use crate::DayUtc;
+pub use crate::DateUtc;
 use candid::{CandidType, Deserialize, Principal};
 use ic_base_types::PrincipalId;
 use ic_nervous_system_proto::pb::v1::Decimal;
 
 #[derive(CandidType, Clone, Deserialize)]
 pub struct GetNodeProviderRewardsCalculationRequest {
-    pub from_day: DayUtc,
-    pub to_day: DayUtc,
+    pub from_day: DateUtc,
+    pub to_day: DateUtc,
     pub provider_id: Principal,
 }
 
@@ -70,6 +70,6 @@ pub struct NodeProviderRewards {
 
 #[derive(CandidType, candid::Deserialize, Clone, Debug)]
 pub struct NodeProviderRewardsDaily {
-    pub day_utc: Option<DayUtc>,
+    pub day_utc: Option<DateUtc>,
     pub node_provider_rewards: Option<NodeProviderRewards>,
 }
diff --git a/rs/node_rewards/canister/api/src/providers_rewards.rs b/rs/node_rewards/canister/api/src/providers_rewards.rs
index dc4fb8cafc..6f89da3802 100644
--- a/rs/node_rewards/canister/api/src/providers_rewards.rs
+++ b/rs/node_rewards/canister/api/src/providers_rewards.rs
@@ -1,11 +1,11 @@
-use crate::DayUtc;
+use crate::DateUtc;
 use candid::{CandidType, Deserialize, Principal};
 use std::collections::BTreeMap;
 
 #[derive(CandidType, Clone, Deserialize)]
 pub struct GetNodeProvidersRewardsRequest {
-    pub from_day: DayUtc,
-    pub to_day: DayUtc,
+    pub from_day: DateUtc,
+    pub to_day: DateUtc,
 }
 pub type GetNodeProvidersRewardsResponse = Result<NodeProvidersRewards, String>;
 
diff --git a/rs/node_rewards/canister/node-rewards-canister.did b/rs/node_rewards/canister/node-rewards-canister.did
index ddd78881cd..f3dfb75a78 100644
--- a/rs/node_rewards/canister/node-rewards-canister.did
+++ b/rs/node_rewards/canister/node-rewards-canister.did
@@ -4,8 +4,10 @@ type Decimal = record {
   human_readable: opt text;
 };
 
-type DayUtc = record {
-  last_ts_nanoseconds: opt nat64;
+type DateUtc = record {
+  day: opt nat32;
+  month: opt nat32;
+  year: opt nat32;
 };
 
 type NodeMetricsDaily = record {
@@ -57,15 +59,15 @@ type NodeProviderRewards = record {
 };
 
 type NodeProviderRewardsDaily = record {
-    day_utc: opt DayUtc;
+    day_utc: opt DateUtc;
     node_provider_rewards: opt NodeProviderRewards;
 };
 
 type GetNodeProviderRewardsCalculationResponse = variant { Ok: vec NodeProviderRewardsDaily; Err: text };
 
 type GetNodeProviderRewardsCalculationRequest = record {
-  from_day: DayUtc;
-  to_day: DayUtc;
+  from_day: DateUtc;
+  to_day: DateUtc;
   provider_id: principal;
 };
 
@@ -79,8 +81,8 @@ type NodeProvidersRewards = record {
 };
 
 type GetNodeProvidersRewardsRequest = record {
-  from_day: DayUtc;
-  to_day: DayUtc;
+  from_day: DateUtc;
+  to_day: DateUtc;
 };
 
 type GetNodeProvidersRewardsResponse = variant { Ok: NodeProvidersRewards; Err: text };
diff --git a/rs/node_rewards/canister/src/canister/mod.rs b/rs/node_rewards/canister/src/canister/mod.rs
index e613b42873..5ab8ca38fb 100644
--- a/rs/node_rewards/canister/src/canister/mod.rs
+++ b/rs/node_rewards/canister/src/canister/mod.rs
@@ -1,7 +1,9 @@
 use crate::api_conversion::into_rewards_calculation_results;
+use crate::chrono_utils::last_unix_timestamp_nanoseconds;
 use crate::metrics::MetricsManager;
 use crate::registry_querier::RegistryQuerier;
 use crate::storage::VM;
+use chrono::{DateTime, NaiveDate};
 use ic_base_types::{PrincipalId, SubnetId};
 use ic_interfaces_registry::ZERO_REGISTRY_VERSION;
 use ic_node_rewards_canister_api::monthly_rewards::{
@@ -25,7 +27,7 @@ use ic_registry_node_provider_rewards::{RewardsPerNodeProvider, calculate_reward
 use ic_types::{RegistryVersion, Time};
 use rewards_calculation::performance_based_algorithm::results::RewardsCalculatorResults;
 use rewards_calculation::performance_based_algorithm::v1::RewardsCalculationV1;
-use rewards_calculation::types::{DayUtc, NodeMetricsDailyRaw, RewardableNode};
+use rewards_calculation::types::{NodeMetricsDailyRaw, RewardableNode};
 use std::cell::RefCell;
 use std::collections::{BTreeMap, HashSet};
 use std::rc::Rc;
@@ -127,13 +129,15 @@ impl NodeRewardsCanister {
         });
     }
 
-    fn validate_reward_period(from_day: &DayUtc, to_day: &DayUtc) -> Result<(), String> {
-        let today: DayUtc = current_time().into();
-        if from_day > to_day {
-            return Err("from_day must be before to_day".to_string());
+    fn validate_reward_period(from_date: &NaiveDate, to_date: &NaiveDate) -> Result<(), String> {
+        let today =
+            DateTime::from_timestamp_nanos(current_time().as_nanos_since_unix_epoch() as i64)
+                .date_naive();
+        if from_date > to_date {
+            return Err("from_date must be before to_date".to_string());
         }
-        if to_day >= &today {
-            return Err("to_day_timestamp_nanos must be earlier than today".to_string());
+        if to_date >= &today {
+            return Err("to_date must be earlier than today".to_string());
         }
         Ok(())
     }
@@ -143,8 +147,8 @@ impl NodeRewardsCanister {
         request: GetNodeProvidersRewardsRequest,
         provider_filter: Option<PrincipalId>,
     ) -> Result<RewardsCalculatorResults, String> {
-        let start_day = request.from_day.into();
-        let end_day = request.to_day.into();
+        let start_day = NaiveDate::try_from(request.from_day)?;
+        let end_day = NaiveDate::try_from(request.to_day)?;
         Self::validate_reward_period(&start_day, &end_day)?;
 
         RewardsCalculationV1::calculate_rewards(&start_day, &end_day, provider_filter, self)
@@ -153,24 +157,24 @@ impl NodeRewardsCanister {
 }
 
 impl rewards_calculation::performance_based_algorithm::DataProvider for &NodeRewardsCanister {
-    fn get_rewards_table(&self, day: &DayUtc) -> Result<NodeRewardsTable, String> {
+    fn get_rewards_table(&self, date: &NaiveDate) -> Result<NodeRewardsTable, String> {
         let registry_querier = RegistryQuerier::new(self.registry_client.clone());
 
         let version = registry_querier
-            .version_for_timestamp(day.unix_timestamp_at_day_end_nanoseconds())
+            .version_for_timestamp_nanoseconds(last_unix_timestamp_nanoseconds(date))
             .ok_or_else(|| "Could not find registry version for timestamp".to_string())?;
         Ok(registry_querier.get_rewards_table(version))
     }
 
     fn get_daily_metrics_by_subnet(
         &self,
-        day: &DayUtc,
+        date: &NaiveDate,
     ) -> Result<BTreeMap<SubnetId, Vec<NodeMetricsDailyRaw>>, String> {
-        let metrics = self.metrics_manager.metrics_by_subnet(day);
+        let metrics = self.metrics_manager.metrics_by_subnet(date);
         if metrics.is_empty() {
             return Err(format!(
                 "No metrics found for day {}",
-                day.unix_timestamp_at_day_end_nanoseconds()
+                date.format("%Y-%m-%d")
             ));
         }
         Ok(metrics)
@@ -178,25 +182,26 @@ impl rewards_calculation::performance_based_algorithm::DataProvider for &NodeRew
 
     fn get_rewardable_nodes(
         &self,
-        day: &DayUtc,
+        date: &NaiveDate,
     ) -> Result<BTreeMap<PrincipalId, Vec<RewardableNode>>, String> {
         let registry_client = self.get_registry_client();
         let registry_querier = RegistryQuerier::new(registry_client.clone());
         registry_querier
-            .get_rewardable_nodes_per_provider(day, None)
+            .get_rewardable_nodes_per_provider(date, None)
             .map_err(|e| format!("Could not get rewardable nodes: {e:?}"))
     }
 
     fn get_provider_rewardable_nodes(
         &self,
-        day: &DayUtc,
+        date: &NaiveDate,
         provider_id: &PrincipalId,
     ) -> Result<Vec<RewardableNode>, String> {
-        let mut all_rewardable_nodes = self.get_rewardable_nodes(day)?;
+        let mut all_rewardable_nodes = self.get_rewardable_nodes(date)?;
         let rewardable_nodes = all_rewardable_nodes.remove(provider_id).ok_or_else(|| {
             format!(
                 "No rewardable nodes found for provider {} for day {}",
-                provider_id, day
+                provider_id,
+                date.format("%Y-%m-%d")
             )
         })?;
         Ok(rewardable_nodes)
diff --git a/rs/node_rewards/canister/src/canister/test/get_node_providers_rewards.rs b/rs/node_rewards/canister/src/canister/test/get_node_providers_rewards.rs
index a23ea75201..d24a62132c 100644
--- a/rs/node_rewards/canister/src/canister/test/get_node_providers_rewards.rs
+++ b/rs/node_rewards/canister/src/canister/test/get_node_providers_rewards.rs
@@ -1,5 +1,6 @@
 use crate::canister::NodeRewardsCanister;
 use crate::canister::test::test_utils::{CANISTER_TEST, VM, setup_thread_local_canister_for_test};
+use crate::chrono_utils::{last_unix_timestamp_nanoseconds, to_native_date};
 use crate::metrics::MetricsManager;
 use crate::pb::v1::{NodeMetrics, SubnetMetricsKey, SubnetMetricsValue};
 use futures_util::FutureExt;
@@ -19,7 +20,6 @@ use maplit::btreemap;
 use rewards_calculation::performance_based_algorithm::test_utils::{
     create_rewards_table_for_region_test, test_node_id, test_provider_id, test_subnet_id,
 };
-use rewards_calculation::types::DayUtc;
 use std::rc::Rc;
 use std::str::FromStr;
 use std::sync::Arc;
@@ -28,8 +28,8 @@ fn setup_data_for_test_rewards_calculation(
     fake_registry: Arc<FakeRegistry>,
     metrics_manager: Rc<MetricsManager<VM>>,
 ) {
-    let day1: DayUtc = DayUtc::try_from("2024-01-01").unwrap();
-    let day2: DayUtc = DayUtc::try_from("2024-01-02").unwrap();
+    let day1 = to_native_date("2024-01-01");
+    let day2 = to_native_date("2024-01-02");
     let subnet1 = test_subnet_id(1);
     let subnet2 = test_subnet_id(2);
     let p1 = test_provider_id(1);
@@ -188,7 +188,7 @@ fn setup_data_for_test_rewards_calculation(
     fake_registry.set_value_at_version_with_timestamp(
         make_node_record_key(p1_node3_t31),
         6,
-        day2.unix_timestamp_at_day_end_nanoseconds(),
+        last_unix_timestamp_nanoseconds(&day2),
         None,
     );
 
@@ -214,7 +214,7 @@ fn setup_data_for_test_rewards_calculation(
     fake_registry.set_value_at_version_with_timestamp(
         make_node_record_key(p1_node5_perf),
         6,
-        day2.unix_timestamp_at_day_end_nanoseconds(),
+        last_unix_timestamp_nanoseconds(&day2),
         None,
     );
 
@@ -231,7 +231,7 @@ fn setup_data_for_test_rewards_calculation(
     fake_registry.set_value_at_version_with_timestamp(
         make_node_record_key(p2_node1),
         6,
-        day2.unix_timestamp_at_day_end_nanoseconds(),
+        last_unix_timestamp_nanoseconds(&day2),
         None,
     );
 
@@ -241,7 +241,7 @@ fn setup_data_for_test_rewards_calculation(
     // Day 1 subnet 1
     subnets_metrics.insert(
         SubnetMetricsKey {
-            timestamp_nanos: day1.unix_timestamp_at_day_end_nanoseconds(),
+            timestamp_nanos: last_unix_timestamp_nanoseconds(&day1),
             subnet_id: Some(subnet1.get()),
         },
         SubnetMetricsValue {
@@ -273,7 +273,7 @@ fn setup_data_for_test_rewards_calculation(
     // Day 1 subnet 2
     subnets_metrics.insert(
         SubnetMetricsKey {
-            timestamp_nanos: day1.unix_timestamp_at_day_end_nanoseconds(),
+            timestamp_nanos: last_unix_timestamp_nanoseconds(&day1),
             subnet_id: Some(subnet2.get()),
         },
         SubnetMetricsValue {
@@ -288,7 +288,7 @@ fn setup_data_for_test_rewards_calculation(
     // Day 2 subnet 1
     subnets_metrics.insert(
         SubnetMetricsKey {
-            timestamp_nanos: day2.unix_timestamp_at_day_end_nanoseconds(),
+            timestamp_nanos: last_unix_timestamp_nanoseconds(&day2),
             subnet_id: Some(subnet1.get()),
         },
         SubnetMetricsValue {
@@ -309,8 +309,8 @@ fn test_get_node_providers_rewards() {
     setup_data_for_test_rewards_calculation(fake_registry, metrics_manager);
     NodeRewardsCanister::schedule_registry_sync(&CANISTER_TEST).now_or_never();
     NodeRewardsCanister::schedule_metrics_sync(&CANISTER_TEST).now_or_never();
-    let from = DayUtc::try_from("2024-01-01").unwrap();
-    let to = DayUtc::try_from("2024-01-02").unwrap();
+    let from = to_native_date("2024-01-01");
+    let to = to_native_date("2024-01-02");
 
     let request = GetNodeProvidersRewardsRequest {
         from_day: from.into(),
diff --git a/rs/node_rewards/canister/src/chrono_utils.rs b/rs/node_rewards/canister/src/chrono_utils.rs
new file mode 100644
index 0000000000..7724d65d53
--- /dev/null
+++ b/rs/node_rewards/canister/src/chrono_utils.rs
@@ -0,0 +1,24 @@
+use chrono::NaiveDate;
+
+pub fn first_unix_timestamp_nanoseconds(naive_date: &NaiveDate) -> u64 {
+    naive_date
+        .and_hms_nano_opt(0, 0, 0, 1)
+        .unwrap()
+        .and_utc()
+        .timestamp_nanos_opt()
+        .unwrap() as u64
+}
+
+pub fn last_unix_timestamp_nanoseconds(naive_date: &NaiveDate) -> u64 {
+    naive_date
+        .and_hms_nano_opt(23, 59, 59, 999_999_999)
+        .unwrap()
+        .and_utc()
+        .timestamp_nanos_opt()
+        .unwrap() as u64
+}
+
+#[cfg(test)]
+pub fn to_native_date(date: &str) -> NaiveDate {
+    NaiveDate::parse_from_str(date, "%Y-%m-%d").unwrap()
+}
diff --git a/rs/node_rewards/canister/src/lib.rs b/rs/node_rewards/canister/src/lib.rs
index 504f62d8f6..b86c3d9dcc 100644
--- a/rs/node_rewards/canister/src/lib.rs
+++ b/rs/node_rewards/canister/src/lib.rs
@@ -15,6 +15,7 @@ use std::borrow::Cow;
 
 pub mod api_conversion;
 pub mod canister;
+mod chrono_utils;
 pub mod metrics;
 pub mod pb;
 pub mod registry_querier;
diff --git a/rs/node_rewards/canister/src/metrics.rs b/rs/node_rewards/canister/src/metrics.rs
index 80a5cc55cc..28b03e43ca 100644
--- a/rs/node_rewards/canister/src/metrics.rs
+++ b/rs/node_rewards/canister/src/metrics.rs
@@ -1,14 +1,16 @@
 #![allow(deprecated)]
 use crate::KeyRange;
+use crate::chrono_utils::{first_unix_timestamp_nanoseconds, last_unix_timestamp_nanoseconds};
 use crate::pb::v1::{SubnetIdKey, SubnetMetricsKey, SubnetMetricsValue};
 use async_trait::async_trait;
 use candid::Principal;
+use chrono::{DateTime, NaiveDate};
 use ic_base_types::{NodeId, SubnetId};
 use ic_cdk::api::call::CallResult;
 use ic_management_canister_types::{NodeMetricsHistoryArgs, NodeMetricsHistoryRecord};
 use ic_stable_structures::StableBTreeMap;
 use itertools::Itertools;
-use rewards_calculation::types::{DayUtc, NodeMetricsDailyRaw, UnixTsNanos};
+use rewards_calculation::types::{NodeMetricsDailyRaw, UnixTsNanos};
 use std::cell::RefCell;
 use std::collections::{BTreeMap, HashMap};
 
@@ -178,40 +180,39 @@ where
         }
     }
 
-    /// Computes daily node metrics for a specific day.
+    /// Computes daily node metrics for a specific date.
     ///
     /// This is done by subtracting the total metrics of the
-    /// previous day from those of the current day.
+    /// previous date from those of the current date.
     pub fn metrics_by_subnet(
         &self,
-        day_utc: &DayUtc,
+        date: &NaiveDate,
     ) -> BTreeMap<SubnetId, Vec<NodeMetricsDailyRaw>> {
         let mut metrics_by_subnet = BTreeMap::new();
-        let previous_day_ts = day_utc
-            .previous_day()
-            .unix_timestamp_at_day_start_nanoseconds();
         let first_key = SubnetMetricsKey {
-            timestamp_nanos: previous_day_ts,
+            timestamp_nanos: first_unix_timestamp_nanoseconds(&date.pred()),
             ..SubnetMetricsKey::min_key()
         };
         let last_key = SubnetMetricsKey {
-            timestamp_nanos: day_utc.unix_timestamp_at_day_end_nanoseconds(),
+            timestamp_nanos: last_unix_timestamp_nanoseconds(date),
             ..SubnetMetricsKey::max_key()
         };
 
-        let mut subnets_metrics_by_day: BTreeMap<DayUtc, _> = self
+        let mut subnets_metrics_by_date: BTreeMap<NaiveDate, _> = self
             .subnets_metrics
             .borrow()
             .range(first_key..=last_key)
-            .into_group_map_by(|(k, _)| DayUtc::from_nanos(k.timestamp_nanos))
+            .into_group_map_by(|(k, _)| {
+                DateTime::from_timestamp_nanos(k.timestamp_nanos as i64).date_naive()
+            })
             .into_iter()
             .collect();
 
         let mut initial_total_metrics: HashMap<_, _> = HashMap::new();
-        if let Some((timestamp_nanos, _)) = subnets_metrics_by_day.first_key_value()
-            && timestamp_nanos < day_utc
+        if let Some((stored_date, _)) = subnets_metrics_by_date.first_key_value()
+            && stored_date < date
         {
-            initial_total_metrics = subnets_metrics_by_day
+            initial_total_metrics = subnets_metrics_by_date
                 .pop_first()
                 .unwrap()
                 .1
@@ -230,7 +231,7 @@ where
                 .collect();
         };
 
-        for (_, subnets_metrics) in subnets_metrics_by_day {
+        for (_, subnets_metrics) in subnets_metrics_by_date {
             for (k, v) in subnets_metrics {
                 let subnet_id = SubnetId::from(k.subnet_id.unwrap());
 
diff --git a/rs/node_rewards/canister/src/metrics/tests.rs b/rs/node_rewards/canister/src/metrics/tests.rs
index 378cbd5c77..ff67195b52 100644
--- a/rs/node_rewards/canister/src/metrics/tests.rs
+++ b/rs/node_rewards/canister/src/metrics/tests.rs
@@ -1,11 +1,13 @@
+use crate::chrono_utils::last_unix_timestamp_nanoseconds;
 use crate::metrics::{MetricsManager, UnixTsNanos};
 use crate::pb::v1::SubnetMetricsKey;
+use chrono::{Days, NaiveDate};
 use ic_base_types::{NodeId, PrincipalId, SubnetId};
 use ic_cdk::api::call::{CallResult, RejectionCode};
 use ic_management_canister_types::{NodeMetrics, NodeMetricsHistoryArgs, NodeMetricsHistoryRecord};
 use ic_stable_structures::DefaultMemoryImpl;
 use ic_stable_structures::memory_manager::{MemoryId, VirtualMemory};
-use rewards_calculation::types::{DayUtc, NodeMetricsDailyRaw};
+use rewards_calculation::types::NodeMetricsDailyRaw;
 use std::cell::RefCell;
 use std::collections::{BTreeMap, HashMap};
 
@@ -47,6 +49,10 @@ impl MetricsManager<VM> {
     }
 }
 
+fn add_days(date: &NaiveDate, days: u64) -> NaiveDate {
+    date.checked_add_days(Days::new(days)).unwrap()
+}
+
 fn node_metrics_history_gen(days: u64) -> Vec<NodeMetricsHistoryRecord> {
     let mut result = Vec::new();
     for i in 0..days {
@@ -245,14 +251,13 @@ impl NodeMetricsHistoryResponseTracker {
     fn add_node_metrics(
         mut self,
         node_id: NodeId,
-        metrics: Vec<(DayUtc, Vec<(Proposed, Failed)>)>,
+        metrics: Vec<(NaiveDate, Vec<(Proposed, Failed)>)>,
     ) -> Self {
-        for (from, proposed_failed) in metrics {
-            let mut metrics_day = from;
+        for (mut from, proposed_failed) in metrics {
             for (proposed, failed) in proposed_failed {
                 let entry = self
                     .subnets_responses
-                    .entry(metrics_day.unix_timestamp_at_day_end_nanoseconds())
+                    .entry(last_unix_timestamp_nanoseconds(&from))
                     .or_default();
                 let entry_sub = entry.entry(self.current_subnet).or_default();
 
@@ -261,7 +266,7 @@ impl NodeMetricsHistoryResponseTracker {
                     num_block_failures_total: failed,
                     node_id: node_id.get().0,
                 });
-                metrics_day = metrics_day.next_day();
+                from = from.succ_opt().unwrap();
             }
         }
         self
@@ -276,10 +281,8 @@ impl NodeMetricsHistoryResponseTracker {
         let subnet_id = SubnetId::from(PrincipalId::from(args.subnet_id));
 
         self.subnets_responses
-            .range(
-                args.start_at_timestamp_nanos
-                    ..(args.start_at_timestamp_nanos + (response_step as u64) * ONE_DAY_NANOS),
-            )
+            .range(args.start_at_timestamp_nanos..)
+            .take(response_step)
             .filter(|(_, metrics)| metrics.contains_key(&subnet_id))
             .for_each(|(ts, metrics)| {
                 let node_metrics = metrics.get(&subnet_id).unwrap().clone();
@@ -298,7 +301,7 @@ impl NodeMetricsHistoryResponseTracker {
 }
 
 async fn _daily_metrics_correct_different_update_size(size: usize) {
-    let day_start = DayUtc::from_nanos(0);
+    let day_start = NaiveDate::from_ymd(2025, 1, 1);
     let tracker = NodeMetricsHistoryResponseTracker::new()
         .with_subnet(subnet_id(1))
         .add_node_metrics(
@@ -307,10 +310,9 @@ async fn _daily_metrics_correct_different_update_size(size: usize) {
         )
         .add_node_metrics(node_id(2), vec![(day_start, vec![(19, 21), (32, 22)])])
         // Node 2 is redeployed to subnet 1 on day 2
-        .add_node_metrics(
-            node_id(2),
-            vec![(day_start.next_day().next_day().next_day(), vec![(10, 10)])],
-        );
+        .add_node_metrics(node_id(2), vec![(add_days(&day_start, 3), vec![(10, 10)])]);
+
+    println!("metrics stored {:?}", tracker.subnets_responses);
 
     let mut mock = mock::MockCanisterClient::new();
     mock.expect_node_metrics_history()
@@ -333,7 +335,7 @@ async fn _daily_metrics_correct_different_update_size(size: usize) {
     assert_eq!(daily_metrics[0][1].num_blocks_failed, 21);
 
     let daily_metrics: Vec<Vec<NodeMetricsDailyRaw>> = mm
-        .metrics_by_subnet(&day_start.next_day())
+        .metrics_by_subnet(&day_start.succ_opt().unwrap())
         .into_values()
         .collect();
 
@@ -346,7 +348,7 @@ async fn _daily_metrics_correct_different_update_size(size: usize) {
     assert_eq!(daily_metrics[0][1].num_blocks_failed, 1);
 
     let daily_metrics: Vec<Vec<NodeMetricsDailyRaw>> = mm
-        .metrics_by_subnet(&day_start.next_day().next_day())
+        .metrics_by_subnet(&add_days(&day_start, 2))
         .into_values()
         .collect();
 
@@ -355,7 +357,7 @@ async fn _daily_metrics_correct_different_update_size(size: usize) {
     assert_eq!(daily_metrics[0][0].num_blocks_failed, 0);
 
     let daily_metrics: Vec<Vec<NodeMetricsDailyRaw>> = mm
-        .metrics_by_subnet(&day_start.next_day().next_day().next_day())
+        .metrics_by_subnet(&add_days(&day_start, 3))
         .into_values()
         .collect();
 
@@ -381,7 +383,7 @@ async fn daily_metrics_correct_2_subs() {
     let subnet_2 = subnet_id(2);
 
     let node_1 = node_id(1);
-    let day_start = DayUtc::from_nanos(0);
+    let day_start = NaiveDate::from_ymd(2025, 1, 1);
 
     let tracker = NodeMetricsHistoryResponseTracker::new()
         .with_subnet(subnet_1)
@@ -389,10 +391,7 @@ async fn daily_metrics_correct_2_subs() {
         .with_subnet(subnet_2)
         .add_node_metrics(
             node_1,
-            vec![(
-                day_start.next_day().next_day().next_day(),
-                vec![(4, 4), (6, 6), (8, 8)],
-            )],
+            vec![(add_days(&day_start, 3), vec![(4, 4), (6, 6), (8, 8)])],
         );
 
     let mut mock = mock::MockCanisterClient::new();
@@ -407,7 +406,7 @@ async fn daily_metrics_correct_2_subs() {
     let mut node_1_daily_metrics = Vec::new();
     for day in 0..8 {
         let daily_metrics = mm
-            .metrics_by_subnet(&DayUtc::from_nanos(day * ONE_DAY_NANOS))
+            .metrics_by_subnet(&add_days(&day_start, day))
             .into_iter()
             .collect::<BTreeMap<_, _>>()
             .into_iter()
@@ -475,8 +474,8 @@ async fn daily_metrics_correct_overlapping_days() {
     let subnet_2 = subnet_id(2);
 
     let node_1 = node_id(1);
-    let node_2 = node_id(1);
-    let day_start = DayUtc::from_nanos(0);
+    let node_2 = node_id(2);
+    let day_start = NaiveDate::from_ymd(2025, 1, 1);
 
     let tracker = NodeMetricsHistoryResponseTracker::new()
         .with_subnet(subnet_1)
@@ -485,17 +484,11 @@ async fn daily_metrics_correct_overlapping_days() {
         // Node 1 redeployed to subnet 2 on day 2
         .add_node_metrics(
             node_1,
-            vec![(
-                day_start.next_day().next_day(),
-                vec![(4, 4), (6, 6), (8, 8)],
-            )],
+            vec![(add_days(&day_start, 2), vec![(4, 4), (6, 6), (8, 8)])],
         )
         .add_node_metrics(
             node_2,
-            vec![(
-                day_start.next_day().next_day(),
-                vec![(1, 1), (3, 3), (6, 6)],
-            )],
+            vec![(add_days(&day_start, 2), vec![(1, 1), (3, 3), (6, 6)])],
         );
 
     let mut mock = mock::MockCanisterClient::new();
@@ -510,7 +503,7 @@ async fn daily_metrics_correct_overlapping_days() {
 
     let mut daily_metrics = Vec::new();
     for idx in 0..4 {
-        let day = DayUtc::from_nanos(idx * ONE_DAY_NANOS);
+        let day = add_days(&day_start, idx);
         let metrics = mm
             .metrics_by_subnet(&day)
             .into_iter()
@@ -528,7 +521,7 @@ async fn daily_metrics_correct_overlapping_days() {
 
     let overlapping_sub_1 = daily_metrics
         .iter()
-        .find(|(sub, day, _)| sub == &subnet_1 && *day == day_start.next_day().next_day())
+        .find(|(sub, day, _)| sub == &subnet_1 && *day == add_days(&day_start, 2))
         .map(|(_, _, node_metrics)| node_metrics)
         .unwrap();
 
@@ -537,7 +530,7 @@ async fn daily_metrics_correct_overlapping_days() {
 
     let overlapping_sub_2 = daily_metrics
         .iter()
-        .find(|(sub, day, _)| sub == &subnet_2 && *day == day_start.next_day().next_day())
+        .find(|(sub, day, _)| sub == &subnet_2 && *day == add_days(&day_start, 2))
         .map(|(_, _, node_metrics)| node_metrics)
         .unwrap();
 
diff --git a/rs/node_rewards/canister/src/registry_querier.rs b/rs/node_rewards/canister/src/registry_querier.rs
index 2c80205763..16f2050f82 100644
--- a/rs/node_rewards/canister/src/registry_querier.rs
+++ b/rs/node_rewards/canister/src/registry_querier.rs
@@ -1,3 +1,5 @@
+use crate::chrono_utils::last_unix_timestamp_nanoseconds;
+use chrono::NaiveDate;
 use ic_base_types::{NodeId, PrincipalId, RegistryVersion, SubnetId};
 use ic_interfaces_registry::RegistryValue;
 use ic_protobuf::registry::dc::v1::DataCenterRecord;
@@ -11,7 +13,7 @@ use ic_registry_keys::{
     make_node_operator_record_key, make_subnet_list_record_key,
 };
 use ic_types::registry::RegistryClientError;
-use rewards_calculation::types::{DayUtc, Region, RewardableNode, UnixTsNanos};
+use rewards_calculation::types::{Region, RewardableNode, UnixTsNanos};
 use std::collections::BTreeMap;
 use std::str::FromStr;
 use std::sync::Arc;
@@ -32,7 +34,7 @@ impl RegistryQuerier {
     }
 
     ///  Returns the latest registry version corresponding to the given timestamp.
-    pub fn version_for_timestamp(&self, ts: UnixTsNanos) -> Option<RegistryVersion> {
+    pub fn version_for_timestamp_nanoseconds(&self, ts: UnixTsNanos) -> Option<RegistryVersion> {
         self.registry_client
             .timestamp_to_versions_map()
             .range(..=ts)
@@ -82,12 +84,12 @@ impl RegistryQuerier {
     /// version of that day.
     pub fn get_rewardable_nodes_per_provider(
         &self,
-        day_utc: &DayUtc,
+        date: &NaiveDate,
         provider_filter: Option<&PrincipalId>,
     ) -> Result<BTreeMap<PrincipalId, Vec<RewardableNode>>, RegistryClientError> {
         let mut rewardable_nodes_per_provider: BTreeMap<_, Vec<RewardableNode>> = BTreeMap::new();
         let registry_version = self
-            .version_for_timestamp(day_utc.unix_timestamp_at_day_end_nanoseconds())
+            .version_for_timestamp_nanoseconds(last_unix_timestamp_nanoseconds(date))
             .unwrap();
         let nodes = self.nodes_in_version(registry_version)?;
 
diff --git a/rs/node_rewards/canister/src/registry_querier/tests.rs b/rs/node_rewards/canister/src/registry_querier/tests.rs
index 674eb405ba..f722bff0d5 100644
--- a/rs/node_rewards/canister/src/registry_querier/tests.rs
+++ b/rs/node_rewards/canister/src/registry_querier/tests.rs
@@ -1,3 +1,4 @@
+use crate::chrono_utils::{last_unix_timestamp_nanoseconds, to_native_date};
 use crate::registry_querier::RegistryQuerier;
 use ic_base_types::{NodeId, PrincipalId, SubnetId};
 use ic_nervous_system_canisters::registry::RegistryCanister;
@@ -17,7 +18,7 @@ use ic_registry_keys::{
 use ic_stable_structures::memory_manager::{MemoryId, MemoryManager, VirtualMemory};
 use ic_stable_structures::{DefaultMemoryImpl, StableBTreeMap};
 use maplit::btreemap;
-use rewards_calculation::types::{DayUtc, RewardableNode};
+use rewards_calculation::types::RewardableNode;
 use std::cell::RefCell;
 use std::sync::Arc;
 
@@ -44,19 +45,14 @@ fn add_record_helper(
     value: Option<impl ::prost::Message>,
     datetime_str: &str,
 ) {
-    let ts = DayUtc::try_from(datetime_str).unwrap();
-    add_record_helper_ts(
-        key,
-        version,
-        value,
-        ts.unix_timestamp_at_day_end_nanoseconds(),
-    );
-}
-
-fn add_record_helper_ts(key: &str, version: u64, value: Option<impl ::prost::Message>, ts: u64) {
+    let naive_date = to_native_date(datetime_str);
     STATE.with_borrow_mut(|map| {
         map.insert(
-            StorableRegistryKey::new(key.to_string(), version, ts),
+            StorableRegistryKey::new(
+                key.to_string(),
+                version,
+                last_unix_timestamp_nanoseconds(&naive_date),
+            ),
             StorableRegistryValue(value.map(|v| v.encode_to_vec())),
         );
     });
@@ -144,15 +140,8 @@ fn add_dummy_data() {
     add_record_helper(&node_3_k, 39670, None::<NodeRecord>, "2025-07-13");
     add_record_helper(&node_3_k, 39675, Some(node_3_v.clone()), "2025-07-15");
     add_record_helper(&node_4_k, 39676, Some(node_4_v.clone()), "2025-07-16");
-
-    // Removed and re-added node_3 same day
-    let ts_removed = DayUtc::try_from("2025-07-16")
-        .unwrap()
-        .unix_timestamp_at_day_start_nanoseconds()
-        + 1;
-    add_record_helper_ts(&node_3_k, 39676, None::<NodeRecord>, ts_removed);
-    let ts_readded = ts_removed + 1;
-    add_record_helper_ts(&node_3_k, 39677, Some(node_3_v), ts_readded);
+    add_record_helper(&node_3_k, 39676, None::<NodeRecord>, "2025-07-16");
+    add_record_helper(&node_3_k, 39677, Some(node_3_v), "2025-07-16");
 }
 
 fn client_for_tests() -> RegistryQuerier {
@@ -234,8 +223,8 @@ fn contains_node(nodes: &[RewardableNode], node_num: u64) -> bool {
 #[test]
 fn test_rewardable_nodes_deleted_nodes() {
     let client = client_for_tests();
-    let day1 = DayUtc::try_from("2025-07-12").unwrap();
-    let day2 = DayUtc::try_from("2025-07-13").unwrap();
+    let day1 = to_native_date("2025-07-12");
+    let day2 = to_native_date("2025-07-13");
 
     let mut rewardable_nodes_day1 = client
         .get_rewardable_nodes_per_provider(&day1, None)
@@ -290,23 +279,22 @@ fn test_node_re_registered_after_deletion() {
 
     let client = client_for_tests();
 
-    let from = DayUtc::try_from("2025-07-07").unwrap();
-    let to = DayUtc::try_from("2025-07-12").unwrap();
-    let mut current_day = from;
+    let from = to_native_date("2025-07-07");
+    let to = to_native_date("2025-07-12");
     let expected_absent = [
-        DayUtc::try_from("2025-07-08").unwrap(),
-        DayUtc::try_from("2025-07-09").unwrap(),
-        DayUtc::try_from("2025-07-10").unwrap(),
+        to_native_date("2025-07-08"),
+        to_native_date("2025-07-09"),
+        to_native_date("2025-07-10"),
     ];
 
-    while current_day <= to {
+    for day in from.iter_days().take_while(|d| *d <= to) {
         let rewardables = client
-            .get_rewardable_nodes_per_provider(&current_day, None)
+            .get_rewardable_nodes_per_provider(&day, None)
             .unwrap()
             .remove(&PrincipalId::new_user_test_id(20))
             .unwrap();
 
-        if expected_absent.contains(&current_day) {
+        if expected_absent.contains(&day) {
             assert!(
                 !contains_node(&rewardables, 1),
                 "Node 1 should not be rewardable after deletion"
@@ -317,8 +305,6 @@ fn test_node_re_registered_after_deletion() {
                 "Node 1 should be rewardable on day 1"
             );
         }
-
-        current_day = current_day.next_day();
     }
 }
 
diff --git a/rs/node_rewards/canister/tests/get_node_providers_monthly_xdr_rewards.rs b/rs/node_rewards/canister/tests/get_node_providers_monthly_xdr_rewards.rs
index f0e79c9254..6370987988 100644
--- a/rs/node_rewards/canister/tests/get_node_providers_monthly_xdr_rewards.rs
+++ b/rs/node_rewards/canister/tests/get_node_providers_monthly_xdr_rewards.rs
@@ -3,7 +3,7 @@ use ic_nervous_system_agent::AgentFor;
 use ic_nervous_system_agent::nns::node_rewards::get_node_providers_monthly_xdr_rewards;
 use ic_nns_constants::NODE_REWARDS_CANISTER_ID;
 use ic_nns_test_utils::common::build_node_rewards_test_wasm;
-use ic_node_rewards_canister_api::DayUtc;
+use ic_node_rewards_canister_api::DateUtc;
 use ic_node_rewards_canister_api::monthly_rewards::GetNodeProvidersMonthlyXdrRewardsRequest;
 use ic_node_rewards_canister_api::provider_rewards_calculation::{
     GetNodeProviderRewardsCalculationRequest, GetNodeProviderRewardsCalculationResponse,
@@ -75,7 +75,7 @@ async fn get_node_provider_rewards_calculation_is_only_callable_in_nonreplicated
     let past_time_nanos = pocket_ic.get_time().await.as_nanos_since_unix_epoch();
     pocket_ic.advance_time(Duration::from_secs(86_400)).await;
     pocket_ic.tick().await;
-    let day = DayUtc::from_nanos(past_time_nanos);
+    let day = DateUtc::from_unix_timestamp_nanoseconds(past_time_nanos);
 
     let request = GetNodeProviderRewardsCalculationRequest {
         from_day: day,
@@ -96,7 +96,7 @@ async fn get_node_provider_rewards_calculation_is_only_callable_in_nonreplicated
     .unwrap_err();
     assert_eq!(
         err,
-        "Could not calculate rewards: \"No metrics found for day 1620345599999999999\""
+        "Could not calculate rewards: \"No metrics found for day 2021-05-06\""
     );
 
     // Replicated update call is not allowed.
diff --git a/rs/node_rewards/rewards_calculation/Cargo.toml b/rs/node_rewards/rewards_calculation/Cargo.toml
index 1fa3a2dc52..82558012bf 100644
--- a/rs/node_rewards/rewards_calculation/Cargo.toml
+++ b/rs/node_rewards/rewards_calculation/Cargo.toml
@@ -13,12 +13,8 @@ path = "src/lib.rs"
 ic-base-types = { path = "../../types/base_types" }
 itertools = { workspace = true }
 ic-protobuf = { path = "../../protobuf" }
-ic-types = { path = "../../types/types" }
 maplit = "1.0"
 rust_decimal = "1.37.1"
 rust_decimal_macros = "1.37.1"
-chrono = { version = "0.4.41", default-features = false, features = [
-    "alloc",
-    "serde",
-] }
+chrono = { workspace = true }
 serde = { workspace = true }
diff --git a/rs/node_rewards/rewards_calculation/src/performance_based_algorithm/mod.rs b/rs/node_rewards/rewards_calculation/src/performance_based_algorithm/mod.rs
index 3634cdcafb..c84eb6ea8d 100644
--- a/rs/node_rewards/rewards_calculation/src/performance_based_algorithm/mod.rs
+++ b/rs/node_rewards/rewards_calculation/src/performance_based_algorithm/mod.rs
@@ -2,7 +2,8 @@ use crate::performance_based_algorithm::results::{
     BaseRewards, BaseRewardsType3, DailyResults, NodeMetricsDaily, NodeProviderRewards,
     NodeResults, NodeStatus, Percent, RewardsCalculatorResults, XDRPermyriad,
 };
-use crate::types::{DayUtc, NodeMetricsDailyRaw, Region, RewardableNode};
+use crate::types::{NodeMetricsDailyRaw, Region, RewardableNode};
+use chrono::NaiveDate;
 use ic_base_types::{NodeId, PrincipalId, SubnetId};
 use ic_protobuf::registry::node::v1::NodeRewardType;
 use ic_protobuf::registry::node_rewards::v2::NodeRewardsTable;
@@ -71,21 +72,21 @@ struct AdjustedRewardsResults {
 }
 
 pub trait DataProvider {
-    fn get_rewards_table(&self, day: &DayUtc) -> Result<NodeRewardsTable, String>;
+    fn get_rewards_table(&self, date: &NaiveDate) -> Result<NodeRewardsTable, String>;
 
     fn get_daily_metrics_by_subnet(
         &self,
-        day: &DayUtc,
+        date: &NaiveDate,
     ) -> Result<BTreeMap<SubnetId, Vec<NodeMetricsDailyRaw>>, String>;
 
     fn get_rewardable_nodes(
         &self,
-        day: &DayUtc,
+        date: &NaiveDate,
     ) -> Result<BTreeMap<PrincipalId, Vec<RewardableNode>>, String>;
 
     fn get_provider_rewardable_nodes(
         &self,
-        day: &DayUtc,
+        date: &NaiveDate,
         provider_id: &PrincipalId,
     ) -> Result<Vec<RewardableNode>, String>;
 }
@@ -115,16 +116,16 @@ trait PerformanceBasedAlgorithm {
     const REWARDS_TABLE_DAYS: Decimal = dec!(30.4375);
 
     fn calculate_rewards(
-        from_day: &DayUtc,
-        to_day: &DayUtc,
+        from_date: &NaiveDate,
+        to_date: &NaiveDate,
         node_provider_filter: Option<PrincipalId>,
         data_provider: impl DataProvider,
     ) -> Result<RewardsCalculatorResults, String> {
-        if from_day > to_day {
+        if from_date > to_date {
             return Err("from_day must be before to_day".to_string());
         }
 
-        let reward_period = from_day.days_until(to_day)?;
+        let reward_period = from_date.iter_days().take_while(|d| d <= to_date);
         let mut total_rewards_per_provider = BTreeMap::new();
         let mut daily_results = BTreeMap::new();
 
@@ -156,16 +157,17 @@ trait PerformanceBasedAlgorithm {
 
     fn calculate_daily_rewards(
         data_provider: &impl DataProvider,
-        day: &DayUtc,
+        date: &NaiveDate,
         node_provider_filter: &Option<PrincipalId>,
     ) -> Result<DailyResults, String> {
-        let rewards_table = data_provider.get_rewards_table(day)?;
-        let metrics_by_subnet = data_provider.get_daily_metrics_by_subnet(day)?;
+        let rewards_table = data_provider.get_rewards_table(date)?;
+        let metrics_by_subnet = data_provider.get_daily_metrics_by_subnet(date)?;
         let providers_rewardable_nodes = if let Some(provider_id) = node_provider_filter {
-            let rewardable_nodes = data_provider.get_provider_rewardable_nodes(day, provider_id)?;
+            let rewardable_nodes =
+                data_provider.get_provider_rewardable_nodes(date, provider_id)?;
             btreemap! { *provider_id => rewardable_nodes }
         } else {
-            data_provider.get_rewardable_nodes(day)?
+            data_provider.get_rewardable_nodes(date)?
         };
         let mut results_per_provider = BTreeMap::new();
 
diff --git a/rs/node_rewards/rewards_calculation/src/performance_based_algorithm/results.rs b/rs/node_rewards/rewards_calculation/src/performance_based_algorithm/results.rs
index 2d066a435b..45eb704041 100644
--- a/rs/node_rewards/rewards_calculation/src/performance_based_algorithm/results.rs
+++ b/rs/node_rewards/rewards_calculation/src/performance_based_algorithm/results.rs
@@ -1,4 +1,4 @@
-use crate::types::DayUtc;
+use chrono::NaiveDate;
 use ic_base_types::{NodeId, PrincipalId, SubnetId};
 use ic_protobuf::registry::node::v1::NodeRewardType;
 use rust_decimal::Decimal;
@@ -69,8 +69,7 @@ pub struct DailyResults {
     pub provider_results: BTreeMap<PrincipalId, NodeProviderRewards>,
 }
 
-#[derive(Serialize, Deserialize)]
 pub struct RewardsCalculatorResults {
     pub total_rewards_xdr_permyriad: BTreeMap<PrincipalId, u64>,
-    pub daily_results: BTreeMap<DayUtc, DailyResults>,
+    pub daily_results: BTreeMap<NaiveDate, DailyResults>,
 }
diff --git a/rs/node_rewards/rewards_calculation/src/performance_based_algorithm/v1.rs b/rs/node_rewards/rewards_calculation/src/performance_based_algorithm/v1.rs
index 83deedbb20..6fb37bc87e 100644
--- a/rs/node_rewards/rewards_calculation/src/performance_based_algorithm/v1.rs
+++ b/rs/node_rewards/rewards_calculation/src/performance_based_algorithm/v1.rs
@@ -1,6 +1,6 @@
 use crate::performance_based_algorithm::results::RewardsCalculatorResults;
 use crate::performance_based_algorithm::{DataProvider, PerformanceBasedAlgorithm};
-use crate::types::DayUtc;
+use chrono::NaiveDate;
 use ic_base_types::PrincipalId;
 use rust_decimal::Decimal;
 use rust_decimal_macros::dec;
@@ -36,14 +36,14 @@ impl PerformanceBasedAlgorithm for RewardsCalculationV1 {
 
 impl RewardsCalculationV1 {
     pub fn calculate_rewards(
-        from_day: &DayUtc,
-        to_day: &DayUtc,
+        from_date: &NaiveDate,
+        to_date: &NaiveDate,
         node_provider_filter: Option<PrincipalId>,
         data_provider: impl DataProvider,
     ) -> Result<RewardsCalculatorResults, String> {
         <RewardsCalculationV1 as PerformanceBasedAlgorithm>::calculate_rewards(
-            from_day,
-            to_day,
+            from_date,
+            to_date,
             node_provider_filter,
             data_provider,
         )
diff --git a/rs/node_rewards/rewards_calculation/src/types.rs b/rs/node_rewards/rewards_calculation/src/types.rs
index ec99adce94..22fc702296 100644
--- a/rs/node_rewards/rewards_calculation/src/types.rs
+++ b/rs/node_rewards/rewards_calculation/src/types.rs
@@ -1,139 +1,10 @@
-use chrono::{DateTime, NaiveDateTime, ParseError, Utc};
 use ic_base_types::NodeId;
 use ic_protobuf::registry::node::v1::NodeRewardType;
-use ic_types::Time;
-use serde::{Deserialize, Serialize};
-use std::fmt;
-use std::fmt::Display;
 
 pub type UnixTsNanos = u64;
 pub type NodesCount = u64;
 pub type Region = String;
 
-const NANOS_PER_DAY: UnixTsNanos = 24 * 60 * 60 * 1_000_000_000;
-
-#[derive(Clone, Debug, PartialEq, Hash, PartialOrd, Ord, Eq, Copy, Deserialize, Serialize)]
-pub struct DayUtc {
-    last_ts_nanoseconds: u64,
-}
-
-impl DayUtc {
-    pub fn from_nanos(value: u64) -> Self {
-        let last_ts_nanoseconds = value
-            .checked_div(NANOS_PER_DAY)
-            .and_then(|v| v.checked_add(1))
-            .and_then(|v| v.checked_mul(NANOS_PER_DAY))
-            .and_then(|v| v.checked_sub(1))
-            .unwrap();
-
-        Self {
-            last_ts_nanoseconds,
-        }
-    }
-
-    pub fn from_secs(value: u64) -> Self {
-        let nanos = value * 1_000_000_000;
-        Self::from_nanos(nanos)
-    }
-}
-
-impl From<Time> for DayUtc {
-    fn from(value: Time) -> Self {
-        Self::from_nanos(value.as_nanos_since_unix_epoch())
-    }
-}
-
-impl Display for DayUtc {
-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
-        let dd_mm_yyyy =
-            DateTime::from_timestamp_nanos(self.unix_timestamp_at_day_end_nanoseconds() as i64)
-                .naive_utc()
-                .format("%d-%m-%Y")
-                .to_string();
-        write!(f, "{}", dd_mm_yyyy)
-    }
-}
-
-impl TryFrom<&str> for DayUtc {
-    type Error = ParseError;
-
-    fn try_from(value: &str) -> Result<Self, Self::Error> {
-        let dt = format!("{} 00:00:00", value);
-        let naive = NaiveDateTime::parse_from_str(&dt, "%Y-%m-%d %H:%M:%S")?;
-        let datetime: DateTime<Utc> = DateTime::from_naive_utc_and_offset(naive, Utc);
-        let ts = datetime.timestamp_nanos_opt().unwrap() as u64;
-
-        Ok(DayUtc::from_nanos(ts))
-    }
-}
-
-impl Default for DayUtc {
-    fn default() -> Self {
-        DayUtc::from_nanos(0)
-    }
-}
-
-impl DayUtc {
-    pub fn unix_timestamp_at_day_end_nanoseconds(&self) -> u64 {
-        self.last_ts_nanoseconds
-    }
-
-    pub fn unix_timestamp_at_day_start_nanoseconds(&self) -> u64 {
-        let extra = self.last_ts_nanoseconds.checked_rem(NANOS_PER_DAY).unwrap();
-
-        self.last_ts_nanoseconds.saturating_sub(extra)
-    }
-
-    pub fn unix_timestamp_at_day_end_seconds(&self) -> u64 {
-        self.unix_timestamp_at_day_end_nanoseconds()
-            .checked_div(1_000_000_000)
-            .unwrap()
-    }
-
-    pub fn unix_timestamp_at_day_start_seconds(&self) -> u64 {
-        self.unix_timestamp_at_day_start_nanoseconds()
-            .checked_div(1_000_000_000)
-            .expect("underflow detected in first_ts_secs")
-    }
-
-    pub fn next_day(&self) -> DayUtc {
-        DayUtc {
-            last_ts_nanoseconds: self
-                .last_ts_nanoseconds
-                .checked_add(NANOS_PER_DAY)
-                .expect("overflow detected in next_day"),
-        }
-    }
-
-    pub fn previous_day(&self) -> DayUtc {
-        let ts_previous_day = self
-            .last_ts_nanoseconds
-            .checked_sub(NANOS_PER_DAY)
-            .unwrap_or_default();
-        DayUtc {
-            last_ts_nanoseconds: ts_previous_day,
-        }
-    }
-
-    pub fn days_until(&self, other: &DayUtc) -> Result<Vec<DayUtc>, String> {
-        if self > other {
-            return Err(format!(
-                "Cannot compute days_until: {} > {}",
-                self.last_ts_nanoseconds, other.last_ts_nanoseconds
-            ));
-        }
-
-        let num_days = (other.last_ts_nanoseconds - self.last_ts_nanoseconds) / NANOS_PER_DAY;
-        let days_until = (0..=num_days)
-            .map(|i| DayUtc {
-                last_ts_nanoseconds: self.last_ts_nanoseconds + i * NANOS_PER_DAY,
-            })
-            .collect();
-
-        Ok(days_until)
-    }
-}
-
 #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
 pub struct NodeMetricsDailyRaw {
     pub node_id: NodeId,
@@ -148,32 +19,3 @@ pub struct RewardableNode {
     pub node_reward_type: NodeRewardType,
     pub dc_id: String,
 }
-
-#[cfg(test)]
-mod tests {
-    use super::*;
-    use crate::types::UnixTsNanos;
-    use chrono::{TimeZone, Utc};
-
-    fn ymdh_to_ts(year: i32, month: u32, day: u32, hour: u32) -> UnixTsNanos {
-        Utc.with_ymd_and_hms(year, month, day, hour, 0, 0)
-            .unwrap()
-            .timestamp_nanos_opt()
-            .unwrap() as UnixTsNanos
-    }
-
-    #[test]
-    fn test_valid_rewarding_period() {
-        let from_day: DayUtc = DayUtc::from_nanos(ymdh_to_ts(2020, 1, 12, 0));
-        let to_day: DayUtc = DayUtc::from_nanos(ymdh_to_ts(2020, 1, 15, 0));
-
-        let days = from_day.days_until(&to_day).unwrap().len();
-
-        assert_eq!(days, 4);
-
-        let to_day = DayUtc::from_nanos(ymdh_to_ts(2020, 1, 12, 13));
-        let days = from_day.days_until(&to_day).unwrap().len();
-
-        assert_eq!(days, 1);
-    }
-}
```

---

### Commit `d161192b1376423686e5a826b7affb0da7bc868c`

**Author:** Mathias Bj√∂rkqvist <mathias.bjorkqvist@dfinity.org>  
**Date:** 2025-09-26  
**Message:** chore(ICP_Ledger): FI-1845: Remove ICP ledger notify-method feature (#6717)

**Files Changed:**
- `rs/node_rewards/canister/BUILD.bazel`

**Code Changes:**

```diff
commit d161192b1376423686e5a826b7affb0da7bc868c
Author: Mathias Bj√∂rkqvist <mathias.bjorkqvist@dfinity.org>
Date:   Fri Sep 26 12:36:09 2025 +0200

    chore(ICP_Ledger): FI-1845: Remove ICP ledger notify-method feature (#6717)
    
    Remove the `notify-method` feature from the ICP ledger canister. The
    `notify` endpoint is still exported, but traps when called. Since many
    consumers still expect the `ledger-canister_notify-method.wasm.gz` file,
    this is still being built and uploaded to the CDN, but it is identical
    to the `ledger-canister.wasm.gz` file. Subsequent ICP ledger suite
    releases will include both (identical) files, and at some later point,
    the `ledger-canister_notify-method.wasm.gz` will be removed.

diff --git a/rs/node_rewards/canister/BUILD.bazel b/rs/node_rewards/canister/BUILD.bazel
index f640f6783a..5a7f643961 100644
--- a/rs/node_rewards/canister/BUILD.bazel
+++ b/rs/node_rewards/canister/BUILD.bazel
@@ -61,7 +61,7 @@ DEV_DATA = [
     # Keep sorted.
     ":node-rewards-canister",
     ":node-rewards-canister-test",
-    "//rs/ledger_suite/icp/ledger:ledger-canister-wasm-notify-method",
+    "//rs/ledger_suite/icp/ledger:ledger-canister-wasm",
     "//rs/nns/cmc:cycles-minting-canister",
     "//rs/nns/governance:governance-canister",
     "//rs/nns/governance:governance-canister-test",
@@ -82,7 +82,7 @@ DEV_ENV = {
     "GENESIS_TOKEN_CANISTER_WASM_PATH": "$(rootpath //rs/nns/gtc:genesis-token-canister)",
     "GOVERNANCE_CANISTER_WASM_PATH": "$(rootpath //rs/nns/governance:governance-canister)",
     "GOVERNANCE_CANISTER_TEST_WASM_PATH": "$(rootpath //rs/nns/governance:governance-canister-test)",
-    "LEDGER_CANISTER_NOTIFY_METHOD_WASM_PATH": "$(rootpath //rs/ledger_suite/icp/ledger:ledger-canister-wasm-notify-method)",
+    "LEDGER_CANISTER_WASM_PATH": "$(rootpath //rs/ledger_suite/icp/ledger:ledger-canister-wasm)",
     "LIFELINE_CANISTER_WASM_PATH": "$(rootpath //rs/nns/handlers/lifeline/impl:lifeline_canister)",
     "REGISTRY_CANISTER_WASM_PATH": "$(rootpath //rs/registry/canister:registry-canister)",
     "ROOT_CANISTER_WASM_PATH": "$(rootpath //rs/nns/handlers/root/impl:root-canister)",
```

---

### Commit `ef7cd8fdf88c3fae338854a378cf284522d8357c`

**Author:** pietrodimarco-dfinity <124565147+pietrodimarco-dfinity@users.noreply.github.com>  
**Date:** 2025-09-25  
**Message:** fix(node-rewards-canister): Consolidate DayUtc type (#6853)

**Files Changed:**
- `rs/node_rewards/canister/api/BUILD.bazel`
- `rs/node_rewards/canister/api/Cargo.toml`
- `rs/node_rewards/canister/api/src/lib.rs`
- `rs/node_rewards/canister/api/src/provider_rewards_calculation.rs`
- `rs/node_rewards/canister/api/src/providers_rewards.rs`
- `rs/node_rewards/canister/node-rewards-canister.did`
- `rs/node_rewards/canister/src/api_conversion.rs`
- `rs/node_rewards/canister/src/canister/mod.rs`
- `rs/node_rewards/canister/src/canister/test/get_node_providers_rewards.rs`
- `rs/node_rewards/canister/src/metrics.rs`
- `rs/node_rewards/canister/src/metrics/tests.rs`
- `rs/node_rewards/canister/src/registry_querier.rs`
- `rs/node_rewards/canister/src/registry_querier/tests.rs`
- `rs/node_rewards/canister/tests/get_node_providers_monthly_xdr_rewards.rs`
- `rs/node_rewards/rewards_calculation/BUILD.bazel`
- `rs/node_rewards/rewards_calculation/Cargo.toml`
- `rs/node_rewards/rewards_calculation/src/types.rs`

**Code Changes:**

```diff
commit ef7cd8fdf88c3fae338854a378cf284522d8357c
Author: pietrodimarco-dfinity <124565147+pietrodimarco-dfinity@users.noreply.github.com>
Date:   Thu Sep 25 19:41:33 2025 +0200

    fix(node-rewards-canister): Consolidate DayUtc type (#6853)
    
    This introduces some breaking changes to the Node Rewards canister API,
    but that is ok, because nobody is calling it yet.
    
    ---------
    
    Co-authored-by: Daniel Wong <97631336+daniel-wong-dfinity-org@users.noreply.github.com>

diff --git a/rs/node_rewards/canister/api/BUILD.bazel b/rs/node_rewards/canister/api/BUILD.bazel
index 5cede2d4c8..a577bcc4cc 100644
--- a/rs/node_rewards/canister/api/BUILD.bazel
+++ b/rs/node_rewards/canister/api/BUILD.bazel
@@ -5,6 +5,7 @@ package(default_visibility = ["//visibility:public"])
 DEPENDENCIES = [
     # Keep sorted.
     "//rs/nervous_system/proto",
+    "//rs/node_rewards/rewards_calculation",
     "//rs/types/base_types",
     "@crate_index//:candid",
     "@crate_index//:ic-cdk",
diff --git a/rs/node_rewards/canister/api/Cargo.toml b/rs/node_rewards/canister/api/Cargo.toml
index 4c7ddb9b62..decff706f9 100644
--- a/rs/node_rewards/canister/api/Cargo.toml
+++ b/rs/node_rewards/canister/api/Cargo.toml
@@ -12,5 +12,6 @@ path = "src/lib.rs"
 [dependencies]
 candid = { workspace = true }
 ic-base-types = { path = "../../../types/base_types" }
+rewards-calculation = { path = "../../rewards_calculation" }
 ic-nervous-system-proto = { path = "../../../nervous_system/proto" }
 serde = { workspace = true }
diff --git a/rs/node_rewards/canister/api/src/lib.rs b/rs/node_rewards/canister/api/src/lib.rs
index 1647c81b1f..15ce9c70ea 100644
--- a/rs/node_rewards/canister/api/src/lib.rs
+++ b/rs/node_rewards/canister/api/src/lib.rs
@@ -1,3 +1,43 @@
 pub mod monthly_rewards;
 pub mod provider_rewards_calculation;
 pub mod providers_rewards;
+
+use rewards_calculation::types as native_types;
+
+// These are API-facing types with all fields wrapped in `Option`
+// to ensure deserialization always works
+// in the future without breaking clients that consume the API.
+#[derive(
+    PartialOrd, Ord, Eq, candid::CandidType, candid::Deserialize, Clone, Copy, PartialEq, Debug,
+)]
+pub struct DayUtc {
+    last_ts_nanoseconds: Option<u64>,
+}
+
+impl DayUtc {
+    pub fn from_nanos(nanos_since_unix_epoch: u64) -> Self {
+        Self::from(native_types::DayUtc::from_nanos(nanos_since_unix_epoch))
+    }
+
+    pub fn from_secs(secs_since_unix_epoch: u64) -> Self {
+        Self::from(native_types::DayUtc::from_secs(secs_since_unix_epoch))
+    }
+}
+
+impl From<native_types::DayUtc> for DayUtc {
+    fn from(day_utc: native_types::DayUtc) -> Self {
+        Self {
+            last_ts_nanoseconds: Some(day_utc.unix_timestamp_at_day_end_nanoseconds()),
+        }
+    }
+}
+
+impl From<DayUtc> for native_types::DayUtc {
+    fn from(day_utc: DayUtc) -> Self {
+        native_types::DayUtc::from_nanos(
+            day_utc
+                .last_ts_nanoseconds
+                .expect("last_ts_nanoseconds is None"),
+        )
+    }
+}
diff --git a/rs/node_rewards/canister/api/src/provider_rewards_calculation.rs b/rs/node_rewards/canister/api/src/provider_rewards_calculation.rs
index 96d677460b..984536628c 100644
--- a/rs/node_rewards/canister/api/src/provider_rewards_calculation.rs
+++ b/rs/node_rewards/canister/api/src/provider_rewards_calculation.rs
@@ -1,23 +1,20 @@
+pub use crate::DayUtc;
 use candid::{CandidType, Deserialize, Principal};
 use ic_base_types::PrincipalId;
 use ic_nervous_system_proto::pb::v1::Decimal;
 
 #[derive(CandidType, Clone, Deserialize)]
 pub struct GetNodeProviderRewardsCalculationRequest {
-    pub from_day_timestamp_nanos: u64,
-    pub to_day_timestamp_nanos: u64,
+    pub from_day: DayUtc,
+    pub to_day: DayUtc,
     pub provider_id: Principal,
 }
 
 pub type GetNodeProviderRewardsCalculationResponse = Result<Vec<NodeProviderRewardsDaily>, String>;
 
-#[derive(
-    PartialOrd, Ord, Eq, candid::CandidType, candid::Deserialize, Clone, Copy, PartialEq, Debug,
-)]
-pub struct DayUtc {
-    pub value: Option<u64>,
-}
-
+// These are API-facing types with all fields wrapped in `Option`
+// to ensure forward compatibility. This way, new fields can be added
+// in the future without breaking clients that consume the API.
 #[derive(candid::CandidType, candid::Deserialize, Clone, PartialEq, Debug)]
 pub struct NodeMetricsDaily {
     pub subnet_assigned: Option<PrincipalId>,
diff --git a/rs/node_rewards/canister/api/src/providers_rewards.rs b/rs/node_rewards/canister/api/src/providers_rewards.rs
index 20f39b035f..dc4fb8cafc 100644
--- a/rs/node_rewards/canister/api/src/providers_rewards.rs
+++ b/rs/node_rewards/canister/api/src/providers_rewards.rs
@@ -1,10 +1,11 @@
+use crate::DayUtc;
 use candid::{CandidType, Deserialize, Principal};
 use std::collections::BTreeMap;
 
 #[derive(CandidType, Clone, Deserialize)]
 pub struct GetNodeProvidersRewardsRequest {
-    pub from_day_timestamp_nanos: u64,
-    pub to_day_timestamp_nanos: u64,
+    pub from_day: DayUtc,
+    pub to_day: DayUtc,
 }
 pub type GetNodeProvidersRewardsResponse = Result<NodeProvidersRewards, String>;
 
diff --git a/rs/node_rewards/canister/node-rewards-canister.did b/rs/node_rewards/canister/node-rewards-canister.did
index c79541bd5c..ddd78881cd 100644
--- a/rs/node_rewards/canister/node-rewards-canister.did
+++ b/rs/node_rewards/canister/node-rewards-canister.did
@@ -5,7 +5,7 @@ type Decimal = record {
 };
 
 type DayUtc = record {
-  value: opt nat64;
+  last_ts_nanoseconds: opt nat64;
 };
 
 type NodeMetricsDaily = record {
@@ -64,8 +64,8 @@ type NodeProviderRewardsDaily = record {
 type GetNodeProviderRewardsCalculationResponse = variant { Ok: vec NodeProviderRewardsDaily; Err: text };
 
 type GetNodeProviderRewardsCalculationRequest = record {
-  from_day_timestamp_nanos: nat64;
-  to_day_timestamp_nanos: nat64;
+  from_day: DayUtc;
+  to_day: DayUtc;
   provider_id: principal;
 };
 
@@ -79,8 +79,8 @@ type NodeProvidersRewards = record {
 };
 
 type GetNodeProvidersRewardsRequest = record {
-  from_day_timestamp_nanos: nat64;
-  to_day_timestamp_nanos: nat64;
+  from_day: DayUtc;
+  to_day: DayUtc;
 };
 
 type GetNodeProvidersRewardsResponse = variant { Ok: NodeProvidersRewards; Err: text };
diff --git a/rs/node_rewards/canister/src/api_conversion.rs b/rs/node_rewards/canister/src/api_conversion.rs
index 98ce409b69..02079e373f 100644
--- a/rs/node_rewards/canister/src/api_conversion.rs
+++ b/rs/node_rewards/canister/src/api_conversion.rs
@@ -1,6 +1,6 @@
 use ic_base_types::PrincipalId;
 use ic_node_rewards_canister_api::provider_rewards_calculation::{
-    BaseRewards as BaseRewardsCandid, BaseRewardsType3 as BaseRewardsType3Candid, DayUtc,
+    BaseRewards as BaseRewardsCandid, BaseRewardsType3 as BaseRewardsType3Candid,
     GetNodeProviderRewardsCalculationResponse, NodeMetricsDaily as NodeMetricsDailyCandid,
     NodeProviderRewards as NodeProviderRewardsCandid, NodeProviderRewardsDaily,
     NodeResults as NodeResultsCandid, NodeStatus as NodeStatusCandid,
@@ -88,9 +88,7 @@ pub fn into_rewards_calculation_results(
         };
 
         daily_rewards.push(NodeProviderRewardsDaily {
-            day_utc: Some(DayUtc {
-                value: Some(day.unix_ts_at_day_end_nanoseconds()),
-            }),
+            day_utc: Some(day.into()),
             node_provider_rewards: Some(node_provider_rewards),
         });
     }
diff --git a/rs/node_rewards/canister/src/canister/mod.rs b/rs/node_rewards/canister/src/canister/mod.rs
index 20eef68823..e613b42873 100644
--- a/rs/node_rewards/canister/src/canister/mod.rs
+++ b/rs/node_rewards/canister/src/canister/mod.rs
@@ -128,7 +128,7 @@ impl NodeRewardsCanister {
     }
 
     fn validate_reward_period(from_day: &DayUtc, to_day: &DayUtc) -> Result<(), String> {
-        let today: DayUtc = current_time().as_nanos_since_unix_epoch().into();
+        let today: DayUtc = current_time().into();
         if from_day > to_day {
             return Err("from_day must be before to_day".to_string());
         }
@@ -143,8 +143,8 @@ impl NodeRewardsCanister {
         request: GetNodeProvidersRewardsRequest,
         provider_filter: Option<PrincipalId>,
     ) -> Result<RewardsCalculatorResults, String> {
-        let start_day = DayUtc::from(request.from_day_timestamp_nanos);
-        let end_day = DayUtc::from(request.to_day_timestamp_nanos);
+        let start_day = request.from_day.into();
+        let end_day = request.to_day.into();
         Self::validate_reward_period(&start_day, &end_day)?;
 
         RewardsCalculationV1::calculate_rewards(&start_day, &end_day, provider_filter, self)
@@ -157,7 +157,7 @@ impl rewards_calculation::performance_based_algorithm::DataProvider for &NodeRew
         let registry_querier = RegistryQuerier::new(self.registry_client.clone());
 
         let version = registry_querier
-            .version_for_timestamp(day.unix_ts_at_day_end_nanoseconds())
+            .version_for_timestamp(day.unix_timestamp_at_day_end_nanoseconds())
             .ok_or_else(|| "Could not find registry version for timestamp".to_string())?;
         Ok(registry_querier.get_rewards_table(version))
     }
@@ -168,7 +168,10 @@ impl rewards_calculation::performance_based_algorithm::DataProvider for &NodeRew
     ) -> Result<BTreeMap<SubnetId, Vec<NodeMetricsDailyRaw>>, String> {
         let metrics = self.metrics_manager.metrics_by_subnet(day);
         if metrics.is_empty() {
-            return Err(format!("No metrics found for day {}", day.get()));
+            return Err(format!(
+                "No metrics found for day {}",
+                day.unix_timestamp_at_day_end_nanoseconds()
+            ));
         }
         Ok(metrics)
     }
@@ -304,8 +307,8 @@ impl NodeRewardsCanister {
     ) -> GetNodeProviderRewardsCalculationResponse {
         let provider_id = PrincipalId::from(request.provider_id);
         let request_inner = GetNodeProvidersRewardsRequest {
-            from_day_timestamp_nanos: request.from_day_timestamp_nanos,
-            to_day_timestamp_nanos: request.to_day_timestamp_nanos,
+            from_day: request.from_day,
+            to_day: request.to_day,
         };
         let result = canister
             .with_borrow(|canister| canister.calculate_rewards(request_inner, Some(provider_id)))?;
diff --git a/rs/node_rewards/canister/src/canister/test/get_node_providers_rewards.rs b/rs/node_rewards/canister/src/canister/test/get_node_providers_rewards.rs
index 9171eb4ec7..a23ea75201 100644
--- a/rs/node_rewards/canister/src/canister/test/get_node_providers_rewards.rs
+++ b/rs/node_rewards/canister/src/canister/test/get_node_providers_rewards.rs
@@ -188,7 +188,7 @@ fn setup_data_for_test_rewards_calculation(
     fake_registry.set_value_at_version_with_timestamp(
         make_node_record_key(p1_node3_t31),
         6,
-        day2.get(),
+        day2.unix_timestamp_at_day_end_nanoseconds(),
         None,
     );
 
@@ -214,7 +214,7 @@ fn setup_data_for_test_rewards_calculation(
     fake_registry.set_value_at_version_with_timestamp(
         make_node_record_key(p1_node5_perf),
         6,
-        day2.get(),
+        day2.unix_timestamp_at_day_end_nanoseconds(),
         None,
     );
 
@@ -231,7 +231,7 @@ fn setup_data_for_test_rewards_calculation(
     fake_registry.set_value_at_version_with_timestamp(
         make_node_record_key(p2_node1),
         6,
-        day2.get(),
+        day2.unix_timestamp_at_day_end_nanoseconds(),
         None,
     );
 
@@ -241,7 +241,7 @@ fn setup_data_for_test_rewards_calculation(
     // Day 1 subnet 1
     subnets_metrics.insert(
         SubnetMetricsKey {
-            timestamp_nanos: day1.unix_ts_at_day_end_nanoseconds(),
+            timestamp_nanos: day1.unix_timestamp_at_day_end_nanoseconds(),
             subnet_id: Some(subnet1.get()),
         },
         SubnetMetricsValue {
@@ -273,7 +273,7 @@ fn setup_data_for_test_rewards_calculation(
     // Day 1 subnet 2
     subnets_metrics.insert(
         SubnetMetricsKey {
-            timestamp_nanos: day1.unix_ts_at_day_end_nanoseconds(),
+            timestamp_nanos: day1.unix_timestamp_at_day_end_nanoseconds(),
             subnet_id: Some(subnet2.get()),
         },
         SubnetMetricsValue {
@@ -288,7 +288,7 @@ fn setup_data_for_test_rewards_calculation(
     // Day 2 subnet 1
     subnets_metrics.insert(
         SubnetMetricsKey {
-            timestamp_nanos: day2.unix_ts_at_day_end_nanoseconds(),
+            timestamp_nanos: day2.unix_timestamp_at_day_end_nanoseconds(),
             subnet_id: Some(subnet1.get()),
         },
         SubnetMetricsValue {
@@ -313,8 +313,8 @@ fn test_get_node_providers_rewards() {
     let to = DayUtc::try_from("2024-01-02").unwrap();
 
     let request = GetNodeProvidersRewardsRequest {
-        from_day_timestamp_nanos: from.unix_ts_at_day_start_nanoseconds(),
-        to_day_timestamp_nanos: to.unix_ts_at_day_end_nanoseconds(),
+        from_day: from.into(),
+        to_day: to.into(),
     };
     let result_endpoint =
         NodeRewardsCanister::get_node_providers_rewards(&CANISTER_TEST, request.clone())
diff --git a/rs/node_rewards/canister/src/metrics.rs b/rs/node_rewards/canister/src/metrics.rs
index 7e7941f079..80a5cc55cc 100644
--- a/rs/node_rewards/canister/src/metrics.rs
+++ b/rs/node_rewards/canister/src/metrics.rs
@@ -187,13 +187,15 @@ where
         day_utc: &DayUtc,
     ) -> BTreeMap<SubnetId, Vec<NodeMetricsDailyRaw>> {
         let mut metrics_by_subnet = BTreeMap::new();
-        let previous_day_ts = day_utc.previous_day().unix_ts_at_day_start_nanoseconds();
+        let previous_day_ts = day_utc
+            .previous_day()
+            .unix_timestamp_at_day_start_nanoseconds();
         let first_key = SubnetMetricsKey {
             timestamp_nanos: previous_day_ts,
             ..SubnetMetricsKey::min_key()
         };
         let last_key = SubnetMetricsKey {
-            timestamp_nanos: day_utc.get(),
+            timestamp_nanos: day_utc.unix_timestamp_at_day_end_nanoseconds(),
             ..SubnetMetricsKey::max_key()
         };
 
@@ -201,7 +203,7 @@ where
             .subnets_metrics
             .borrow()
             .range(first_key..=last_key)
-            .into_group_map_by(|(k, _)| k.timestamp_nanos.into())
+            .into_group_map_by(|(k, _)| DayUtc::from_nanos(k.timestamp_nanos))
             .into_iter()
             .collect();
 
diff --git a/rs/node_rewards/canister/src/metrics/tests.rs b/rs/node_rewards/canister/src/metrics/tests.rs
index 8fc016da2f..378cbd5c77 100644
--- a/rs/node_rewards/canister/src/metrics/tests.rs
+++ b/rs/node_rewards/canister/src/metrics/tests.rs
@@ -250,7 +250,10 @@ impl NodeMetricsHistoryResponseTracker {
         for (from, proposed_failed) in metrics {
             let mut metrics_day = from;
             for (proposed, failed) in proposed_failed {
-                let entry = self.subnets_responses.entry(metrics_day.get()).or_default();
+                let entry = self
+                    .subnets_responses
+                    .entry(metrics_day.unix_timestamp_at_day_end_nanoseconds())
+                    .or_default();
                 let entry_sub = entry.entry(self.current_subnet).or_default();
 
                 entry_sub.push(NodeMetrics {
@@ -295,17 +298,18 @@ impl NodeMetricsHistoryResponseTracker {
 }
 
 async fn _daily_metrics_correct_different_update_size(size: usize) {
+    let day_start = DayUtc::from_nanos(0);
     let tracker = NodeMetricsHistoryResponseTracker::new()
         .with_subnet(subnet_id(1))
         .add_node_metrics(
             node_id(1),
-            vec![(0.into(), vec![(7, 5), (10, 6), (15, 6), (25, 50)])],
+            vec![(day_start, vec![(7, 5), (10, 6), (15, 6), (25, 50)])],
         )
-        .add_node_metrics(node_id(2), vec![(0.into(), vec![(19, 21), (32, 22)])])
+        .add_node_metrics(node_id(2), vec![(day_start, vec![(19, 21), (32, 22)])])
         // Node 2 is redeployed to subnet 1 on day 2
         .add_node_metrics(
             node_id(2),
-            vec![((3 * ONE_DAY_NANOS).into(), vec![(10, 10)])],
+            vec![(day_start.next_day().next_day().next_day(), vec![(10, 10)])],
         );
 
     let mut mock = mock::MockCanisterClient::new();
@@ -317,7 +321,7 @@ async fn _daily_metrics_correct_different_update_size(size: usize) {
         mm.update_subnets_metrics(vec![subnet_id(1)]).await;
     }
     let daily_metrics: Vec<Vec<NodeMetricsDailyRaw>> =
-        mm.metrics_by_subnet(&0.into()).into_values().collect();
+        mm.metrics_by_subnet(&day_start).into_values().collect();
 
     println!("{:?}", daily_metrics);
 
@@ -329,7 +333,7 @@ async fn _daily_metrics_correct_different_update_size(size: usize) {
     assert_eq!(daily_metrics[0][1].num_blocks_failed, 21);
 
     let daily_metrics: Vec<Vec<NodeMetricsDailyRaw>> = mm
-        .metrics_by_subnet(&ONE_DAY_NANOS.into())
+        .metrics_by_subnet(&day_start.next_day())
         .into_values()
         .collect();
 
@@ -342,7 +346,7 @@ async fn _daily_metrics_correct_different_update_size(size: usize) {
     assert_eq!(daily_metrics[0][1].num_blocks_failed, 1);
 
     let daily_metrics: Vec<Vec<NodeMetricsDailyRaw>> = mm
-        .metrics_by_subnet(&(2 * ONE_DAY_NANOS).into())
+        .metrics_by_subnet(&day_start.next_day().next_day())
         .into_values()
         .collect();
 
@@ -351,7 +355,7 @@ async fn _daily_metrics_correct_different_update_size(size: usize) {
     assert_eq!(daily_metrics[0][0].num_blocks_failed, 0);
 
     let daily_metrics: Vec<Vec<NodeMetricsDailyRaw>> = mm
-        .metrics_by_subnet(&(3 * ONE_DAY_NANOS).into())
+        .metrics_by_subnet(&day_start.next_day().next_day().next_day())
         .into_values()
         .collect();
 
@@ -377,14 +381,18 @@ async fn daily_metrics_correct_2_subs() {
     let subnet_2 = subnet_id(2);
 
     let node_1 = node_id(1);
+    let day_start = DayUtc::from_nanos(0);
 
     let tracker = NodeMetricsHistoryResponseTracker::new()
         .with_subnet(subnet_1)
-        .add_node_metrics(node_1, vec![(0.into(), vec![(1, 1), (2, 2), (3, 3)])])
+        .add_node_metrics(node_1, vec![(day_start, vec![(1, 1), (2, 2), (3, 3)])])
         .with_subnet(subnet_2)
         .add_node_metrics(
             node_1,
-            vec![((3 * ONE_DAY_NANOS).into(), vec![(4, 4), (6, 6), (8, 8)])],
+            vec![(
+                day_start.next_day().next_day().next_day(),
+                vec![(4, 4), (6, 6), (8, 8)],
+            )],
         );
 
     let mut mock = mock::MockCanisterClient::new();
@@ -399,7 +407,7 @@ async fn daily_metrics_correct_2_subs() {
     let mut node_1_daily_metrics = Vec::new();
     for day in 0..8 {
         let daily_metrics = mm
-            .metrics_by_subnet(&(day * ONE_DAY_NANOS).into())
+            .metrics_by_subnet(&DayUtc::from_nanos(day * ONE_DAY_NANOS))
             .into_iter()
             .collect::<BTreeMap<_, _>>()
             .into_iter()
@@ -468,19 +476,26 @@ async fn daily_metrics_correct_overlapping_days() {
 
     let node_1 = node_id(1);
     let node_2 = node_id(1);
+    let day_start = DayUtc::from_nanos(0);
 
     let tracker = NodeMetricsHistoryResponseTracker::new()
         .with_subnet(subnet_1)
-        .add_node_metrics(node_1, vec![(0.into(), vec![(1, 1), (2, 2), (3, 3)])])
+        .add_node_metrics(node_1, vec![(day_start, vec![(1, 1), (2, 2), (3, 3)])])
         .with_subnet(subnet_2)
         // Node 1 redeployed to subnet 2 on day 2
         .add_node_metrics(
             node_1,
-            vec![((2 * ONE_DAY_NANOS).into(), vec![(4, 4), (6, 6), (8, 8)])],
+            vec![(
+                day_start.next_day().next_day(),
+                vec![(4, 4), (6, 6), (8, 8)],
+            )],
         )
         .add_node_metrics(
             node_2,
-            vec![((2 * ONE_DAY_NANOS).into(), vec![(1, 1), (3, 3), (6, 6)])],
+            vec![(
+                day_start.next_day().next_day(),
+                vec![(1, 1), (3, 3), (6, 6)],
+            )],
         );
 
     let mut mock = mock::MockCanisterClient::new();
@@ -495,7 +510,7 @@ async fn daily_metrics_correct_overlapping_days() {
 
     let mut daily_metrics = Vec::new();
     for idx in 0..4 {
-        let day = (idx * ONE_DAY_NANOS).into();
+        let day = DayUtc::from_nanos(idx * ONE_DAY_NANOS);
         let metrics = mm
             .metrics_by_subnet(&day)
             .into_iter()
@@ -513,7 +528,7 @@ async fn daily_metrics_correct_overlapping_days() {
 
     let overlapping_sub_1 = daily_metrics
         .iter()
-        .find(|(sub, day, _)| sub == &subnet_1 && *day == (2 * ONE_DAY_NANOS).into())
+        .find(|(sub, day, _)| sub == &subnet_1 && *day == day_start.next_day().next_day())
         .map(|(_, _, node_metrics)| node_metrics)
         .unwrap();
 
@@ -522,7 +537,7 @@ async fn daily_metrics_correct_overlapping_days() {
 
     let overlapping_sub_2 = daily_metrics
         .iter()
-        .find(|(sub, day, _)| sub == &subnet_2 && *day == (2 * ONE_DAY_NANOS).into())
+        .find(|(sub, day, _)| sub == &subnet_2 && *day == day_start.next_day().next_day())
         .map(|(_, _, node_metrics)| node_metrics)
         .unwrap();
 
diff --git a/rs/node_rewards/canister/src/registry_querier.rs b/rs/node_rewards/canister/src/registry_querier.rs
index e983675bb9..2c80205763 100644
--- a/rs/node_rewards/canister/src/registry_querier.rs
+++ b/rs/node_rewards/canister/src/registry_querier.rs
@@ -87,7 +87,7 @@ impl RegistryQuerier {
     ) -> Result<BTreeMap<PrincipalId, Vec<RewardableNode>>, RegistryClientError> {
         let mut rewardable_nodes_per_provider: BTreeMap<_, Vec<RewardableNode>> = BTreeMap::new();
         let registry_version = self
-            .version_for_timestamp(day_utc.unix_ts_at_day_end_nanoseconds())
+            .version_for_timestamp(day_utc.unix_timestamp_at_day_end_nanoseconds())
             .unwrap();
         let nodes = self.nodes_in_version(registry_version)?;
 
diff --git a/rs/node_rewards/canister/src/registry_querier/tests.rs b/rs/node_rewards/canister/src/registry_querier/tests.rs
index 33514945ba..674eb405ba 100644
--- a/rs/node_rewards/canister/src/registry_querier/tests.rs
+++ b/rs/node_rewards/canister/src/registry_querier/tests.rs
@@ -45,7 +45,12 @@ fn add_record_helper(
     datetime_str: &str,
 ) {
     let ts = DayUtc::try_from(datetime_str).unwrap();
-    add_record_helper_ts(key, version, value, ts.unix_ts_at_day_end_nanoseconds());
+    add_record_helper_ts(
+        key,
+        version,
+        value,
+        ts.unix_timestamp_at_day_end_nanoseconds(),
+    );
 }
 
 fn add_record_helper_ts(key: &str, version: u64, value: Option<impl ::prost::Message>, ts: u64) {
@@ -143,7 +148,7 @@ fn add_dummy_data() {
     // Removed and re-added node_3 same day
     let ts_removed = DayUtc::try_from("2025-07-16")
         .unwrap()
-        .unix_ts_at_day_start_nanoseconds()
+        .unix_timestamp_at_day_start_nanoseconds()
         + 1;
     add_record_helper_ts(&node_3_k, 39676, None::<NodeRecord>, ts_removed);
     let ts_readded = ts_removed + 1;
diff --git a/rs/node_rewards/canister/tests/get_node_providers_monthly_xdr_rewards.rs b/rs/node_rewards/canister/tests/get_node_providers_monthly_xdr_rewards.rs
index bd5f326c7a..f0e79c9254 100644
--- a/rs/node_rewards/canister/tests/get_node_providers_monthly_xdr_rewards.rs
+++ b/rs/node_rewards/canister/tests/get_node_providers_monthly_xdr_rewards.rs
@@ -3,6 +3,7 @@ use ic_nervous_system_agent::AgentFor;
 use ic_nervous_system_agent::nns::node_rewards::get_node_providers_monthly_xdr_rewards;
 use ic_nns_constants::NODE_REWARDS_CANISTER_ID;
 use ic_nns_test_utils::common::build_node_rewards_test_wasm;
+use ic_node_rewards_canister_api::DayUtc;
 use ic_node_rewards_canister_api::monthly_rewards::GetNodeProvidersMonthlyXdrRewardsRequest;
 use ic_node_rewards_canister_api::provider_rewards_calculation::{
     GetNodeProviderRewardsCalculationRequest, GetNodeProviderRewardsCalculationResponse,
@@ -74,10 +75,11 @@ async fn get_node_provider_rewards_calculation_is_only_callable_in_nonreplicated
     let past_time_nanos = pocket_ic.get_time().await.as_nanos_since_unix_epoch();
     pocket_ic.advance_time(Duration::from_secs(86_400)).await;
     pocket_ic.tick().await;
+    let day = DayUtc::from_nanos(past_time_nanos);
 
     let request = GetNodeProviderRewardsCalculationRequest {
-        from_day_timestamp_nanos: past_time_nanos,
-        to_day_timestamp_nanos: past_time_nanos,
+        from_day: day,
+        to_day: day,
         provider_id: Principal::anonymous(),
     };
 
diff --git a/rs/node_rewards/rewards_calculation/BUILD.bazel b/rs/node_rewards/rewards_calculation/BUILD.bazel
index abe52d044d..93f535602e 100644
--- a/rs/node_rewards/rewards_calculation/BUILD.bazel
+++ b/rs/node_rewards/rewards_calculation/BUILD.bazel
@@ -6,6 +6,7 @@ DEPENDENCIES = [
     # Keep sorted.
     "//rs/protobuf",
     "//rs/types/base_types",
+    "//rs/types/types",
     "@crate_index//:candid",
     "@crate_index//:chrono_canisters",
     "@crate_index//:itertools",
diff --git a/rs/node_rewards/rewards_calculation/Cargo.toml b/rs/node_rewards/rewards_calculation/Cargo.toml
index d3de985e51..1fa3a2dc52 100644
--- a/rs/node_rewards/rewards_calculation/Cargo.toml
+++ b/rs/node_rewards/rewards_calculation/Cargo.toml
@@ -13,6 +13,7 @@ path = "src/lib.rs"
 ic-base-types = { path = "../../types/base_types" }
 itertools = { workspace = true }
 ic-protobuf = { path = "../../protobuf" }
+ic-types = { path = "../../types/types" }
 maplit = "1.0"
 rust_decimal = "1.37.1"
 rust_decimal_macros = "1.37.1"
diff --git a/rs/node_rewards/rewards_calculation/src/types.rs b/rs/node_rewards/rewards_calculation/src/types.rs
index 0eec8c16e3..ec99adce94 100644
--- a/rs/node_rewards/rewards_calculation/src/types.rs
+++ b/rs/node_rewards/rewards_calculation/src/types.rs
@@ -1,6 +1,7 @@
 use chrono::{DateTime, NaiveDateTime, ParseError, Utc};
 use ic_base_types::NodeId;
 use ic_protobuf::registry::node::v1::NodeRewardType;
+use ic_types::Time;
 use serde::{Deserialize, Serialize};
 use std::fmt;
 use std::fmt::Display;
@@ -13,13 +14,39 @@ const NANOS_PER_DAY: UnixTsNanos = 24 * 60 * 60 * 1_000_000_000;
 
 #[derive(Clone, Debug, PartialEq, Hash, PartialOrd, Ord, Eq, Copy, Deserialize, Serialize)]
 pub struct DayUtc {
-    value: UnixTsNanos,
+    last_ts_nanoseconds: u64,
+}
+
+impl DayUtc {
+    pub fn from_nanos(value: u64) -> Self {
+        let last_ts_nanoseconds = value
+            .checked_div(NANOS_PER_DAY)
+            .and_then(|v| v.checked_add(1))
+            .and_then(|v| v.checked_mul(NANOS_PER_DAY))
+            .and_then(|v| v.checked_sub(1))
+            .unwrap();
+
+        Self {
+            last_ts_nanoseconds,
+        }
+    }
+
+    pub fn from_secs(value: u64) -> Self {
+        let nanos = value * 1_000_000_000;
+        Self::from_nanos(nanos)
+    }
+}
+
+impl From<Time> for DayUtc {
+    fn from(value: Time) -> Self {
+        Self::from_nanos(value.as_nanos_since_unix_epoch())
+    }
 }
 
 impl Display for DayUtc {
     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
         let dd_mm_yyyy =
-            DateTime::from_timestamp_nanos(self.unix_ts_at_day_end_nanoseconds() as i64)
+            DateTime::from_timestamp_nanos(self.unix_timestamp_at_day_end_nanoseconds() as i64)
                 .naive_utc()
                 .format("%d-%m-%Y")
                 .to_string();
@@ -27,13 +54,6 @@ impl Display for DayUtc {
     }
 }
 
-impl From<UnixTsNanos> for DayUtc {
-    fn from(value: UnixTsNanos) -> Self {
-        let day_end = ((value / NANOS_PER_DAY) + 1) * NANOS_PER_DAY - 1;
-        Self { value: day_end }
-    }
-}
-
 impl TryFrom<&str> for DayUtc {
     type Error = ParseError;
 
@@ -43,43 +63,55 @@ impl TryFrom<&str> for DayUtc {
         let datetime: DateTime<Utc> = DateTime::from_naive_utc_and_offset(naive, Utc);
         let ts = datetime.timestamp_nanos_opt().unwrap() as u64;
 
-        Ok(DayUtc::from(ts))
+        Ok(DayUtc::from_nanos(ts))
     }
 }
 
 impl Default for DayUtc {
     fn default() -> Self {
-        DayUtc::from(0)
+        DayUtc::from_nanos(0)
     }
 }
 
 impl DayUtc {
-    pub fn unix_ts_at_day_end_nanoseconds(&self) -> UnixTsNanos {
-        self.value
+    pub fn unix_timestamp_at_day_end_nanoseconds(&self) -> u64 {
+        self.last_ts_nanoseconds
     }
 
-    pub fn get(&self) -> UnixTsNanos {
-        self.value
+    pub fn unix_timestamp_at_day_start_nanoseconds(&self) -> u64 {
+        let extra = self.last_ts_nanoseconds.checked_rem(NANOS_PER_DAY).unwrap();
+
+        self.last_ts_nanoseconds.saturating_sub(extra)
     }
 
-    pub fn unix_ts_at_day_start_nanoseconds(&self) -> UnixTsNanos {
-        (self.value / NANOS_PER_DAY) * NANOS_PER_DAY
+    pub fn unix_timestamp_at_day_end_seconds(&self) -> u64 {
+        self.unix_timestamp_at_day_end_nanoseconds()
+            .checked_div(1_000_000_000)
+            .unwrap()
     }
 
-    pub fn unix_ts_at_day_end_seconds(&self) -> u64 {
-        self.unix_ts_at_day_end_nanoseconds() / 1_000_000_000
+    pub fn unix_timestamp_at_day_start_seconds(&self) -> u64 {
+        self.unix_timestamp_at_day_start_nanoseconds()
+            .checked_div(1_000_000_000)
+            .expect("underflow detected in first_ts_secs")
     }
 
     pub fn next_day(&self) -> DayUtc {
         DayUtc {
-            value: self.value + NANOS_PER_DAY,
+            last_ts_nanoseconds: self
+                .last_ts_nanoseconds
+                .checked_add(NANOS_PER_DAY)
+                .expect("overflow detected in next_day"),
         }
     }
 
     pub fn previous_day(&self) -> DayUtc {
-        let ts_previous_day = self.value.checked_sub(NANOS_PER_DAY).unwrap_or_default();
+        let ts_previous_day = self
+            .last_ts_nanoseconds
+            .checked_sub(NANOS_PER_DAY)
+            .unwrap_or_default();
         DayUtc {
-            value: ts_previous_day,
+            last_ts_nanoseconds: ts_previous_day,
         }
     }
 
@@ -87,14 +119,14 @@ impl DayUtc {
         if self > other {
             return Err(format!(
                 "Cannot compute days_until: {} > {}",
-                self.value, other.value
+                self.last_ts_nanoseconds, other.last_ts_nanoseconds
             ));
         }
 
-        let num_days = (other.value - self.value) / NANOS_PER_DAY;
+        let num_days = (other.last_ts_nanoseconds - self.last_ts_nanoseconds) / NANOS_PER_DAY;
         let days_until = (0..=num_days)
             .map(|i| DayUtc {
-                value: self.value + i * NANOS_PER_DAY,
+                last_ts_nanoseconds: self.last_ts_nanoseconds + i * NANOS_PER_DAY,
             })
             .collect();
 
@@ -132,13 +164,14 @@ mod tests {
 
     #[test]
     fn test_valid_rewarding_period() {
-        let from_day: DayUtc = ymdh_to_ts(2020, 1, 12, 0).into();
-        let to_day = (ymdh_to_ts(2020, 1, 16, 0) - 1).into();
+        let from_day: DayUtc = DayUtc::from_nanos(ymdh_to_ts(2020, 1, 12, 0));
+        let to_day: DayUtc = DayUtc::from_nanos(ymdh_to_ts(2020, 1, 15, 0));
+
         let days = from_day.days_until(&to_day).unwrap().len();
 
         assert_eq!(days, 4);
 
-        let to_day = ymdh_to_ts(2020, 1, 12, 13).into();
+        let to_day = DayUtc::from_nanos(ymdh_to_ts(2020, 1, 12, 13));
         let days = from_day.days_until(&to_day).unwrap().len();
 
         assert_eq!(days, 1);
```

---

### Commit `2f56f172a1ea9dfac0c2fc6889454c38bb88ff57`

**Author:** Nikola Milosavljevic <73236646+NikolaMilosa@users.noreply.github.com>  
**Date:** 2025-09-24  
**Message:** chore: bump rust to 1.89 (#6758)

**Files Changed:**
- `rs/node_rewards/canister/src/lib.rs`
- `rs/node_rewards/canister/src/metrics.rs`
- `rs/node_rewards/canister/src/registry_querier.rs`

**Code Changes:**

```diff
commit 2f56f172a1ea9dfac0c2fc6889454c38bb88ff57
Author: Nikola Milosavljevic <73236646+NikolaMilosa@users.noreply.github.com>
Date:   Wed Sep 24 09:21:42 2025 +0200

    chore: bump rust to 1.89 (#6758)
    
    This PR bumps rust version to `1.89`. These changes were generated by:
    * automatic `cargo fix --workspace --all-targets --keep-going ...`
    * automatic `cargo clippy --fix ...` (It did fix some things that the
    above command missed)
    * Manually applied rustc
    [`mismatched_lifetime_syntax`](https://doc.rust-lang.org/beta/nightly-rustc/rustc_lint/lifetime_syntax/static.MISMATCHED_LIFETIME_SYNTAXES.html)
    fixes
    * Manually applied clippy
    [`cloned-ref-to-slice-refs`](https://rust-lang.github.io/rust-clippy/master/index.html#/cloned-ref-to-slice-refs)
    * Had to add some `#[allow(dead_code)]` because the `const` values used
    in `lazy_static!` weren't viewed as ever used. Left `//TODO:` to ask if
    some of the parts that aren't used are needed
    * Small manual patching of difference between
    ```bash
    bazel query 'kind("rust_library", //...) union kind("rust_binary", //...) union ("rust_test", //...)' > targets
    bazel build --config=lint --target_pattern_file=targets
    ```
    
    ---------
    
    Co-authored-by: IDX GitHub Automation <>
    Co-authored-by: Nicolas Mattia <nicolas.mattia@dfinity.org>

diff --git a/rs/node_rewards/canister/src/lib.rs b/rs/node_rewards/canister/src/lib.rs
index 20af202a31..504f62d8f6 100644
--- a/rs/node_rewards/canister/src/lib.rs
+++ b/rs/node_rewards/canister/src/lib.rs
@@ -55,7 +55,7 @@ impl KeyRange for pb::v1::SubnetMetricsKey {
 //------------ Storable Implementations ------------//
 
 impl Storable for pb::v1::SubnetIdKey {
-    fn to_bytes(&self) -> std::borrow::Cow<[u8]> {
+    fn to_bytes(&self) -> std::borrow::Cow<'_, [u8]> {
         Cow::Owned(self.encode_to_vec())
     }
 
@@ -70,7 +70,7 @@ impl Storable for pb::v1::SubnetIdKey {
 }
 
 impl Storable for pb::v1::SubnetMetricsKey {
-    fn to_bytes(&self) -> std::borrow::Cow<[u8]> {
+    fn to_bytes(&self) -> std::borrow::Cow<'_, [u8]> {
         Cow::Owned(self.encode_to_vec())
     }
 
@@ -85,7 +85,7 @@ impl Storable for pb::v1::SubnetMetricsKey {
 }
 
 impl Storable for pb::v1::SubnetMetricsValue {
-    fn to_bytes(&self) -> std::borrow::Cow<[u8]> {
+    fn to_bytes(&self) -> std::borrow::Cow<'_, [u8]> {
         Cow::Owned(self.encode_to_vec())
     }
 
@@ -97,7 +97,7 @@ impl Storable for pb::v1::SubnetMetricsValue {
 }
 
 impl Storable for pb::v1::NodeMetrics {
-    fn to_bytes(&self) -> std::borrow::Cow<[u8]> {
+    fn to_bytes(&self) -> std::borrow::Cow<'_, [u8]> {
         Cow::Owned(self.encode_to_vec())
     }
     fn from_bytes(bytes: std::borrow::Cow<[u8]>) -> Self {
diff --git a/rs/node_rewards/canister/src/metrics.rs b/rs/node_rewards/canister/src/metrics.rs
index 9df82f44dc..7e7941f079 100644
--- a/rs/node_rewards/canister/src/metrics.rs
+++ b/rs/node_rewards/canister/src/metrics.rs
@@ -206,26 +206,26 @@ where
             .collect();
 
         let mut initial_total_metrics: HashMap<_, _> = HashMap::new();
-        if let Some((timestamp_nanos, _)) = subnets_metrics_by_day.first_key_value() {
-            if timestamp_nanos < day_utc {
-                initial_total_metrics = subnets_metrics_by_day
-                    .pop_first()
-                    .unwrap()
-                    .1
-                    .into_iter()
-                    .flat_map(|(k, v)| {
-                        v.nodes_metrics.into_iter().map(move |node_metrics| {
+        if let Some((timestamp_nanos, _)) = subnets_metrics_by_day.first_key_value()
+            && timestamp_nanos < day_utc
+        {
+            initial_total_metrics = subnets_metrics_by_day
+                .pop_first()
+                .unwrap()
+                .1
+                .into_iter()
+                .flat_map(|(k, v)| {
+                    v.nodes_metrics.into_iter().map(move |node_metrics| {
+                        (
+                            (k.subnet_id, node_metrics.node_id),
                             (
-                                (k.subnet_id, node_metrics.node_id),
-                                (
-                                    node_metrics.num_blocks_proposed_total,
-                                    node_metrics.num_blocks_failed_total,
-                                ),
-                            )
-                        })
+                                node_metrics.num_blocks_proposed_total,
+                                node_metrics.num_blocks_failed_total,
+                            ),
+                        )
                     })
-                    .collect();
-            }
+                })
+                .collect();
         };
 
         for (_, subnets_metrics) in subnets_metrics_by_day {
diff --git a/rs/node_rewards/canister/src/registry_querier.rs b/rs/node_rewards/canister/src/registry_querier.rs
index cfaf3eb621..e983675bb9 100644
--- a/rs/node_rewards/canister/src/registry_querier.rs
+++ b/rs/node_rewards/canister/src/registry_querier.rs
@@ -107,10 +107,10 @@ impl RegistryQuerier {
                 ic_cdk::println!("Node {} has no NodeOperatorData: skipping", node_id);
                 continue;
             };
-            if let Some(provider_filter) = provider_filter {
-                if &node_provider_id != provider_filter {
-                    continue;
-                }
+            if let Some(provider_filter) = provider_filter
+                && &node_provider_id != provider_filter
+            {
+                continue;
             }
             let Some(some_reward_type) = node_record.node_reward_type else {
                 // If the node does not have a node_reward_type, we skip it.
```

---

### Commit `626ccf507254cc6b72ae126ae4d7f7ba22b52406`

**Author:** pietrodimarco-dfinity <124565147+pietrodimarco-dfinity@users.noreply.github.com>  
**Date:** 2025-09-16  
**Message:** chore(nns): Release notes (#6641)

**Files Changed:**
- `rs/node_rewards/canister/CHANGELOG.md`

**Code Changes:**

```diff
commit 626ccf507254cc6b72ae126ae4d7f7ba22b52406
Author: pietrodimarco-dfinity <124565147+pietrodimarco-dfinity@users.noreply.github.com>
Date:   Tue Sep 16 19:14:26 2025 +0200

    chore(nns): Release notes (#6641)
    
    Release notes for submitted proposals:
    
    https://dashboard.internetcomputer.org/proposal/138378
    
    Co-authored-by: max-dfinity <100170574+max-dfinity@users.noreply.github.com>

diff --git a/rs/node_rewards/canister/CHANGELOG.md b/rs/node_rewards/canister/CHANGELOG.md
index 0ec4c84f0d..fb9ef5a1ea 100644
--- a/rs/node_rewards/canister/CHANGELOG.md
+++ b/rs/node_rewards/canister/CHANGELOG.md
@@ -2,6 +2,15 @@
 
 INSERT NEW RELEASES HERE
 
+
+# 2025-09-06: Proposal 138378
+
+https://dashboard.internetcomputer.org/proposal/138378
+
+* Add Node Provider filtering on get_rewardable_nodes_per_provider to reduce number of instruction on query calls.
+* Discard historical rewards storage and API endpoints as historical rewards will be stored in Governance canister.
+* Disable replicated execution of query calls.
+
 # 2025-08-30: Proposal 138288
 
 http://dashboard.internetcomputer.org/proposal/138288
@@ -20,6 +29,7 @@ http://dashboard.internetcomputer.org/proposal/138288
 * Replicated execution of the query endpoints `get_node_provider_rewards_calculation` and `get_historical_reward_periods`
   is disabled.
 
+
 # 2025-08-15: Proposal 137910
 
 http://dashboard.internetcomputer.org/proposal/137910
```

---

### Commit `ed7dbb0a280cf0e25b712b651a05997d3ce24f92`

**Author:** pietrodimarco-dfinity <124565147+pietrodimarco-dfinity@users.noreply.github.com>  
**Date:** 2025-09-15  
**Message:** feat(NRC): Refactor NRC to compute daily rewards (#6730)

**Files Changed:**
- `rs/node_rewards/canister/api/src/provider_rewards_calculation.rs`
- `rs/node_rewards/canister/api/src/providers_rewards.rs`
- `rs/node_rewards/canister/node-rewards-canister.did`
- `rs/node_rewards/canister/src/api_conversion.rs`
- `rs/node_rewards/canister/src/canister/mod.rs`
- `rs/node_rewards/canister/src/canister/test/get_node_providers_rewards.rs`
- `rs/node_rewards/canister/src/lib.rs`
- `rs/node_rewards/canister/src/main.rs`
- `rs/node_rewards/canister/src/metrics.rs`
- `rs/node_rewards/canister/src/metrics/tests.rs`
- `rs/node_rewards/canister/src/registry_querier.rs`
- `rs/node_rewards/canister/src/registry_querier/tests.rs`
- `rs/node_rewards/canister/tests/get_node_providers_monthly_xdr_rewards.rs`
- `rs/node_rewards/rewards_calculation/BUILD.bazel`
- `rs/node_rewards/rewards_calculation/Cargo.toml`
- `rs/node_rewards/rewards_calculation/src/lib.rs`
- `rs/node_rewards/rewards_calculation/src/performance_based_algorithm/mod.rs`
- `rs/node_rewards/rewards_calculation/src/performance_based_algorithm/results.rs`
- `rs/node_rewards/rewards_calculation/src/performance_based_algorithm/test_utils.rs`
- `rs/node_rewards/rewards_calculation/src/performance_based_algorithm/v1.rs`
- `rs/node_rewards/rewards_calculation/src/rewards_calculator/mod.rs`
- `rs/node_rewards/rewards_calculation/src/rewards_calculator/test_utils.rs`
- `rs/node_rewards/rewards_calculation/src/rewards_calculator/tests.rs`
- `rs/node_rewards/rewards_calculation/src/rewards_calculator_results.rs`
- `rs/node_rewards/rewards_calculation/src/types.rs`

**Code Changes:**

```diff
commit ed7dbb0a280cf0e25b712b651a05997d3ce24f92
Author: pietrodimarco-dfinity <124565147+pietrodimarco-dfinity@users.noreply.github.com>
Date:   Mon Sep 15 18:06:16 2025 +0200

    feat(NRC): Refactor NRC to compute daily rewards (#6730)
    
    Changes:
    
    - Replace legacy days range rewards calculation with daily rewards
    calculation
    - Adapt` metrics.rs` to extract daily metrics
    - Implement
    `rewards_calculation::performance_based_algorithm::DataProvider` trait
    - Adapt API for new daily calculation
    - Adapt `registry_querier.rs` to fetch daily rewardable nodes

diff --git a/rs/node_rewards/canister/api/src/provider_rewards_calculation.rs b/rs/node_rewards/canister/api/src/provider_rewards_calculation.rs
index 3d674857e3..96d677460b 100644
--- a/rs/node_rewards/canister/api/src/provider_rewards_calculation.rs
+++ b/rs/node_rewards/canister/api/src/provider_rewards_calculation.rs
@@ -1,12 +1,15 @@
 use candid::{CandidType, Deserialize, Principal};
+use ic_base_types::PrincipalId;
+use ic_nervous_system_proto::pb::v1::Decimal;
+
 #[derive(CandidType, Clone, Deserialize)]
 pub struct GetNodeProviderRewardsCalculationRequest {
-    pub from_nanos: u64,
-    pub to_nanos: u64,
+    pub from_day_timestamp_nanos: u64,
+    pub to_day_timestamp_nanos: u64,
     pub provider_id: Principal,
 }
 
-pub type GetNodeProviderRewardsCalculationResponse = Result<NodeProviderRewards, String>;
+pub type GetNodeProviderRewardsCalculationResponse = Result<Vec<NodeProviderRewardsDaily>, String>;
 
 #[derive(
     PartialOrd, Ord, Eq, candid::CandidType, candid::Deserialize, Clone, Copy, PartialEq, Debug,
@@ -17,79 +20,59 @@ pub struct DayUtc {
 
 #[derive(candid::CandidType, candid::Deserialize, Clone, PartialEq, Debug)]
 pub struct NodeMetricsDaily {
-    pub subnet_assigned: Option<::ic_base_types::PrincipalId>,
-    pub subnet_assigned_fr_percent: Option<::ic_nervous_system_proto::pb::v1::Decimal>,
+    pub subnet_assigned: Option<PrincipalId>,
+    pub subnet_assigned_fr_percent: Option<Decimal>,
     pub num_blocks_proposed: Option<u64>,
     pub num_blocks_failed: Option<u64>,
-    pub original_fr_percent: Option<::ic_nervous_system_proto::pb::v1::Decimal>,
-    pub relative_fr_percent: Option<::ic_nervous_system_proto::pb::v1::Decimal>,
-}
-
-#[derive(candid::CandidType, candid::Deserialize, Clone, PartialEq, Debug)]
-pub struct Assigned {
-    pub node_metrics: Option<NodeMetricsDaily>,
+    pub original_fr_percent: Option<Decimal>,
+    pub relative_fr_percent: Option<Decimal>,
 }
-
 #[derive(candid::CandidType, candid::Deserialize, Clone, PartialEq, Debug)]
-pub struct Unassigned {
-    pub extrapolated_fr_percent: Option<::ic_nervous_system_proto::pb::v1::Decimal>,
+pub enum NodeStatus {
+    Assigned {
+        node_metrics: Option<NodeMetricsDaily>,
+    },
+    Unassigned {
+        extrapolated_fr_percent: Option<Decimal>,
+    },
 }
-
-#[derive(candid::CandidType, candid::Deserialize, Clone, PartialEq, Debug)]
-pub struct NodeStatus {
-    pub status: Option<node_status::Status>,
-}
-
-/// Nested message and enum types in `NodeStatus`.
-pub mod node_status {
-    #[derive(candid::CandidType, candid::Deserialize, Clone, PartialEq, Debug)]
-    pub enum Status {
-        Assigned(super::Assigned),
-        Unassigned(super::Unassigned),
-    }
-}
-
-#[derive(candid::CandidType, candid::Deserialize, Clone, PartialEq, Debug)]
-pub struct DailyResults {
-    pub day: Option<DayUtc>,
-    pub node_status: Option<NodeStatus>,
-    pub performance_multiplier_percent: Option<::ic_nervous_system_proto::pb::v1::Decimal>,
-    pub rewards_reduction_percent: Option<::ic_nervous_system_proto::pb::v1::Decimal>,
-    pub base_rewards_xdr_permyriad: Option<::ic_nervous_system_proto::pb::v1::Decimal>,
-    pub adjusted_rewards_xdr_permyriad: Option<::ic_nervous_system_proto::pb::v1::Decimal>,
-}
-
 #[derive(candid::CandidType, candid::Deserialize, Clone, PartialEq, Debug)]
 pub struct NodeResults {
-    pub node_id: Option<::ic_base_types::PrincipalId>,
+    pub node_id: Option<PrincipalId>,
     pub node_reward_type: Option<String>,
     pub region: Option<String>,
     pub dc_id: Option<String>,
-    pub daily_results: Vec<DailyResults>,
+    pub node_status: Option<NodeStatus>,
+    pub performance_multiplier_percent: Option<Decimal>,
+    pub rewards_reduction_percent: Option<Decimal>,
+    pub base_rewards_xdr_permyriad: Option<Decimal>,
+    pub adjusted_rewards_xdr_permyriad: Option<Decimal>,
 }
-
 #[derive(candid::CandidType, candid::Deserialize, Clone, PartialEq, Debug)]
 pub struct BaseRewards {
-    pub monthly_xdr_permyriad: Option<::ic_nervous_system_proto::pb::v1::Decimal>,
-    pub daily_xdr_permyriad: Option<::ic_nervous_system_proto::pb::v1::Decimal>,
+    pub monthly_xdr_permyriad: Option<Decimal>,
+    pub daily_xdr_permyriad: Option<Decimal>,
     pub node_reward_type: Option<String>,
     pub region: Option<String>,
 }
-
 #[derive(candid::CandidType, candid::Deserialize, Clone, PartialEq, Debug)]
-pub struct DailyBaseRewardsType3 {
-    pub day: Option<DayUtc>,
+pub struct BaseRewardsType3 {
     pub region: Option<String>,
     pub nodes_count: Option<u64>,
-    pub avg_rewards_xdr_permyriad: Option<::ic_nervous_system_proto::pb::v1::Decimal>,
-    pub avg_coefficient_percent: Option<::ic_nervous_system_proto::pb::v1::Decimal>,
-    pub value_xdr_permyriad: Option<::ic_nervous_system_proto::pb::v1::Decimal>,
+    pub avg_rewards_xdr_permyriad: Option<Decimal>,
+    pub avg_coefficient_percent: Option<Decimal>,
+    pub value_xdr_permyriad: Option<Decimal>,
 }
-
 #[derive(candid::CandidType, candid::Deserialize, Clone, PartialEq, Debug)]
 pub struct NodeProviderRewards {
-    pub rewards_total_xdr_permyriad: Option<u64>,
+    pub rewards_total_xdr_permyriad: Option<Decimal>,
     pub base_rewards: Vec<BaseRewards>,
-    pub base_rewards_type3: Vec<DailyBaseRewardsType3>,
+    pub base_rewards_type3: Vec<BaseRewardsType3>,
     pub nodes_results: Vec<NodeResults>,
 }
+
+#[derive(CandidType, candid::Deserialize, Clone, Debug)]
+pub struct NodeProviderRewardsDaily {
+    pub day_utc: Option<DayUtc>,
+    pub node_provider_rewards: Option<NodeProviderRewards>,
+}
diff --git a/rs/node_rewards/canister/api/src/providers_rewards.rs b/rs/node_rewards/canister/api/src/providers_rewards.rs
index 14e7d28469..20f39b035f 100644
--- a/rs/node_rewards/canister/api/src/providers_rewards.rs
+++ b/rs/node_rewards/canister/api/src/providers_rewards.rs
@@ -3,8 +3,8 @@ use std::collections::BTreeMap;
 
 #[derive(CandidType, Clone, Deserialize)]
 pub struct GetNodeProvidersRewardsRequest {
-    pub from_nanos: u64,
-    pub to_nanos: u64,
+    pub from_day_timestamp_nanos: u64,
+    pub to_day_timestamp_nanos: u64,
 }
 pub type GetNodeProvidersRewardsResponse = Result<NodeProvidersRewards, String>;
 
diff --git a/rs/node_rewards/canister/node-rewards-canister.did b/rs/node_rewards/canister/node-rewards-canister.did
index c3c33e4f06..c79541bd5c 100644
--- a/rs/node_rewards/canister/node-rewards-canister.did
+++ b/rs/node_rewards/canister/node-rewards-canister.did
@@ -1,33 +1,13 @@
-type GetNodeProvidersMonthlyXdrRewardsRequest = record {
-    registry_version: opt nat64;
-};
-
-type GetNodeProvidersMonthlyXdrRewardsResponse = record {
-    rewards : opt NodeProvidersMonthlyXdrRewards;
-    error: opt text;
-};
-
-type NodeProvidersMonthlyXdrRewards = record {
-    rewards: vec record { principal; nat64 };
-    registry_version: opt nat64;
-};
-
-type GetNodeProvidersRewardsRequest = record {
-  from_nanos: nat64;
-  to_nanos: nat64;
-};
-
-type NodeProvidersRewards = record {
-  rewards_xdr_permyriad: vec record {
-    principal;
-    nat64;
-  };
-};
+// get_node_provider_rewards_calculation
 
 type Decimal = record {
   human_readable: opt text;
 };
 
+type DayUtc = record {
+  value: opt nat64;
+};
+
 type NodeMetricsDaily = record {
   subnet_assigned: opt principal;
   subnet_assigned_fr_percent: opt Decimal;
@@ -37,34 +17,9 @@ type NodeMetricsDaily = record {
   relative_fr_percent: opt Decimal;
 };
 
-type Assigned = record {
-  node_metrics: opt NodeMetricsDaily;
-};
-
-type Unassigned = record {
-  extrapolated_fr_percent: opt Decimal;
-};
-
-type Status = variant {
-  Assigned: Assigned;
-  Unassigned: Unassigned;
-};
-
-type NodeStatus = record {
-  status: opt Status;
-};
-
-type DayUtc = record {
-  value: opt nat64;
-};
-
-type DailyResults = record {
-  day: opt DayUtc;
-  node_status: opt NodeStatus;
-  performance_multiplier_percent: opt Decimal;
-  rewards_reduction_percent: opt Decimal;
-  base_rewards_xdr_permyriad: opt Decimal;
-  adjusted_rewards_xdr_permyriad: opt Decimal;
+type NodeStatus = variant {
+  Assigned: record { node_metrics: opt NodeMetricsDaily };
+  Unassigned: record { extrapolated_fr_percent: opt Decimal };
 };
 
 type NodeResults = record {
@@ -72,7 +27,11 @@ type NodeResults = record {
   node_reward_type: opt text;
   region: opt text;
   dc_id: opt text;
-  daily_results: vec DailyResults;
+  node_status: opt NodeStatus;
+  performance_multiplier_percent: opt Decimal;
+  rewards_reduction_percent: opt Decimal;
+  base_rewards_xdr_permyriad: opt Decimal;
+  adjusted_rewards_xdr_permyriad: opt Decimal;
 };
 
 type BaseRewards = record {
@@ -82,8 +41,7 @@ type BaseRewards = record {
   region: opt text;
 };
 
-type DailyBaseRewardsType3 = record {
-  day: opt DayUtc;
+type BaseRewardsType3 = record {
   region: opt text;
   nodes_count: opt nat64;
   avg_rewards_xdr_permyriad: opt Decimal;
@@ -92,26 +50,62 @@ type DailyBaseRewardsType3 = record {
 };
 
 type NodeProviderRewards = record {
-  rewards_total_xdr_permyriad: opt nat64;
+  rewards_total_xdr_permyriad: opt Decimal;
   base_rewards: vec BaseRewards;
-  base_rewards_type3: vec DailyBaseRewardsType3;
+  base_rewards_type3: vec BaseRewardsType3;
   nodes_results: vec NodeResults;
 };
 
+type NodeProviderRewardsDaily = record {
+    day_utc: opt DayUtc;
+    node_provider_rewards: opt NodeProviderRewards;
+};
+
+type GetNodeProviderRewardsCalculationResponse = variant { Ok: vec NodeProviderRewardsDaily; Err: text };
+
 type GetNodeProviderRewardsCalculationRequest = record {
-  from_nanos: nat64;
-  to_nanos: nat64;
+  from_day_timestamp_nanos: nat64;
+  to_day_timestamp_nanos: nat64;
   provider_id: principal;
 };
 
-type GetNodeProvidersRewardsResponse = variant { Ok : NodeProvidersRewards; Err : text };
+// get_node_providers_rewards
+
+type NodeProvidersRewards = record {
+  rewards_xdr_permyriad: vec record {
+    principal;
+    nat64;
+  };
+};
+
+type GetNodeProvidersRewardsRequest = record {
+  from_day_timestamp_nanos: nat64;
+  to_day_timestamp_nanos: nat64;
+};
+
+type GetNodeProvidersRewardsResponse = variant { Ok: NodeProvidersRewards; Err: text };
 
-type GetNodeProviderRewardsCalculationResponse = variant { Ok : NodeProviderRewards; Err : text };
 
-service : () -> {
+// get_node_providers_monthly_xdr_rewards
+
+type GetNodeProvidersMonthlyXdrRewardsRequest = record {
+    registry_version: opt nat64;
+};
+
+type GetNodeProvidersMonthlyXdrRewardsResponse = record {
+    rewards: opt NodeProvidersMonthlyXdrRewards;
+    error: opt text;
+};
+
+type NodeProvidersMonthlyXdrRewards = record {
+    rewards: vec record { principal; nat64 };
+    registry_version: opt nat64;
+};
+
+service: () -> {
     get_node_providers_monthly_xdr_rewards: (GetNodeProvidersMonthlyXdrRewardsRequest) -> (
         GetNodeProvidersMonthlyXdrRewardsResponse
     );
     get_node_providers_rewards: (GetNodeProvidersRewardsRequest) -> (GetNodeProvidersRewardsResponse);
-    get_node_provider_rewards_calculation : (GetNodeProviderRewardsCalculationRequest) -> (GetNodeProviderRewardsCalculationResponse) query;
+    get_node_provider_rewards_calculation: (GetNodeProviderRewardsCalculationRequest) -> (GetNodeProviderRewardsCalculationResponse) query;
 }
diff --git a/rs/node_rewards/canister/src/api_conversion.rs b/rs/node_rewards/canister/src/api_conversion.rs
index a8c9ec8725..98ce409b69 100644
--- a/rs/node_rewards/canister/src/api_conversion.rs
+++ b/rs/node_rewards/canister/src/api_conversion.rs
@@ -1,83 +1,98 @@
+use ic_base_types::PrincipalId;
 use ic_node_rewards_canister_api::provider_rewards_calculation::{
-    Assigned as AssignedCandid, BaseRewards as BaseRewardsCandid,
-    DailyBaseRewardsType3 as DailyBaseRewardsType3Candid, DailyResults as DailyResultsCandid,
-    DayUtc as DayUtcCandid, NodeMetricsDaily as NodeMetricsDailyCandid,
-    NodeProviderRewards as NodeProviderRewardsCandid, NodeResults as NodeResultsCandid,
-    NodeStatus as NodeStatusCandid, Unassigned as UnassignedCandid,
-    node_status::Status as StatusCandid,
+    BaseRewards as BaseRewardsCandid, BaseRewardsType3 as BaseRewardsType3Candid, DayUtc,
+    GetNodeProviderRewardsCalculationResponse, NodeMetricsDaily as NodeMetricsDailyCandid,
+    NodeProviderRewards as NodeProviderRewardsCandid, NodeProviderRewardsDaily,
+    NodeResults as NodeResultsCandid, NodeStatus as NodeStatusCandid,
 };
-use rewards_calculation::rewards_calculator_results::{NodeProviderRewards, NodeStatus};
+use rewards_calculation::performance_based_algorithm::results::{
+    NodeStatus, RewardsCalculatorResults,
+};
+
+pub fn into_rewards_calculation_results(
+    results: RewardsCalculatorResults,
+    provider_id: PrincipalId,
+) -> GetNodeProviderRewardsCalculationResponse {
+    let mut daily_rewards: Vec<NodeProviderRewardsDaily> = Vec::new();
+
+    for (day, mut daily_results) in results.daily_results {
+        let daily_provider_results = daily_results
+            .provider_results
+            .remove(&provider_id)
+            .ok_or(format!("No results found for provider_id: {}", provider_id))?;
 
-pub fn to_candid_type(rewards: NodeProviderRewards) -> NodeProviderRewardsCandid {
-    NodeProviderRewardsCandid {
-        rewards_total_xdr_permyriad: Some(rewards.rewards_total_xdr_permyriad),
-        base_rewards: rewards
+        let nodes_results = daily_provider_results
+            .nodes_results
+            .iter()
+            .map(|nr| NodeResultsCandid {
+                node_id: Some(nr.node_id.get()),
+                node_reward_type: Some(nr.node_reward_type.to_string()),
+                region: Some(nr.region.clone()),
+                dc_id: Some(nr.dc_id.clone()),
+                node_status: match &nr.node_status {
+                    NodeStatus::Assigned { node_metrics } => Some(NodeStatusCandid::Assigned {
+                        node_metrics: Some(NodeMetricsDailyCandid {
+                            subnet_assigned: Some(node_metrics.subnet_assigned.get()),
+                            subnet_assigned_fr_percent: Some(
+                                node_metrics.subnet_assigned_fr.into(),
+                            ),
+                            num_blocks_proposed: Some(node_metrics.num_blocks_proposed),
+                            num_blocks_failed: Some(node_metrics.num_blocks_failed),
+                            original_fr_percent: Some(node_metrics.original_fr.into()),
+                            relative_fr_percent: Some(node_metrics.relative_fr.into()),
+                        }),
+                    }),
+                    NodeStatus::Unassigned { extrapolated_fr } => {
+                        Some(NodeStatusCandid::Unassigned {
+                            extrapolated_fr_percent: Some((*extrapolated_fr).into()),
+                        })
+                    }
+                },
+                performance_multiplier_percent: Some(nr.performance_multiplier.into()),
+                rewards_reduction_percent: Some(nr.rewards_reduction.into()),
+                base_rewards_xdr_permyriad: Some(nr.base_rewards.into()),
+                adjusted_rewards_xdr_permyriad: Some(nr.adjusted_rewards.into()),
+            })
+            .collect();
+
+        // Map BaseRewards
+        let base_rewards = daily_provider_results
             .base_rewards
-            .into_iter()
+            .iter()
             .map(|br| BaseRewardsCandid {
-                node_reward_type: Some(br.node_reward_type.to_string()),
-                region: Some(br.region),
                 monthly_xdr_permyriad: Some(br.monthly.into()),
                 daily_xdr_permyriad: Some(br.daily.into()),
+                node_reward_type: Some(br.node_reward_type.to_string()),
+                region: Some(br.region.clone()),
             })
-            .collect(),
-        base_rewards_type3: rewards
+            .collect();
+
+        // Map BaseRewardsType3
+        let base_rewards_type3 = daily_provider_results
             .base_rewards_type3
-            .into_iter()
-            .map(|br3| DailyBaseRewardsType3Candid {
-                day: Some(DayUtcCandid {
-                    value: Some(br3.day.unix_ts_at_day_end()),
-                }),
-                region: Some(br3.region),
+            .iter()
+            .map(|br3| BaseRewardsType3Candid {
+                region: Some(br3.region.clone()),
                 nodes_count: Some(br3.nodes_count as u64),
                 avg_rewards_xdr_permyriad: Some(br3.avg_rewards.into()),
                 avg_coefficient_percent: Some(br3.avg_coefficient.into()),
                 value_xdr_permyriad: Some(br3.value.into()),
             })
-            .collect(),
-        nodes_results: rewards
-            .nodes_results
-            .into_iter()
-            .map(|nr| NodeResultsCandid {
-                node_id: Some(nr.node_id.get()),
-                node_reward_type: Some(nr.node_reward_type.to_string()),
-                region: Some(nr.region),
-                dc_id: Some(nr.dc_id),
-                daily_results: nr
-                    .daily_results
-                    .into_iter()
-                    .map(|dr| DailyResultsCandid {
-                        day: Some(DayUtcCandid {
-                            value: Some(dr.day.unix_ts_at_day_end()),
-                        }),
-                        node_status: match dr.node_status {
-                            NodeStatus::Assigned { node_metrics } => Some(NodeStatusCandid {
-                                status: Some(StatusCandid::Assigned(AssignedCandid {
-                                    node_metrics: Some(NodeMetricsDailyCandid {
-                                        subnet_assigned: Some(node_metrics.subnet_assigned.get()),
-                                        subnet_assigned_fr_percent: Some(
-                                            node_metrics.subnet_assigned_fr.into(),
-                                        ),
-                                        num_blocks_proposed: Some(node_metrics.num_blocks_proposed),
-                                        num_blocks_failed: Some(node_metrics.num_blocks_failed),
-                                        original_fr_percent: Some(node_metrics.original_fr.into()),
-                                        relative_fr_percent: Some(node_metrics.relative_fr.into()),
-                                    }),
-                                })),
-                            }),
-                            NodeStatus::Unassigned { extrapolated_fr } => Some(NodeStatusCandid {
-                                status: Some(StatusCandid::Unassigned(UnassignedCandid {
-                                    extrapolated_fr_percent: Some(extrapolated_fr.into()),
-                                })),
-                            }),
-                        },
-                        performance_multiplier_percent: Some(dr.performance_multiplier.into()),
-                        rewards_reduction_percent: Some(dr.rewards_reduction.into()),
-                        base_rewards_xdr_permyriad: Some(dr.base_rewards.into()),
-                        adjusted_rewards_xdr_permyriad: Some(dr.adjusted_rewards.into()),
-                    })
-                    .collect(),
-            })
-            .collect(),
+            .collect();
+
+        let node_provider_rewards = NodeProviderRewardsCandid {
+            rewards_total_xdr_permyriad: Some(daily_provider_results.rewards_total.into()),
+            base_rewards,
+            base_rewards_type3,
+            nodes_results,
+        };
+
+        daily_rewards.push(NodeProviderRewardsDaily {
+            day_utc: Some(DayUtc {
+                value: Some(day.unix_ts_at_day_end_nanoseconds()),
+            }),
+            node_provider_rewards: Some(node_provider_rewards),
+        });
     }
+    Ok(daily_rewards)
 }
diff --git a/rs/node_rewards/canister/src/canister/mod.rs b/rs/node_rewards/canister/src/canister/mod.rs
index 62e969f73b..20eef68823 100644
--- a/rs/node_rewards/canister/src/canister/mod.rs
+++ b/rs/node_rewards/canister/src/canister/mod.rs
@@ -1,4 +1,4 @@
-use crate::api_conversion::to_candid_type;
+use crate::api_conversion::into_rewards_calculation_results;
 use crate::metrics::MetricsManager;
 use crate::registry_querier::RegistryQuerier;
 use crate::storage::VM;
@@ -17,19 +17,17 @@ use ic_node_rewards_canister_api::providers_rewards::{
 use ic_protobuf::registry::dc::v1::DataCenterRecord;
 use ic_protobuf::registry::node_operator::v1::NodeOperatorRecord;
 use ic_protobuf::registry::node_rewards::v2::NodeRewardsTable;
-use ic_registry_canister_client::{
-    CanisterRegistryClient, RegistryDataStableMemory, get_decoded_value,
-};
+use ic_registry_canister_client::{CanisterRegistryClient, get_decoded_value};
 use ic_registry_keys::{
     DATA_CENTER_KEY_PREFIX, NODE_OPERATOR_RECORD_KEY_PREFIX, NODE_REWARDS_TABLE_KEY,
 };
 use ic_registry_node_provider_rewards::{RewardsPerNodeProvider, calculate_rewards_v0};
-use ic_types::RegistryVersion;
-use rewards_calculation::rewards_calculator::RewardsCalculatorInput;
-use rewards_calculation::rewards_calculator_results::RewardsCalculatorResults;
-use rewards_calculation::types::RewardPeriod;
+use ic_types::{RegistryVersion, Time};
+use rewards_calculation::performance_based_algorithm::results::RewardsCalculatorResults;
+use rewards_calculation::performance_based_algorithm::v1::RewardsCalculationV1;
+use rewards_calculation::types::{DayUtc, NodeMetricsDailyRaw, RewardableNode};
 use std::cell::RefCell;
-use std::collections::HashSet;
+use std::collections::{BTreeMap, HashSet};
 use std::rc::Rc;
 use std::sync::Arc;
 use std::thread::LocalKey;
@@ -37,6 +35,17 @@ use std::thread::LocalKey;
 #[cfg(test)]
 mod test;
 
+#[cfg(target_arch = "wasm32")]
+fn current_time() -> Time {
+    let current_time = ic_cdk::api::time();
+    Time::from_nanos_since_unix_epoch(current_time)
+}
+
+#[cfg(not(any(target_arch = "wasm32")))]
+fn current_time() -> Time {
+    ic_types::time::current_time()
+}
+
 /// This struct represents the API for the canister.  API methods should be implemented in
 /// main.rs and defer the important work to the methods in this struct, essentially passing
 /// through arguments and responses with almost no logic.
@@ -73,7 +82,7 @@ impl NodeRewardsCanister {
     pub fn get_registry_value(&self, key: String) -> Result<Option<Vec<u8>>, String> {
         self.registry_client
             .get_value(key.as_ref(), self.registry_client.get_latest_version())
-            .map_err(|e| format!("Failed to get registry value: {e:?}"))
+            .map_err(|e| format!("Failed to get registry value: {:?}", e))
     }
 
     pub async fn schedule_registry_sync(
@@ -118,39 +127,76 @@ impl NodeRewardsCanister {
         });
     }
 
-    fn calculate_rewards<S: RegistryDataStableMemory>(
+    fn validate_reward_period(from_day: &DayUtc, to_day: &DayUtc) -> Result<(), String> {
+        let today: DayUtc = current_time().as_nanos_since_unix_epoch().into();
+        if from_day > to_day {
+            return Err("from_day must be before to_day".to_string());
+        }
+        if to_day >= &today {
+            return Err("to_day_timestamp_nanos must be earlier than today".to_string());
+        }
+        Ok(())
+    }
+
+    fn calculate_rewards(
         &self,
         request: GetNodeProvidersRewardsRequest,
         provider_filter: Option<PrincipalId>,
     ) -> Result<RewardsCalculatorResults, String> {
-        let reward_period = RewardPeriod::new(request.from_nanos.into(), request.to_nanos.into())
-            .map_err(|e| e.to_string())?;
+        let start_day = DayUtc::from(request.from_day_timestamp_nanos);
+        let end_day = DayUtc::from(request.to_day_timestamp_nanos);
+        Self::validate_reward_period(&start_day, &end_day)?;
+
+        RewardsCalculationV1::calculate_rewards(&start_day, &end_day, provider_filter, self)
+            .map_err(|e| format!("Could not calculate rewards: {e:?}"))
+    }
+}
+
+impl rewards_calculation::performance_based_algorithm::DataProvider for &NodeRewardsCanister {
+    fn get_rewards_table(&self, day: &DayUtc) -> Result<NodeRewardsTable, String> {
         let registry_querier = RegistryQuerier::new(self.registry_client.clone());
 
         let version = registry_querier
-            .version_for_timestamp(reward_period.from.unix_ts_at_day_end())
+            .version_for_timestamp(day.unix_ts_at_day_end_nanoseconds())
             .ok_or_else(|| "Could not find registry version for timestamp".to_string())?;
-        let rewards_table = registry_querier.get_rewards_table(version);
-        let daily_metrics_by_subnet = self
-            .metrics_manager
-            .daily_metrics_by_subnet(reward_period.from, reward_period.to);
-        let provider_rewardable_nodes = RegistryQuerier::get_rewardable_nodes_per_provider::<S>(
-            &*self.registry_client,
-            reward_period.from,
-            reward_period.to,
-            provider_filter,
-        )
-        .map_err(|e| format!("Could not get rewardable nodes: {e:?}"))?;
-
-        let input = RewardsCalculatorInput {
-            reward_period,
-            rewards_table,
-            daily_metrics_by_subnet,
-            provider_rewardable_nodes,
-        };
+        Ok(registry_querier.get_rewards_table(version))
+    }
 
-        rewards_calculation::rewards_calculator::calculate_rewards(input)
-            .map_err(|e| format!("Could not calculate rewards: {e:?}"))
+    fn get_daily_metrics_by_subnet(
+        &self,
+        day: &DayUtc,
+    ) -> Result<BTreeMap<SubnetId, Vec<NodeMetricsDailyRaw>>, String> {
+        let metrics = self.metrics_manager.metrics_by_subnet(day);
+        if metrics.is_empty() {
+            return Err(format!("No metrics found for day {}", day.get()));
+        }
+        Ok(metrics)
+    }
+
+    fn get_rewardable_nodes(
+        &self,
+        day: &DayUtc,
+    ) -> Result<BTreeMap<PrincipalId, Vec<RewardableNode>>, String> {
+        let registry_client = self.get_registry_client();
+        let registry_querier = RegistryQuerier::new(registry_client.clone());
+        registry_querier
+            .get_rewardable_nodes_per_provider(day, None)
+            .map_err(|e| format!("Could not get rewardable nodes: {e:?}"))
+    }
+
+    fn get_provider_rewardable_nodes(
+        &self,
+        day: &DayUtc,
+        provider_id: &PrincipalId,
+    ) -> Result<Vec<RewardableNode>, String> {
+        let mut all_rewardable_nodes = self.get_rewardable_nodes(day)?;
+        let rewardable_nodes = all_rewardable_nodes.remove(provider_id).ok_or_else(|| {
+            format!(
+                "No rewardable nodes found for provider {} for day {}",
+                provider_id, day
+            )
+        })?;
+        Ok(rewardable_nodes)
     }
 }
 
@@ -188,7 +234,8 @@ impl NodeRewardsCanister {
             registry_client.sync_registry_stored().await.map_err(|e| {
                 format!(
                     "Could not sync registry store to latest version, \
-                    please try again later: {e:?}"
+                    please try again later: {:?}",
+                    e
                 )
             })?;
 
@@ -224,7 +271,7 @@ impl NodeRewardsCanister {
         }
     }
 
-    pub async fn get_node_providers_rewards<S: RegistryDataStableMemory>(
+    pub async fn get_node_providers_rewards(
         canister: &'static LocalKey<RefCell<NodeRewardsCanister>>,
         request: GetNodeProvidersRewardsRequest,
     ) -> GetNodeProvidersRewardsResponse {
@@ -233,18 +280,17 @@ impl NodeRewardsCanister {
             .map_err(|e| {
                 format!(
                     "Could not sync registry store to latest version, \
-                    please try again later: {e:?}"
+                    please try again later: {:?}",
+                    e
                 )
             })?;
         NodeRewardsCanister::schedule_metrics_sync(canister).await;
-        let result =
-            canister.with_borrow(|canister| canister.calculate_rewards::<S>(request, None))?;
+        let result = canister.with_borrow(|canister| canister.calculate_rewards(request, None))?;
+
         let rewards_xdr_permyriad = result
-            .provider_results
-            .iter()
-            .map(|(provider_id, provider_rewards)| {
-                (provider_id.0, provider_rewards.rewards_total_xdr_permyriad)
-            })
+            .total_rewards_xdr_permyriad
+            .into_iter()
+            .map(|(k, v)| (k.0, v))
             .collect();
 
         Ok(NodeProvidersRewards {
@@ -252,24 +298,18 @@ impl NodeRewardsCanister {
         })
     }
 
-    pub fn get_node_provider_rewards_calculation<S: RegistryDataStableMemory>(
+    pub fn get_node_provider_rewards_calculation(
         canister: &'static LocalKey<RefCell<NodeRewardsCanister>>,
         request: GetNodeProviderRewardsCalculationRequest,
     ) -> GetNodeProviderRewardsCalculationResponse {
         let provider_id = PrincipalId::from(request.provider_id);
         let request_inner = GetNodeProvidersRewardsRequest {
-            from_nanos: request.from_nanos,
-            to_nanos: request.to_nanos,
+            from_day_timestamp_nanos: request.from_day_timestamp_nanos,
+            to_day_timestamp_nanos: request.to_day_timestamp_nanos,
         };
-        let mut result = canister.with_borrow(|canister| {
-            canister.calculate_rewards::<S>(request_inner, Some(provider_id))
-        })?;
-        let node_provider_rewards = result
-            .provider_results
-            .remove(&provider_id)
-            .ok_or(format!("No rewards found for node provider {provider_id}"))?;
-
-        Ok(to_candid_type(node_provider_rewards))
+        let result = canister
+            .with_borrow(|canister| canister.calculate_rewards(request_inner, Some(provider_id)))?;
+        into_rewards_calculation_results(result, provider_id)
     }
 }
 
diff --git a/rs/node_rewards/canister/src/canister/test/get_node_providers_rewards.rs b/rs/node_rewards/canister/src/canister/test/get_node_providers_rewards.rs
index 041b326ddb..9171eb4ec7 100644
--- a/rs/node_rewards/canister/src/canister/test/get_node_providers_rewards.rs
+++ b/rs/node_rewards/canister/src/canister/test/get_node_providers_rewards.rs
@@ -1,13 +1,9 @@
-use crate::api_conversion::to_candid_type;
 use crate::canister::NodeRewardsCanister;
-use crate::canister::test::test_utils::{
-    CANISTER_TEST, TestState, VM, setup_thread_local_canister_for_test,
-};
+use crate::canister::test::test_utils::{CANISTER_TEST, VM, setup_thread_local_canister_for_test};
 use crate::metrics::MetricsManager;
 use crate::pb::v1::{NodeMetrics, SubnetMetricsKey, SubnetMetricsValue};
 use futures_util::FutureExt;
 use ic_nervous_system_canisters::registry::fake::FakeRegistry;
-use ic_node_rewards_canister_api::provider_rewards_calculation::GetNodeProviderRewardsCalculationRequest;
 use ic_node_rewards_canister_api::providers_rewards::{
     GetNodeProvidersRewardsRequest, NodeProvidersRewards,
 };
@@ -20,12 +16,10 @@ use ic_registry_keys::{
 };
 use ic_types::PrincipalId;
 use maplit::btreemap;
-use rewards_calculation::rewards_calculator::test_utils::{
+use rewards_calculation::performance_based_algorithm::test_utils::{
     create_rewards_table_for_region_test, test_node_id, test_provider_id, test_subnet_id,
 };
-use rewards_calculation::rewards_calculator_results::NodeProviderRewards;
 use rewards_calculation::types::DayUtc;
-use std::collections::BTreeMap;
 use std::rc::Rc;
 use std::str::FromStr;
 use std::sync::Arc;
@@ -247,7 +241,7 @@ fn setup_data_for_test_rewards_calculation(
     // Day 1 subnet 1
     subnets_metrics.insert(
         SubnetMetricsKey {
-            timestamp_nanos: day1.unix_ts_at_day_end(),
+            timestamp_nanos: day1.unix_ts_at_day_end_nanoseconds(),
             subnet_id: Some(subnet1.get()),
         },
         SubnetMetricsValue {
@@ -279,7 +273,7 @@ fn setup_data_for_test_rewards_calculation(
     // Day 1 subnet 2
     subnets_metrics.insert(
         SubnetMetricsKey {
-            timestamp_nanos: day1.unix_ts_at_day_end(),
+            timestamp_nanos: day1.unix_ts_at_day_end_nanoseconds(),
             subnet_id: Some(subnet2.get()),
         },
         SubnetMetricsValue {
@@ -294,7 +288,7 @@ fn setup_data_for_test_rewards_calculation(
     // Day 2 subnet 1
     subnets_metrics.insert(
         SubnetMetricsKey {
-            timestamp_nanos: day2.unix_ts_at_day_end(),
+            timestamp_nanos: day2.unix_ts_at_day_end_nanoseconds(),
             subnet_id: Some(subnet1.get()),
         },
         SubnetMetricsValue {
@@ -307,311 +301,25 @@ fn setup_data_for_test_rewards_calculation(
     );
 }
 
-const EXPECTED_TEST_1: &str = r#"{
-  "6fyp7-3ibaa-aaaaa-aaaap-4ai": {
-    "rewards_total_xdr_permyriad": 137200,
-    "base_rewards": [
-      {
-        "node_reward_type": "Type1",
-        "region": "Europe,Switzerland",
-        "monthly": "304375",
-        "daily": "10000"
-      },
-      {
-        "node_reward_type": "Type3",
-        "region": "North America,USA,California",
-        "monthly": "913125",
-        "daily": "30000"
-      },
-      {
-        "node_reward_type": "Type3dot1",
-        "region": "North America,USA,Nevada",
-        "monthly": "1217500",
-        "daily": "40000"
-      }
-    ],
-    "base_rewards_type3": [
-      {
-        "day": {
-          "value": 1704153599999999999
-        },
-        "region": "North America:USA",
-        "nodes_count": 2,
-        "avg_rewards": "35000",
-        "avg_coefficient": "0.80",
-        "value": "31500.00"
-      },
-      {
-        "day": {
-          "value": 1704239999999999999
-        },
-        "region": "North America:USA",
-        "nodes_count": 1,
-        "avg_rewards": "30000",
-        "avg_coefficient": "0.90",
-        "value": "30000"
-      }
-    ],
-    "nodes_results": [
-      {
-        "node_id": "zv7tz-zylaa-aaaaa-aaaap-2ai",
-        "node_reward_type": "Type1",
-        "region": "Europe,Switzerland",
-        "dc_id": "dc1",
-        "daily_results": [
-          {
-            "day": {
-              "value": 1704153599999999999
-            },
-            "node_status": {
-              "Assigned": {
-                "node_metrics": {
-                  "subnet_assigned": "yndj2-3ybaa-aaaaa-aaaap-yai",
-                  "subnet_assigned_fr": "0.25",
-                  "num_blocks_proposed": 95,
-                  "num_blocks_failed": 5,
-                  "original_fr": "0.05",
-                  "relative_fr": "0"
-                }
-              }
-            },
-            "performance_multiplier": "1",
-            "rewards_reduction": "0",
-            "base_rewards": "10000",
-            "adjusted_rewards": "10000"
-          },
-          {
-            "day": {
-              "value": 1704239999999999999
-            },
-            "node_status": {
-              "Assigned": {
-                "node_metrics": {
-                  "subnet_assigned": "yndj2-3ybaa-aaaaa-aaaap-yai",
-                  "subnet_assigned_fr": "0.02",
-                  "num_blocks_proposed": 98,
-                  "num_blocks_failed": 2,
-                  "original_fr": "0.02",
-                  "relative_fr": "0.00"
-                }
-              }
-            },
-            "performance_multiplier": "1",
-            "rewards_reduction": "0",
-            "base_rewards": "10000",
-            "adjusted_rewards": "10000"
-          }
-        ]
-      },
-      {
-        "node_id": "f6rsp-hqmaa-aaaaa-aaaap-2ai",
-        "node_reward_type": "Type3",
-        "region": "North America,USA,California",
-        "dc_id": "dc2",
-        "daily_results": [
-          {
-            "day": {
-              "value": 1704153599999999999
-            },
-            "node_status": {
-              "Assigned": {
-                "node_metrics": {
-                  "subnet_assigned": "yndj2-3ybaa-aaaaa-aaaap-yai",
-                  "subnet_assigned_fr": "0.25",
-                  "num_blocks_proposed": 90,
-                  "num_blocks_failed": 10,
-                  "original_fr": "0.10",
-                  "relative_fr": "0"
-                }
-              }
-            },
-            "performance_multiplier": "1",
-            "rewards_reduction": "0",
-            "base_rewards": "31500.00",
-            "adjusted_rewards": "31500.00"
-          },
-          {
-            "day": {
-              "value": 1704239999999999999
-            },
-            "node_status": {
-              "Unassigned": {
-                "extrapolated_fr": "0"
-              }
-            },
-            "performance_multiplier": "1",
-            "rewards_reduction": "0",
-            "base_rewards": "30000",
-            "adjusted_rewards": "30000"
-          }
-        ]
-      },
-      {
-        "node_id": "ybquz-ianaa-aaaaa-aaaap-2ai",
-        "node_reward_type": "Type3dot1",
-        "region": "North America,USA,Nevada",
-        "dc_id": "dc3",
-        "daily_results": [
-          {
-            "day": {
-              "value": 1704153599999999999
-            },
-            "node_status": {
-              "Assigned": {
-                "node_metrics": {
-                  "subnet_assigned": "yndj2-3ybaa-aaaaa-aaaap-yai",
-                  "subnet_assigned_fr": "0.25",
-                  "num_blocks_proposed": 75,
-                  "num_blocks_failed": 25,
-                  "original_fr": "0.25",
-                  "relative_fr": "0.00"
-                }
-              }
-            },
-            "performance_multiplier": "1",
-            "rewards_reduction": "0",
-            "base_rewards": "31500.00",
-            "adjusted_rewards": "31500.00"
-          }
-        ]
-      },
-      {
-        "node_id": "fnlpp-iyoaa-aaaaa-aaaap-2ai",
-        "node_reward_type": "Type1",
-        "region": "Europe,Switzerland",
-        "dc_id": "dc1",
-        "daily_results": [
-          {
-            "day": {
-              "value": 1704153599999999999
-            },
-            "node_status": {
-              "Unassigned": {
-                "extrapolated_fr": "0.1125"
-              }
-            },
-            "performance_multiplier": "0.9800",
-            "rewards_reduction": "0.0200",
-            "base_rewards": "10000",
-            "adjusted_rewards": "9800.0000"
-          },
-          {
-            "day": {
-              "value": 1704239999999999999
-            },
-            "node_status": {
-              "Unassigned": {
-                "extrapolated_fr": "0"
-              }
-            },
-            "performance_multiplier": "1",
-            "rewards_reduction": "0",
-            "base_rewards": "10000",
-            "adjusted_rewards": "10000"
-          }
-        ]
-      },
-      {
-        "node_id": "yskjz-hipaa-aaaaa-aaaap-2ai",
-        "node_reward_type": "Type1",
-        "region": "Europe,Switzerland",
-        "dc_id": "dc1",
-        "daily_results": [
-          {
-            "day": {
-              "value": 1704153599999999999
-            },
-            "node_status": {
-              "Assigned": {
-                "node_metrics": {
-                  "subnet_assigned": "yndj2-3ybaa-aaaaa-aaaap-yai",
-                  "subnet_assigned_fr": "0.25",
-                  "num_blocks_proposed": 30,
-                  "num_blocks_failed": 70,
-                  "original_fr": "0.70",
-                  "relative_fr": "0.45"
-                }
-              }
-            },
-            "performance_multiplier": "0.44",
-            "rewards_reduction": "0.56",
-            "base_rewards": "10000",
-            "adjusted_rewards": "4400.00"
-          }
-        ]
-      }
-    ]
-  },
-  "djduj-3qcaa-aaaaa-aaaap-4ai": {
-    "rewards_total_xdr_permyriad": 10000,
-    "base_rewards": [
-      {
-        "node_reward_type": "Type1",
-        "region": "Europe,Switzerland",
-        "monthly": "304375",
-        "daily": "10000"
-      }
-    ],
-    "base_rewards_type3": [],
-    "nodes_results": [
-      {
-        "node_id": "6qmi3-pavaa-aaaaa-aaaap-2ai",
-        "node_reward_type": "Type1",
-        "region": "Europe,Switzerland",
-        "dc_id": "dc1",
-        "daily_results": [
-          {
-            "day": {
-              "value": 1704153599999999999
-            },
-            "node_status": {
-              "Assigned": {
-                "node_metrics": {
-                  "subnet_assigned": "fbysm-3acaa-aaaaa-aaaap-yai",
-                  "subnet_assigned_fr": "0.20",
-                  "num_blocks_proposed": 80,
-                  "num_blocks_failed": 20,
-                  "original_fr": "0.20",
-                  "relative_fr": "0.00"
-                }
-              }
-            },
-            "performance_multiplier": "1",
-            "rewards_reduction": "0",
-            "base_rewards": "10000",
-            "adjusted_rewards": "10000"
-          }
-        ]
-      }
-    ]
-  }
-}"#;
 #[test]
 fn test_get_node_providers_rewards() {
     use pretty_assertions::assert_eq;
 
     let (fake_registry, metrics_manager) = setup_thread_local_canister_for_test();
     setup_data_for_test_rewards_calculation(fake_registry, metrics_manager);
+    NodeRewardsCanister::schedule_registry_sync(&CANISTER_TEST).now_or_never();
+    NodeRewardsCanister::schedule_metrics_sync(&CANISTER_TEST).now_or_never();
     let from = DayUtc::try_from("2024-01-01").unwrap();
     let to = DayUtc::try_from("2024-01-02").unwrap();
 
     let request = GetNodeProvidersRewardsRequest {
-        from_nanos: from.unix_ts_at_day_start(),
-        to_nanos: to.unix_ts_at_day_end(),
+        from_day_timestamp_nanos: from.unix_ts_at_day_start_nanoseconds(),
+        to_day_timestamp_nanos: to.unix_ts_at_day_end_nanoseconds(),
     };
-    let result_endpoint = NodeRewardsCanister::get_node_providers_rewards::<TestState>(
-        &CANISTER_TEST,
-        request.clone(),
-    )
-    .now_or_never()
-    .unwrap();
-
-    let inner_results = CANISTER_TEST
-        .with_borrow(|canister| canister.calculate_rewards::<TestState>(request, None))
-        .unwrap();
-    let expected: BTreeMap<PrincipalId, NodeProviderRewards> =
-        serde_json::from_str(EXPECTED_TEST_1).unwrap();
-    assert_eq!(inner_results.provider_results, expected);
+    let result_endpoint =
+        NodeRewardsCanister::get_node_providers_rewards(&CANISTER_TEST, request.clone())
+            .now_or_never()
+            .unwrap();
 
     let expected = NodeProvidersRewards {
         rewards_xdr_permyriad: btreemap! {
@@ -621,50 +329,3 @@ fn test_get_node_providers_rewards() {
     };
     assert_eq!(result_endpoint, Ok(expected));
 }
-
-#[test]
-fn test_get_node_provider_rewards_calculation_historical() {
-    use pretty_assertions::assert_eq;
-
-    let (fake_registry, metrics_manager) = setup_thread_local_canister_for_test();
-    setup_data_for_test_rewards_calculation(fake_registry, metrics_manager);
-    let from = DayUtc::try_from("2024-01-01").unwrap();
-    let to = DayUtc::try_from("2024-01-02").unwrap();
-
-    let request = GetNodeProvidersRewardsRequest {
-        from_nanos: from.unix_ts_at_day_end(),
-        to_nanos: to.unix_ts_at_day_end(),
-    };
-
-    // Invoke to populate historical rewards
-    let _ = NodeRewardsCanister::get_node_providers_rewards::<TestState>(
-        &CANISTER_TEST,
-        request.clone(),
-    )
-    .now_or_never()
-    .unwrap();
-
-    let expected: BTreeMap<PrincipalId, NodeProviderRewards> =
-        serde_json::from_str(EXPECTED_TEST_1).unwrap();
-
-    for (provider_id, expected_rewards) in expected {
-        let request = GetNodeProviderRewardsCalculationRequest {
-            from_nanos: from.unix_ts_at_day_end(),
-            to_nanos: to.unix_ts_at_day_end(),
-            provider_id: provider_id.0,
-        };
-
-        let got = NodeRewardsCanister::get_node_provider_rewards_calculation::<TestState>(
-            &CANISTER_TEST,
-            request,
-        )
-        .unwrap();
-
-        assert_eq!(
-            got,
-            to_candid_type(expected_rewards),
-            "Mismatch for provider {:?}",
-            provider_id
-        );
-    }
-}
diff --git a/rs/node_rewards/canister/src/lib.rs b/rs/node_rewards/canister/src/lib.rs
index 0cf146f7ea..20af202a31 100644
--- a/rs/node_rewards/canister/src/lib.rs
+++ b/rs/node_rewards/canister/src/lib.rs
@@ -11,7 +11,6 @@ use ic_management_canister_types::NodeMetrics;
 use ic_stable_structures::Storable;
 use ic_stable_structures::storable::Bound;
 use prost::Message;
-use rewards_calculation::types::SubnetMetricsDailyKey;
 use std::borrow::Cow;
 
 pub mod api_conversion;
@@ -121,15 +120,6 @@ impl From<pb::v1::SubnetIdKey> for SubnetId {
     }
 }
 
-impl From<pb::v1::SubnetMetricsKey> for SubnetMetricsDailyKey {
-    fn from(key: pb::v1::SubnetMetricsKey) -> Self {
-        Self {
-            day: key.timestamp_nanos.into(),
-            subnet_id: SubnetId::from(key.subnet_id.unwrap()),
-        }
-    }
-}
-
 impl From<NodeMetrics> for pb::v1::NodeMetrics {
     fn from(metrics: NodeMetrics) -> Self {
         pb::v1::NodeMetrics {
diff --git a/rs/node_rewards/canister/src/main.rs b/rs/node_rewards/canister/src/main.rs
index 525644133a..e05229c245 100644
--- a/rs/node_rewards/canister/src/main.rs
+++ b/rs/node_rewards/canister/src/main.rs
@@ -113,10 +113,7 @@ async fn get_node_providers_rewards(
     request: GetNodeProvidersRewardsRequest,
 ) -> GetNodeProvidersRewardsResponse {
     panic_if_caller_not_governance();
-    NodeRewardsCanister::get_node_providers_rewards::<RegistryStoreStableMemoryBorrower>(
-        &CANISTER, request,
-    )
-    .await
+    NodeRewardsCanister::get_node_providers_rewards(&CANISTER, request).await
 }
 
 #[query]
@@ -130,9 +127,7 @@ fn get_node_provider_rewards_calculation(
         );
     }
 
-    NodeRewardsCanister::get_node_provider_rewards_calculation::<RegistryStoreStableMemoryBorrower>(
-        &CANISTER, request,
-    )
+    NodeRewardsCanister::get_node_provider_rewards_calculation(&CANISTER, request)
 }
 
 #[cfg(test)]
diff --git a/rs/node_rewards/canister/src/metrics.rs b/rs/node_rewards/canister/src/metrics.rs
index 3116b784ec..9df82f44dc 100644
--- a/rs/node_rewards/canister/src/metrics.rs
+++ b/rs/node_rewards/canister/src/metrics.rs
@@ -8,7 +8,7 @@ use ic_cdk::api::call::CallResult;
 use ic_management_canister_types::{NodeMetricsHistoryArgs, NodeMetricsHistoryRecord};
 use ic_stable_structures::StableBTreeMap;
 use itertools::Itertools;
-use rewards_calculation::types::{DayUtc, NodeMetricsDailyRaw, SubnetMetricsDailyKey, UnixTsNanos};
+use rewards_calculation::types::{DayUtc, NodeMetricsDailyRaw, UnixTsNanos};
 use std::cell::RefCell;
 use std::collections::{BTreeMap, HashMap};
 
@@ -178,24 +178,22 @@ where
         }
     }
 
-    /// Computes daily node metrics per subnet within the specified time range.
+    /// Computes daily node metrics for a specific day.
     ///
-    /// For each node in every subnet, calculates the number of proposed and failed blocks
-    /// produced during each day. This is done by subtracting the total metrics of the
+    /// This is done by subtracting the total metrics of the
     /// previous day from those of the current day.
-    pub fn daily_metrics_by_subnet(
+    pub fn metrics_by_subnet(
         &self,
-        start_day: DayUtc,
-        end_day: DayUtc,
-    ) -> BTreeMap<SubnetMetricsDailyKey, Vec<NodeMetricsDailyRaw>> {
-        let mut daily_metrics_by_subnet = BTreeMap::new();
-        let previous_day_ts = start_day.previous_day().unix_ts_at_day_start();
+        day_utc: &DayUtc,
+    ) -> BTreeMap<SubnetId, Vec<NodeMetricsDailyRaw>> {
+        let mut metrics_by_subnet = BTreeMap::new();
+        let previous_day_ts = day_utc.previous_day().unix_ts_at_day_start_nanoseconds();
         let first_key = SubnetMetricsKey {
             timestamp_nanos: previous_day_ts,
             ..SubnetMetricsKey::min_key()
         };
         let last_key = SubnetMetricsKey {
-            timestamp_nanos: end_day.get(),
+            timestamp_nanos: day_utc.get(),
             ..SubnetMetricsKey::max_key()
         };
 
@@ -207,10 +205,10 @@ where
             .into_iter()
             .collect();
 
-        let mut last_total_metrics: HashMap<_, _> = HashMap::new();
+        let mut initial_total_metrics: HashMap<_, _> = HashMap::new();
         if let Some((timestamp_nanos, _)) = subnets_metrics_by_day.first_key_value() {
-            if timestamp_nanos < &start_day {
-                last_total_metrics = subnets_metrics_by_day
+            if timestamp_nanos < day_utc {
+                initial_total_metrics = subnets_metrics_by_day
                     .pop_first()
                     .unwrap()
                     .1
@@ -231,38 +229,30 @@ where
         };
 
         for (_, subnets_metrics) in subnets_metrics_by_day {
-            // current_total_metrics holds the total metrics for the current day per node per subnet.
-            // It will be used to calculate the daily metrics for each node the next day by subtracting
-            // the last day's total metrics from the current day's total metrics.
-            let mut current_total_metrics: HashMap<_, _> = HashMap::new();
             for (k, v) in subnets_metrics {
+                let subnet_id = SubnetId::from(k.subnet_id.unwrap());
+
                 let daily_nodes_metrics: Vec<NodeMetricsDailyRaw> = v
                     .nodes_metrics
                     .into_iter()
                     .map(|node| {
-                        let (last_proposed_total, last_failed_total) = last_total_metrics
+                        let (initial_proposed_total, initial_failed_total) = initial_total_metrics
                             .remove(&(k.subnet_id, node.node_id))
                             .unwrap_or_default();
-                        current_total_metrics.insert(
-                            (k.subnet_id, node.node_id),
-                            (node.num_blocks_proposed_total, node.num_blocks_failed_total),
-                        );
-
                         NodeMetricsDailyRaw {
                             node_id: NodeId::from(node.node_id.unwrap()),
                             num_blocks_proposed: node.num_blocks_proposed_total
-                                - last_proposed_total,
-                            num_blocks_failed: node.num_blocks_failed_total - last_failed_total,
+                                - initial_proposed_total,
+                            num_blocks_failed: node.num_blocks_failed_total - initial_failed_total,
                         }
                     })
                     .collect();
 
-                daily_metrics_by_subnet.insert(k.into(), daily_nodes_metrics);
+                metrics_by_subnet.insert(subnet_id, daily_nodes_metrics);
             }
-            last_total_metrics = current_total_metrics;
         }
 
-        daily_metrics_by_subnet
+        metrics_by_subnet
     }
 }
 
diff --git a/rs/node_rewards/canister/src/metrics/tests.rs b/rs/node_rewards/canister/src/metrics/tests.rs
index 95ac66faf7..8fc016da2f 100644
--- a/rs/node_rewards/canister/src/metrics/tests.rs
+++ b/rs/node_rewards/canister/src/metrics/tests.rs
@@ -316,10 +316,10 @@ async fn _daily_metrics_correct_different_update_size(size: usize) {
     for _ in 0..MAX_TIMES {
         mm.update_subnets_metrics(vec![subnet_id(1)]).await;
     }
-    let daily_metrics: Vec<Vec<NodeMetricsDailyRaw>> = mm
-        .daily_metrics_by_subnet(0.into(), (4 * ONE_DAY_NANOS).into())
-        .into_values()
-        .collect();
+    let daily_metrics: Vec<Vec<NodeMetricsDailyRaw>> =
+        mm.metrics_by_subnet(&0.into()).into_values().collect();
+
+    println!("{:?}", daily_metrics);
 
     // (7, 5)
     assert_eq!(daily_metrics[0][0].num_blocks_proposed, 7);
@@ -328,24 +328,39 @@ async fn _daily_metrics_correct_different_update_size(size: usize) {
     assert_eq!(daily_metrics[0][1].num_blocks_proposed, 19);
     assert_eq!(daily_metrics[0][1].num_blocks_failed, 21);
 
+    let daily_metrics: Vec<Vec<NodeMetricsDailyRaw>> = mm
+        .metrics_by_subnet(&ONE_DAY_NANOS.into())
+        .into_values()
+        .collect();
+
     // (10 - 7, 6 - 5) = (3, 1)
     // (32 - 19, 22 - 21) = (13, 1)
-    assert_eq!(daily_metrics[1][0].num_blocks_proposed, 3);
-    assert_eq!(daily_metrics[1][0].num_blocks_failed, 1);
+    assert_eq!(daily_metrics[0][0].num_blocks_proposed, 3);
+    assert_eq!(daily_metrics[0][0].num_blocks_failed, 1);
+
+    assert_eq!(daily_metrics[0][1].num_blocks_proposed, 13);
+    assert_eq!(daily_metrics[0][1].num_blocks_failed, 1);
 
-    assert_eq!(daily_metrics[1][1].num_blocks_proposed, 13);
-    assert_eq!(daily_metrics[1][1].num_blocks_failed, 1);
+    let daily_metrics: Vec<Vec<NodeMetricsDailyRaw>> = mm
+        .metrics_by_subnet(&(2 * ONE_DAY_NANOS).into())
+        .into_values()
+        .collect();
 
     // (15 - 10, 6 - 6) = (5, 0)
-    assert_eq!(daily_metrics[2][0].num_blocks_proposed, 5);
-    assert_eq!(daily_metrics[2][0].num_blocks_failed, 0);
+    assert_eq!(daily_metrics[0][0].num_blocks_proposed, 5);
+    assert_eq!(daily_metrics[0][0].num_blocks_failed, 0);
+
+    let daily_metrics: Vec<Vec<NodeMetricsDailyRaw>> = mm
+        .metrics_by_subnet(&(3 * ONE_DAY_NANOS).into())
+        .into_values()
+        .collect();
 
     // (25 - 15, 50 - 6) = (10, 44)
-    assert_eq!(daily_metrics[3][0].num_blocks_proposed, 10);
-    assert_eq!(daily_metrics[3][0].num_blocks_failed, 44);
+    assert_eq!(daily_metrics[0][0].num_blocks_proposed, 10);
+    assert_eq!(daily_metrics[0][0].num_blocks_failed, 44);
 
-    assert_eq!(daily_metrics[3][1].num_blocks_proposed, 10);
-    assert_eq!(daily_metrics[3][1].num_blocks_failed, 10);
+    assert_eq!(daily_metrics[0][1].num_blocks_proposed, 10);
+    assert_eq!(daily_metrics[0][1].num_blocks_failed, 10);
 }
 
 #[tokio::test]
@@ -381,18 +396,22 @@ async fn daily_metrics_correct_2_subs() {
         mm.update_subnets_metrics(vec![subnet_1, subnet_2]).await;
     }
 
-    let node_1_daily_metrics = mm
-        .daily_metrics_by_subnet(0.into(), (8 * ONE_DAY_NANOS).into())
-        .into_iter()
-        .collect::<BTreeMap<_, _>>()
-        .into_iter()
-        .filter_map(|(sub, metrics)| {
-            metrics
-                .into_iter()
-                .find(|daily_metrics| daily_metrics.node_id == node_1)
-                .map(move |metrics_node_1| (sub.subnet_id, metrics_node_1))
-        })
-        .collect::<Vec<_>>();
+    let mut node_1_daily_metrics = Vec::new();
+    for day in 0..8 {
+        let daily_metrics = mm
+            .metrics_by_subnet(&(day * ONE_DAY_NANOS).into())
+            .into_iter()
+            .collect::<BTreeMap<_, _>>()
+            .into_iter()
+            .filter_map(|(sub, metrics)| {
+                metrics
+                    .into_iter()
+                    .find(|daily_metrics| daily_metrics.node_id == node_1)
+                    .map(move |metrics_node_1| (sub, metrics_node_1))
+            })
+            .collect::<Vec<_>>();
+        node_1_daily_metrics.extend(daily_metrics);
+    }
 
     for (day, (subnet, metrics)) in node_1_daily_metrics.into_iter().enumerate() {
         match day {
@@ -474,18 +493,23 @@ async fn daily_metrics_correct_overlapping_days() {
             .await;
     }
 
-    let daily_metrics = mm
-        .daily_metrics_by_subnet(0.into(), (4 * ONE_DAY_NANOS).into())
-        .into_iter()
-        .collect::<BTreeMap<_, _>>()
-        .into_iter()
-        .filter_map(|(sub, metrics)| {
-            metrics
-                .into_iter()
-                .find(|daily_metrics| daily_metrics.node_id == node_1)
-                .map(move |metrics_node_1| (sub.subnet_id, sub.day, metrics_node_1))
-        })
-        .collect::<Vec<_>>();
+    let mut daily_metrics = Vec::new();
+    for idx in 0..4 {
+        let day = (idx * ONE_DAY_NANOS).into();
+        let metrics = mm
+            .metrics_by_subnet(&day)
+            .into_iter()
+            .collect::<BTreeMap<_, _>>()
+            .into_iter()
+            .filter_map(|(sub, metrics)| {
+                metrics
+                    .into_iter()
+                    .find(|daily_metrics| daily_metrics.node_id == node_1)
+                    .map(move |metrics_node_1| (sub, day, metrics_node_1))
+            })
+            .collect::<Vec<_>>();
+        daily_metrics.extend(metrics);
+    }
 
     let overlapping_sub_1 = daily_metrics
         .iter()
diff --git a/rs/node_rewards/canister/src/registry_querier.rs b/rs/node_rewards/canister/src/registry_querier.rs
index 18a9e474af..cfaf3eb621 100644
--- a/rs/node_rewards/canister/src/registry_querier.rs
+++ b/rs/node_rewards/canister/src/registry_querier.rs
@@ -5,17 +5,14 @@ use ic_protobuf::registry::node::v1::{NodeRecord, NodeRewardType};
 use ic_protobuf::registry::node_operator::v1::NodeOperatorRecord;
 use ic_protobuf::registry::node_rewards::v2::NodeRewardsTable;
 use ic_protobuf::registry::subnet::v1::SubnetListRecord;
-use ic_registry_canister_client::{
-    CanisterRegistryClient, RegistryDataStableMemory, StorableRegistryKey, get_decoded_value,
-};
+use ic_registry_canister_client::{CanisterRegistryClient, get_decoded_value};
 use ic_registry_keys::{
     NODE_RECORD_KEY_PREFIX, NODE_REWARDS_TABLE_KEY, make_data_center_record_key,
     make_node_operator_record_key, make_subnet_list_record_key,
 };
 use ic_types::registry::RegistryClientError;
-use itertools::Itertools;
 use rewards_calculation::types::{DayUtc, Region, RewardableNode, UnixTsNanos};
-use std::collections::{BTreeMap, BTreeSet};
+use std::collections::BTreeMap;
 use std::str::FromStr;
 use std::sync::Arc;
 
@@ -79,22 +76,22 @@ impl RegistryQuerier {
 
 // Exposed API Methods
 impl RegistryQuerier {
-    /// Computes the set of rewardable nodes, grouped by node provider, for the given range of UTC days.
-    ///
-    /// A node is considered rewardable on a specific UTC day if it exists in the registry on that day.
-    /// See the `nodes_in_registry_between` method for details on how this is determined.
+    /// Computes the set of rewardable nodes, grouped by node provider, for the given UTC day.
     ///
-    /// Nodes without a specified `node_reward_type` are excluded from the rewardable set.
-    pub fn get_rewardable_nodes_per_provider<S: RegistryDataStableMemory>(
-        registry_client: &dyn CanisterRegistryClient,
-        start_day: DayUtc,
-        end_day: DayUtc,
-        provider_filter: Option<PrincipalId>,
+    /// A node is considered rewardable on a specific UTC day if it exists in the last registry
+    /// version of that day.
+    pub fn get_rewardable_nodes_per_provider(
+        &self,
+        day_utc: &DayUtc,
+        provider_filter: Option<&PrincipalId>,
     ) -> Result<BTreeMap<PrincipalId, Vec<RewardableNode>>, RegistryClientError> {
         let mut rewardable_nodes_per_provider: BTreeMap<_, Vec<RewardableNode>> = BTreeMap::new();
-        let nodes_in_range = Self::nodes_in_registry_between::<S>(start_day, end_day);
+        let registry_version = self
+            .version_for_timestamp(day_utc.unix_ts_at_day_end_nanoseconds())
+            .unwrap();
+        let nodes = self.nodes_in_version(registry_version)?;
 
-        for (node_id, (node_record, latest_version, rewardable_days)) in nodes_in_range {
+        for (node_id, node_record) in nodes {
             let node_operator_id: PrincipalId = node_record
                 .node_operator_id
                 .try_into()
@@ -105,18 +102,17 @@ impl RegistryQuerier {
                 dc_id,
                 region,
                 ..
-            }) = Self::node_operator_data(registry_client, node_operator_id, latest_version)?
+            }) = self.node_operator_data(node_operator_id, registry_version)?
             else {
                 ic_cdk::println!("Node {} has no NodeOperatorData: skipping", node_id);
                 continue;
             };
             if let Some(provider_filter) = provider_filter {
-                if node_provider_id != provider_filter {
+                if &node_provider_id != provider_filter {
                     continue;
                 }
             }
             let Some(some_reward_type) = node_record.node_reward_type else {
-                ic_cdk::println!("Node {} has no node_reward_type: skipping", node_id);
                 // If the node does not have a node_reward_type, we skip it.
                 continue;
             };
@@ -129,7 +125,6 @@ impl RegistryQuerier {
                 .or_default()
                 .push(RewardableNode {
                     node_id,
-                    rewardable_days,
                     node_reward_type,
                     dc_id: dc_id.clone(),
                     region: region.clone(),
@@ -138,125 +133,43 @@ impl RegistryQuerier {
         Ok(rewardable_nodes_per_provider)
     }
 
-    /// Returns a map of all nodes that were present in the registry in a day range.
-    ///
-    /// Let's define the following for a day `D` in the range:
-    ///
-    /// - `A`: the start of the day (00:00:00 UTC) for the day.
-    /// - `B`: the end of the day (23:59:59 UTC) for the day.
-    ///
-    /// A node is considered to be in the registry on a day `D` if:
-    ///
-    /// - it has been added in a registry version corresponding to a timestamp ts <= `B`
-    /// - it has NOT been removed in a registry version corresponding to a timestamp ts < `A`
-    ///
-    /// For each node, are returned:
-    /// - the most recent `NodeRecord` before `B` inclusive,
-    /// - the corresponding `RegistryVersion`,
-    /// - the sorted list of `DayUTC`s the node is in the registry.
-    fn nodes_in_registry_between<S: RegistryDataStableMemory>(
-        day_start: DayUtc,
-        day_end: DayUtc,
-    ) -> BTreeMap<NodeId, (NodeRecord, RegistryVersion, Vec<DayUtc>)> {
-        let start_ts = day_start.unix_ts_at_day_start();
-        let end_ts = day_end.unix_ts_at_day_end();
+    /// Returns a map of all nodes that were present in the registry at the specified version.
+    fn nodes_in_version(
+        &self,
+        registry_version: RegistryVersion,
+    ) -> Result<BTreeMap<NodeId, NodeRecord>, RegistryClientError> {
+        let nodes_raw = self
+            .registry_client
+            .get_key_family_with_values(NODE_RECORD_KEY_PREFIX, registry_version)?;
         let prefix_length = NODE_RECORD_KEY_PREFIX.len();
 
-        let start_key = StorableRegistryKey {
-            key: NODE_RECORD_KEY_PREFIX.to_string(),
-            ..Default::default()
-        };
-
-        S::with_registry_map(|registry_map| {
-            registry_map
-                .range(start_key..)
-                .filter(|(k, _)| {
-                    k.timestamp_nanoseconds <= end_ts && k.key.starts_with(NODE_RECORD_KEY_PREFIX)
-                })
-                .map(|(k, v)| (k.key, k.version, k.timestamp_nanoseconds, v.0))
-                .group_by(|(node_key, _, _, _)| node_key.clone())
-                .into_iter()
-                .filter_map(|(node_key, node_mutations)| {
-                    let mut days = BTreeSet::new();
-                    let mut last_present_ts: Option<UnixTsNanos> = None;
-                    let mut latest_value: Option<Vec<u8>> = None;
-                    let mut latest_version = RegistryVersion::default().get();
-
-                    // Process node's mutations history.
-                    for (_, version, ts, maybe_value) in node_mutations {
-                        if maybe_value.is_some() {
-                            // A creation or update
-                            latest_value = maybe_value;
-                            latest_version = version;
-                            if last_present_ts.is_none() {
-                                // Node was absent, now it's present.
-                                // If it became present before the window, track it from the start.
-                                // Otherwise, track it from the actual timestamp.
-                                last_present_ts = Some(ts.max(start_ts));
-                            }
-                        } else {
-                            // A deletion
-                            if let Some(start_of_interval) = last_present_ts.take() {
-                                // The node was present and is now gone. Finalize the interval.
-                                let mut days_between = DayUtc::from(start_of_interval)
-                                    .days_until(&DayUtc::from(ts))
-                                    .unwrap_or_default();
-
-                                // If a node is deleted it will be rewarded until the day before deletion.
-                                if !days_between.is_empty() {
-                                    days_between.truncate(days_between.len() - 1);
-                                }
-
-                                days.extend(days_between);
-                            }
-                        }
-                    }
-
-                    // After all mutations, if the node is still present, finalize the last interval.
-                    if let Some(start_of_interval) = last_present_ts {
-                        let days_between =
-                            DayUtc::from(start_of_interval).days_until(&DayUtc::from(end_ts));
-                        days.extend(days_between.unwrap_or_default());
-                    }
-
-                    // If the node was present at any time and we have its record, decode and return it.
-                    if !days.is_empty() {
-                        if let Some(final_value) = latest_value {
-                            let principal = PrincipalId::from_str(&node_key[prefix_length..])
-                                .expect("Invalid node key");
-                            let node_id = NodeId::from(principal);
-                            let node_record = NodeRecord::decode(final_value.as_slice())
-                                .expect("Failed to decode NodeRecord");
-
-                            return Some((
-                                node_id,
-                                (
-                                    node_record,
-                                    RegistryVersion::from(latest_version),
-                                    days.into_iter().sorted().collect(),
-                                ),
-                            ));
-                        }
-                    }
-                    None
-                })
-                .collect()
-        })
+        let nodes = nodes_raw
+            .into_iter()
+            .map(|(node_key, node_value)| {
+                let principal =
+                    PrincipalId::from_str(&node_key[prefix_length..]).expect("Invalid node key");
+                let node_id = NodeId::from(principal);
+                let node_record =
+                    NodeRecord::decode(node_value.as_slice()).expect("Failed to decode NodeRecord");
+                (node_id, node_record)
+            })
+            .collect();
+        Ok(nodes)
     }
 
     fn node_operator_data(
-        registry_client: &dyn CanisterRegistryClient,
+        &self,
         node_operator: PrincipalId,
         version: RegistryVersion,
     ) -> Result<Option<NodeOperatorData>, RegistryClientError> {
         let node_operator_record_key = make_node_operator_record_key(node_operator);
         let Some(node_operator_record) = get_decoded_value::<NodeOperatorRecord>(
-            registry_client,
+            &*self.registry_client,
             node_operator_record_key.as_str(),
             version,
         )
         .map_err(|e| RegistryClientError::DecodeError {
-            error: format!("Failed to decode NodeOperatorRecord: {e}"),
+            error: format!("Failed to decode NodeOperatorRecord: {}", e),
         })?
         else {
             return Ok(None);
@@ -264,12 +177,12 @@ impl RegistryQuerier {
 
         let data_center_key = make_data_center_record_key(node_operator_record.dc_id.as_str());
         let Some(data_center_record) = get_decoded_value::<DataCenterRecord>(
-            registry_client,
+            &*self.registry_client,
             data_center_key.as_str(),
             version,
         )
         .map_err(|e| RegistryClientError::DecodeError {
-            error: format!("Failed to decode DataCenterRecord: {e}"),
+            error: format!("Failed to decode DataCenterRecord: {}", e),
         })?
         else {
             return Ok(None);
diff --git a/rs/node_rewards/canister/src/registry_querier/tests.rs b/rs/node_rewards/canister/src/registry_querier/tests.rs
index 0272e7e2df..33514945ba 100644
--- a/rs/node_rewards/canister/src/registry_querier/tests.rs
+++ b/rs/node_rewards/canister/src/registry_querier/tests.rs
@@ -17,7 +17,7 @@ use ic_registry_keys::{
 use ic_stable_structures::memory_manager::{MemoryId, MemoryManager, VirtualMemory};
 use ic_stable_structures::{DefaultMemoryImpl, StableBTreeMap};
 use maplit::btreemap;
-use rewards_calculation::types::{DayUtc, RewardPeriod, RewardableNode};
+use rewards_calculation::types::{DayUtc, RewardableNode};
 use std::cell::RefCell;
 use std::sync::Arc;
 
@@ -45,7 +45,7 @@ fn add_record_helper(
     datetime_str: &str,
 ) {
     let ts = DayUtc::try_from(datetime_str).unwrap();
-    add_record_helper_ts(key, version, value, ts.unix_ts_at_day_end());
+    add_record_helper_ts(key, version, value, ts.unix_ts_at_day_end_nanoseconds());
 }
 
 fn add_record_helper_ts(key: &str, version: u64, value: Option<impl ::prost::Message>, ts: u64) {
@@ -88,7 +88,7 @@ fn generate_node_operator_key_value(
         dc_id,
         ..NodeOperatorRecord::default()
     };
-    let key = format!("{NODE_OPERATOR_RECORD_KEY_PREFIX}{principal_id}");
+    let key = format!("{}{}", NODE_OPERATOR_RECORD_KEY_PREFIX, principal_id);
 
     (key, value)
 }
@@ -99,7 +99,7 @@ fn generate_dc_key_value(dc_id: String) -> (String, DataCenterRecord) {
         region: "A".to_string(),
         ..DataCenterRecord::default()
     };
-    let key = format!("{DATA_CENTER_KEY_PREFIX}{dc_id}");
+    let key = format!("{}{}", DATA_CENTER_KEY_PREFIX, dc_id);
 
     (key, value)
 }
@@ -143,7 +143,7 @@ fn add_dummy_data() {
     // Removed and re-added node_3 same day
     let ts_removed = DayUtc::try_from("2025-07-16")
         .unwrap()
-        .unix_ts_at_day_start()
+        .unix_ts_at_day_start_nanoseconds()
         + 1;
     add_record_helper_ts(&node_3_k, 39676, None::<NodeRecord>, ts_removed);
     let ts_readded = ts_removed + 1;
@@ -159,17 +159,6 @@ fn client_for_tests() -> RegistryQuerier {
     }
 }
 
-fn node_rewardable_days(rewardable_nodes: &[RewardableNode], node_id: u64) -> Vec<DayUtc> {
-    let node_id = NodeId::from(PrincipalId::new_node_test_id(node_id));
-
-    rewardable_nodes
-        .iter()
-        .find(|n| n.node_id == node_id)
-        .unwrap_or_else(|| panic!("Node {node_id} should be present"))
-        .clone()
-        .rewardable_days
-}
-
 #[test]
 fn test_subnets_list_returns_expected_subnets() {
     let client = client_for_tests();
@@ -232,159 +221,51 @@ fn test_get_rewards_table_returns_correct_record() {
 
     assert_eq!(result, table);
 }
-
-#[test]
-fn test_nodes_in_registry_returns_expected_days() {
-    let _client = client_for_tests();
-
-    // Time range where:
-    // - node_1 exists until 2025-07-07
-    // - node_2 is always present
-    // - node_3 appears on 2025-07-11
-    let from = DayUtc::try_from("2025-07-03").unwrap();
-    let to = DayUtc::try_from("2025-07-16").unwrap();
-    let nodes_map = RegistryQuerier::nodes_in_registry_between::<DummyState>(from, to);
-
-    let node_1_id = NodeId::from(PrincipalId::new_node_test_id(1));
-    let node_2_id = NodeId::from(PrincipalId::new_node_test_id(2));
-    let node_3_id = NodeId::from(PrincipalId::new_node_test_id(3));
-
-    let (_, _, node_1_days) = &nodes_map[&node_1_id];
-    let expected_node_1_days: Vec<DayUtc> = vec![
-        DayUtc::try_from("2025-07-03").unwrap(),
-        DayUtc::try_from("2025-07-04").unwrap(),
-        DayUtc::try_from("2025-07-05").unwrap(),
-        DayUtc::try_from("2025-07-06").unwrap(),
-        DayUtc::try_from("2025-07-07").unwrap(),
-    ];
-    assert_eq!(node_1_days, &expected_node_1_days);
-
-    let (_, _, node_2_days) = &nodes_map[&node_2_id];
-    let expected_node_2_days: Vec<DayUtc> = vec![
-        DayUtc::try_from("2025-07-04").unwrap(),
-        DayUtc::try_from("2025-07-05").unwrap(),
-        DayUtc::try_from("2025-07-06").unwrap(),
-        DayUtc::try_from("2025-07-07").unwrap(),
-        DayUtc::try_from("2025-07-08").unwrap(),
-        DayUtc::try_from("2025-07-09").unwrap(),
-        DayUtc::try_from("2025-07-10").unwrap(),
-        DayUtc::try_from("2025-07-11").unwrap(),
-        DayUtc::try_from("2025-07-12").unwrap(),
-        DayUtc::try_from("2025-07-13").unwrap(),
-        DayUtc::try_from("2025-07-14").unwrap(),
-        DayUtc::try_from("2025-07-15").unwrap(),
-        DayUtc::try_from("2025-07-16").unwrap(),
-    ];
-    assert_eq!(node_2_days, &expected_node_2_days);
-
-    let (_, _, node_3_days) = &nodes_map[&node_3_id];
-    let expected_node_3_days: Vec<DayUtc> = vec![
-        DayUtc::try_from("2025-07-11").unwrap(),
-        DayUtc::try_from("2025-07-12").unwrap(),
-        // node_3 was deleted on 2025-07-13, so it should not be present on 2025-07-14
-        DayUtc::try_from("2025-07-15").unwrap(),
-        DayUtc::try_from("2025-07-16").unwrap(),
-    ];
-    assert_eq!(node_3_days, &expected_node_3_days);
+fn contains_node(nodes: &[RewardableNode], node_num: u64) -> bool {
+    nodes
+        .iter()
+        .any(|n| n.node_id == NodeId::from(PrincipalId::new_node_test_id(node_num)))
 }
-
 #[test]
 fn test_rewardable_nodes_deleted_nodes() {
-    let _client = client_for_tests();
-    // Define the range for which we want to check rewardable nodes.
-    // This is *after* node_1 was deleted.
-    let from = DayUtc::try_from("2025-07-12").unwrap();
-    let to = DayUtc::try_from("2025-07-13").unwrap();
-    let _reward_period = RewardPeriod::new(from, to).expect("Failed to create reward period");
-
-    let mut rewardables = RegistryQuerier::get_rewardable_nodes_per_provider::<DummyState>(
-        &*REGISTRY_STORE.with(|store| store.clone()),
-        from,
-        to,
-        None,
-    )
-    .expect("Failed to fetch rewardable nodes");
+    let client = client_for_tests();
+    let day1 = DayUtc::try_from("2025-07-12").unwrap();
+    let day2 = DayUtc::try_from("2025-07-13").unwrap();
+
+    let mut rewardable_nodes_day1 = client
+        .get_rewardable_nodes_per_provider(&day1, None)
+        .unwrap();
+    let mut rewardable_nodes_day2 = client
+        .get_rewardable_nodes_per_provider(&day2, None)
+        .unwrap();
 
     let np_1_id = PrincipalId::new_user_test_id(20);
-    let np_1_rewardables = rewardables
-        .remove(&np_1_id)
-        .expect("No rewardables found for node provider");
+    let rewardables_day1 = rewardable_nodes_day1.remove(&np_1_id).unwrap();
+    let rewardables_day2 = rewardable_nodes_day2.remove(&np_1_id).unwrap();
 
-    // Node 1 was deleted before this period, so it should NOT be present.
+    // Day 1 expectations
     assert!(
-        !np_1_rewardables
-            .iter()
-            .any(|n| n.node_id == NodeId::from(PrincipalId::new_node_test_id(1))),
-        "Node 1 should not be rewardable after it was deleted"
+        !contains_node(&rewardables_day1, 1),
+        "Node 1 should not be rewardable after deletion"
     );
-
-    // Node 2 should be rewardable in this period.
-    let node_2_rewardable_days = node_rewardable_days(&np_1_rewardables, 2);
-
-    assert_eq!(node_2_rewardable_days.first(), Some(&from));
-    assert_eq!(node_2_rewardable_days.last(), Some(&to));
-
-    let node_3_rewardable_days = node_rewardable_days(&np_1_rewardables, 3);
-
-    // Node 3 should be rewardable until 2025-07-12 because on 2025-07-13 got deleted.
-    assert_eq!(node_3_rewardable_days.first(), Some(&from));
-    assert_eq!(
-        node_3_rewardable_days.last(),
-        Some(&DayUtc::try_from("2025-07-12").unwrap())
+    assert!(
+        contains_node(&rewardables_day1, 2),
+        "Node 2 should be rewardable on day 1"
     );
-}
-
-#[test]
-fn test_rewardable_nodes_rewardables_till_deleted() {
-    let _client = client_for_tests();
-
-    // Define a time range that spans:
-    // - The active time of node_1 (until deletion on 2025-07-08),
-    // - Node_2's full active range,
-    // - Node_3's creation (on 2025-07-11).
-    let from = DayUtc::try_from("2025-07-03").unwrap();
-    let to = DayUtc::try_from("2025-07-12").unwrap();
-    let _reward_period = RewardPeriod::new(from, to).expect("Failed to create reward period");
-
-    let mut rewardables = RegistryQuerier::get_rewardable_nodes_per_provider::<DummyState>(
-        &*REGISTRY_STORE.with(|store| store.clone()),
-        from,
-        to,
-        None,
-    )
-    .expect("Failed to fetch rewardable nodes");
-
-    let np_1_id = PrincipalId::new_user_test_id(20);
-    let np_1_rewardables = rewardables
-        .remove(&np_1_id)
-        .expect("No rewardables found for node provider");
-
-    // Node 1 was deleted on 2025-07-08, so its rewardable period ends there.
-    let node_1_rewardable_days = node_rewardable_days(&np_1_rewardables, 1);
-
-    assert_eq!(node_1_rewardable_days.first(), Some(&from));
-    assert_eq!(
-        node_1_rewardable_days.last(),
-        Some(&DayUtc::try_from("2025-07-07").unwrap())
+    assert!(
+        contains_node(&rewardables_day1, 3),
+        "Node 3 should be rewardable on day 1"
     );
 
-    // Node 2 is active throughout the whole range.
-    let node_2_rewardable_days = node_rewardable_days(&np_1_rewardables, 2);
-
-    assert_eq!(
-        node_2_rewardable_days.first(),
-        Some(&DayUtc::try_from("2025-07-04").unwrap())
+    // Day 2 expectations
+    assert!(
+        !contains_node(&rewardables_day2, 3),
+        "Node 3 should NOT be rewardable on day 2 because it was removed"
     );
-    assert_eq!(node_2_rewardable_days.last(), Some(&to));
-
-    // Node 3 became active on 2025-07-11.
-    let node_3_rewardable_days = node_rewardable_days(&np_1_rewardables, 3);
-
-    assert_eq!(
-        node_3_rewardable_days.first(),
-        Some(&DayUtc::try_from("2025-07-11").unwrap())
+    assert!(
+        contains_node(&rewardables_day2, 2),
+        "Node 2 should be rewardable on day 2"
     );
-    assert_eq!(node_3_rewardable_days.last(), Some(&to));
 }
 
 #[test]
@@ -392,9 +273,8 @@ fn test_node_re_registered_after_deletion() {
     let node_1_id = 1;
     let no_1_id = 10;
 
-    // Re-register node_1 after it was deleted
     let node_id = PrincipalId::new_node_test_id(node_1_id);
-    let node_key = format!("{NODE_RECORD_KEY_PREFIX}{node_id}");
+    let node_key = format!("{}{}", NODE_RECORD_KEY_PREFIX, node_id);
     let node_record = NodeRecord {
         node_reward_type: Some(NodeRewardType::Type0 as i32),
         node_operator_id: PrincipalId::new_user_test_id(no_1_id).to_vec(),
@@ -403,74 +283,50 @@ fn test_node_re_registered_after_deletion() {
 
     add_record_helper(&node_key, 39668, Some(node_record), "2025-07-11");
 
-    let _client = client_for_tests();
+    let client = client_for_tests();
 
-    // Range that includes both the deletion and re-registration periods
     let from = DayUtc::try_from("2025-07-07").unwrap();
     let to = DayUtc::try_from("2025-07-12").unwrap();
-    let _reward_period = RewardPeriod::new(from, to).expect("Failed to create reward period");
-
-    let mut rewardables = RegistryQuerier::get_rewardable_nodes_per_provider::<DummyState>(
-        &*REGISTRY_STORE.with(|store| store.clone()),
-        from,
-        to,
-        None,
-    )
-    .expect("Failed to fetch rewardables");
-
-    let np_1_id = PrincipalId::new_user_test_id(20);
-    let np_1_rewardables = rewardables
-        .remove(&np_1_id)
-        .expect("No rewardables for node provider");
-
-    let node_1_rewardable_days = node_rewardable_days(&np_1_rewardables, node_1_id);
-
-    let expected_days: Vec<DayUtc> = vec![
-        DayUtc::try_from("2025-07-07").unwrap(),
-        // On 2025-07-08, node_1 was deleted, so it should not be rewardable until the 2025-07-11.
-        DayUtc::try_from("2025-07-11").unwrap(),
-        DayUtc::try_from("2025-07-12").unwrap(),
+    let mut current_day = from;
+    let expected_absent = [
+        DayUtc::try_from("2025-07-08").unwrap(),
+        DayUtc::try_from("2025-07-09").unwrap(),
+        DayUtc::try_from("2025-07-10").unwrap(),
     ];
 
-    assert_eq!(node_1_rewardable_days, expected_days);
-}
-
-#[test]
-fn test_rewardables_nodes_provider_filtered() {
-    let _client = client_for_tests();
-    let from = DayUtc::try_from("2025-07-12").unwrap();
-    let to = DayUtc::try_from("2025-07-17").unwrap();
-    let _reward_period = RewardPeriod::new(from, to).expect("Failed to create reward period");
-    let np_2_id = PrincipalId::new_user_test_id(50);
-
-    let rewardables = RegistryQuerier::get_rewardable_nodes_per_provider::<DummyState>(
-        &*REGISTRY_STORE.with(|store| store.clone()),
-        from,
-        to,
-        Some(np_2_id),
-    )
-    .expect("Failed to fetch rewardable nodes");
-
-    assert_eq!(rewardables.len(), 1);
-    let np_2_rewardables = rewardables.get(&np_2_id).unwrap();
-    assert_eq!(np_2_rewardables.len(), 1);
-    let expected_node_4 = NodeId::from(PrincipalId::new_node_test_id(4));
-    assert_eq!(np_2_rewardables[0].node_id, expected_node_4);
+    while current_day <= to {
+        let rewardables = client
+            .get_rewardable_nodes_per_provider(&current_day, None)
+            .unwrap()
+            .remove(&PrincipalId::new_user_test_id(20))
+            .unwrap();
+
+        if expected_absent.contains(&current_day) {
+            assert!(
+                !contains_node(&rewardables, 1),
+                "Node 1 should not be rewardable after deletion"
+            );
+        } else {
+            assert!(
+                contains_node(&rewardables, 1),
+                "Node 1 should be rewardable on day 1"
+            );
+        }
+
+        current_day = current_day.next_day();
+    }
 }
 
 #[test]
 fn test_node_operator_data_returns_expected_data() {
-    let _client = client_for_tests();
+    let client = client_for_tests();
 
     let version = 39667;
     let no_2_id = PrincipalId::new_user_test_id(30);
-    let data = RegistryQuerier::node_operator_data(
-        &*REGISTRY_STORE.with(|store| store.clone()),
-        no_2_id,
-        version.into(),
-    )
-    .unwrap()
-    .unwrap();
+    let data = client
+        .node_operator_data(no_2_id, version.into())
+        .unwrap()
+        .unwrap();
 
     assert_eq!(data.node_provider_id, PrincipalId::new_user_test_id(20));
     assert_eq!(data.dc_id, "y");
@@ -478,27 +334,23 @@ fn test_node_operator_data_returns_expected_data() {
 
     let version = 39675;
     let no_1_id = PrincipalId::new_user_test_id(10);
-    let data = RegistryQuerier::node_operator_data(
-        &*REGISTRY_STORE.with(|store| store.clone()),
-        no_1_id,
-        version.into(),
-    )
-    .unwrap()
-    .unwrap();
+    let data = client
+        .node_operator_data(no_1_id, version.into())
+        .unwrap()
+        .unwrap();
 
     assert_eq!(data.node_provider_id, PrincipalId::new_user_test_id(20));
     assert_eq!(data.dc_id, "x");
     assert_eq!(data.region, "A");
 
     let not_yet_added_no_version = 39652;
-    let data = RegistryQuerier::node_operator_data(
-        &*REGISTRY_STORE.with(|store| store.clone()),
-        no_1_id,
-        not_yet_added_no_version.into(),
-    )
-    .unwrap();
+    let data = client
+        .node_operator_data(no_1_id, not_yet_added_no_version.into())
+        .unwrap();
+
     assert!(
         data.is_none(),
-        "Data should not exist for version {not_yet_added_no_version} because Operator was not yet added"
+        "Data should not exist for version {} because Operator was not yet added",
+        not_yet_added_no_version
     );
 }
diff --git a/rs/node_rewards/canister/tests/get_node_providers_monthly_xdr_rewards.rs b/rs/node_rewards/canister/tests/get_node_providers_monthly_xdr_rewards.rs
index c475ed4ceb..bd5f326c7a 100644
--- a/rs/node_rewards/canister/tests/get_node_providers_monthly_xdr_rewards.rs
+++ b/rs/node_rewards/canister/tests/get_node_providers_monthly_xdr_rewards.rs
@@ -76,8 +76,8 @@ async fn get_node_provider_rewards_calculation_is_only_callable_in_nonreplicated
     pocket_ic.tick().await;
 
     let request = GetNodeProviderRewardsCalculationRequest {
-        from_nanos: past_time_nanos,
-        to_nanos: past_time_nanos,
+        from_day_timestamp_nanos: past_time_nanos,
+        to_day_timestamp_nanos: past_time_nanos,
         provider_id: Principal::anonymous(),
     };
 
@@ -92,7 +92,10 @@ async fn get_node_provider_rewards_calculation_is_only_callable_in_nonreplicated
     .unwrap()
     .0
     .unwrap_err();
-    assert_eq!(err, "No rewards found for node provider 2vxsx-fae");
+    assert_eq!(
+        err,
+        "Could not calculate rewards: \"No metrics found for day 1620345599999999999\""
+    );
 
     // Replicated update call is not allowed.
     let err = update_candid::<_, (GetNodeProviderRewardsCalculationResponse,)>(
diff --git a/rs/node_rewards/rewards_calculation/BUILD.bazel b/rs/node_rewards/rewards_calculation/BUILD.bazel
index 7c5089e056..abe52d044d 100644
--- a/rs/node_rewards/rewards_calculation/BUILD.bazel
+++ b/rs/node_rewards/rewards_calculation/BUILD.bazel
@@ -6,10 +6,8 @@ DEPENDENCIES = [
     # Keep sorted.
     "//rs/protobuf",
     "//rs/types/base_types",
-    "//rs/types/types",
     "@crate_index//:candid",
     "@crate_index//:chrono_canisters",
-    "@crate_index//:ic-cdk",
     "@crate_index//:itertools",
     "@crate_index//:maplit",
     "@crate_index//:rust_decimal",
diff --git a/rs/node_rewards/rewards_calculation/Cargo.toml b/rs/node_rewards/rewards_calculation/Cargo.toml
index f9e5a8e5df..d3de985e51 100644
--- a/rs/node_rewards/rewards_calculation/Cargo.toml
+++ b/rs/node_rewards/rewards_calculation/Cargo.toml
@@ -10,8 +10,6 @@ documentation.workspace = true
 path = "src/lib.rs"
 
 [dependencies]
-ic-cdk = { workspace = true }
-ic-types = { path = "../../types/types" }
 ic-base-types = { path = "../../types/base_types" }
 itertools = { workspace = true }
 ic-protobuf = { path = "../../protobuf" }
diff --git a/rs/node_rewards/rewards_calculation/src/lib.rs b/rs/node_rewards/rewards_calculation/src/lib.rs
index f198983a33..069d06b865 100644
--- a/rs/node_rewards/rewards_calculation/src/lib.rs
+++ b/rs/node_rewards/rewards_calculation/src/lib.rs
@@ -1,4 +1,2 @@
-mod performance_based_algorithm;
-pub mod rewards_calculator;
-pub mod rewards_calculator_results;
+pub mod performance_based_algorithm;
 pub mod types;
diff --git a/rs/node_rewards/rewards_calculation/src/performance_based_algorithm/mod.rs b/rs/node_rewards/rewards_calculation/src/performance_based_algorithm/mod.rs
index 3977717337..3634cdcafb 100644
--- a/rs/node_rewards/rewards_calculation/src/performance_based_algorithm/mod.rs
+++ b/rs/node_rewards/rewards_calculation/src/performance_based_algorithm/mod.rs
@@ -1,15 +1,13 @@
-#![allow(dead_code)]
 use crate::performance_based_algorithm::results::{
     BaseRewards, BaseRewardsType3, DailyResults, NodeMetricsDaily, NodeProviderRewards,
     NodeResults, NodeStatus, Percent, RewardsCalculatorResults, XDRPermyriad,
 };
-use crate::performance_based_algorithm::test_utils::RewardableNode;
-use crate::types::{DayUtc, NodeMetricsDailyRaw, Region};
+use crate::types::{DayUtc, NodeMetricsDailyRaw, Region, RewardableNode};
 use ic_base_types::{NodeId, PrincipalId, SubnetId};
 use ic_protobuf::registry::node::v1::NodeRewardType;
 use ic_protobuf::registry::node_rewards::v2::NodeRewardsTable;
-use ic_types::Time;
 use itertools::Itertools;
+use maplit::btreemap;
 use rust_decimal::Decimal;
 use rust_decimal::prelude::ToPrimitive;
 use rust_decimal_macros::dec;
@@ -17,7 +15,7 @@ use std::cmp::max;
 use std::collections::BTreeMap;
 
 pub mod results;
-mod test_utils;
+pub mod test_utils;
 pub mod v1;
 
 // ================================================================================================
@@ -72,17 +70,6 @@ struct AdjustedRewardsResults {
     adjusted_rewards: BTreeMap<NodeId, XDRPermyriad>,
 }
 
-#[cfg(target_arch = "wasm32")]
-fn current_time() -> Time {
-    let current_time = ic_cdk::api::time();
-    Time::from_nanos_since_unix_epoch(current_time)
-}
-
-#[cfg(not(any(target_arch = "wasm32")))]
-fn current_time() -> Time {
-    ic_types::time::current_time()
-}
-
 pub trait DataProvider {
     fn get_rewards_table(&self, day: &DayUtc) -> Result<NodeRewardsTable, String>;
 
@@ -100,7 +87,7 @@ pub trait DataProvider {
         &self,
         day: &DayUtc,
         provider_id: &PrincipalId,
-    ) -> Result<BTreeMap<PrincipalId, Vec<RewardableNode>>, String>;
+    ) -> Result<Vec<RewardableNode>, String>;
 }
 
 trait PerformanceBasedAlgorithm {
@@ -127,24 +114,15 @@ trait PerformanceBasedAlgorithm {
     /// 2629800 / 86400 = 30.4375 days of rewards
     const REWARDS_TABLE_DAYS: Decimal = dec!(30.4375);
 
-    fn validate_reward_period(from_day: &DayUtc, to_day: &DayUtc) -> Result<(), String> {
-        let today: DayUtc = current_time().as_nanos_since_unix_epoch().into();
-        if from_day > to_day {
-            return Err("from_day must be before to_day".to_string());
-        }
-        if to_day >= &today {
-            return Err("to_day_timestamp_nanos must be earlier than today".to_string());
-        }
-        Ok(())
-    }
-
     fn calculate_rewards(
         from_day: &DayUtc,
         to_day: &DayUtc,
         node_provider_filter: Option<PrincipalId>,
         data_provider: impl DataProvider,
     ) -> Result<RewardsCalculatorResults, String> {
-        Self::validate_reward_period(from_day, to_day)?;
+        if from_day > to_day {
+            return Err("from_day must be before to_day".to_string());
+        }
 
         let reward_period = from_day.days_until(to_day)?;
         let mut total_rewards_per_provider = BTreeMap::new();
@@ -184,7 +162,8 @@ trait PerformanceBasedAlgorithm {
         let rewards_table = data_provider.get_rewards_table(day)?;
         let metrics_by_subnet = data_provider.get_daily_metrics_by_subnet(day)?;
         let providers_rewardable_nodes = if let Some(provider_id) = node_provider_filter {
-            data_provider.get_provider_rewardable_nodes(day, provider_id)?
+            let rewardable_nodes = data_provider.get_provider_rewardable_nodes(day, provider_id)?;
+            btreemap! { *provider_id => rewardable_nodes }
         } else {
             data_provider.get_rewardable_nodes(day)?
         };
@@ -308,11 +287,15 @@ trait PerformanceBasedAlgorithm {
                 })
                 .collect::<BTreeMap<_, _>>();
             let nodes_fr = nodes_original_fr.values().cloned().collect::<Vec<_>>();
-            let failure_rates = nodes_fr.iter().sorted().collect::<Vec<_>>();
-            let index = ((nodes_fr.len() as f64) * Self::SUBNET_FAILURE_RATE_PERCENTILE).ceil()
-                as usize
-                - 1;
-            let subnet_fr = *failure_rates[index];
+            let subnet_fr = if nodes_fr.is_empty() {
+                Decimal::ZERO
+            } else {
+                let failure_rates = nodes_fr.iter().sorted().collect::<Vec<_>>();
+                let index = ((nodes_fr.len() as f64) * Self::SUBNET_FAILURE_RATE_PERCENTILE).ceil()
+                    as usize
+                    - 1;
+                *failure_rates[index]
+            };
             result.subnets_fr.insert(subnet_id, subnet_fr);
 
             for NodeMetricsDailyRaw {
diff --git a/rs/node_rewards/rewards_calculation/src/performance_based_algorithm/results.rs b/rs/node_rewards/rewards_calculation/src/performance_based_algorithm/results.rs
index a5201b3a24..2d066a435b 100644
--- a/rs/node_rewards/rewards_calculation/src/performance_based_algorithm/results.rs
+++ b/rs/node_rewards/rewards_calculation/src/performance_based_algorithm/results.rs
@@ -1,4 +1,3 @@
-#![allow(dead_code)]
 use crate::types::DayUtc;
 use ic_base_types::{NodeId, PrincipalId, SubnetId};
 use ic_protobuf::registry::node::v1::NodeRewardType;
diff --git a/rs/node_rewards/rewards_calculation/src/performance_based_algorithm/test_utils.rs b/rs/node_rewards/rewards_calculation/src/performance_based_algorithm/test_utils.rs
index ea7ee0e044..f7134e2b3c 100644
--- a/rs/node_rewards/rewards_calculation/src/performance_based_algorithm/test_utils.rs
+++ b/rs/node_rewards/rewards_calculation/src/performance_based_algorithm/test_utils.rs
@@ -1,5 +1,4 @@
-#![allow(dead_code)]
-use crate::types::{NodeMetricsDailyRaw, Region};
+use crate::types::{NodeMetricsDailyRaw, Region, RewardableNode};
 use ic_base_types::{NodeId, PrincipalId, SubnetId};
 use ic_protobuf::registry::node::v1::NodeRewardType;
 use ic_protobuf::registry::node_rewards::v2::{NodeRewardRate, NodeRewardRates, NodeRewardsTable};
@@ -18,14 +17,6 @@ pub fn test_subnet_id(id: u64) -> SubnetId {
     SubnetId::from(PrincipalId::new_subnet_test_id(id))
 }
 
-#[derive(Eq, Hash, PartialEq, Clone, Ord, PartialOrd, Debug)]
-pub struct RewardableNode {
-    pub node_id: NodeId,
-    pub region: Region,
-    pub node_reward_type: NodeRewardType,
-    pub dc_id: String,
-}
-
 impl Default for RewardableNode {
     fn default() -> Self {
         RewardableNode {
diff --git a/rs/node_rewards/rewards_calculation/src/performance_based_algorithm/v1.rs b/rs/node_rewards/rewards_calculation/src/performance_based_algorithm/v1.rs
index 63a9a5ccbc..83deedbb20 100644
--- a/rs/node_rewards/rewards_calculation/src/performance_based_algorithm/v1.rs
+++ b/rs/node_rewards/rewards_calculation/src/performance_based_algorithm/v1.rs
@@ -1,5 +1,3 @@
-#![allow(dead_code)]
-#![allow(unused_imports)]
 use crate::performance_based_algorithm::results::RewardsCalculatorResults;
 use crate::performance_based_algorithm::{DataProvider, PerformanceBasedAlgorithm};
 use crate::types::DayUtc;
@@ -52,15 +50,17 @@ impl RewardsCalculationV1 {
     }
 }
 
+#[cfg(test)]
 mod tests {
-    #![allow(dead_code)]
-    use crate::performance_based_algorithm::PerformanceBasedAlgorithm;
     use crate::performance_based_algorithm::test_utils::{
-        RewardableNode, build_daily_metrics, create_rewards_table_for_region_test,
-        generate_rewardable_nodes, test_node_id, test_subnet_id,
+        build_daily_metrics, create_rewards_table_for_region_test, generate_rewardable_nodes,
+        test_node_id, test_subnet_id,
     };
     use crate::performance_based_algorithm::v1::RewardsCalculationV1;
-    use crate::performance_based_algorithm::{AdjustedRewardsResults, BaseRewardsResults};
+    use crate::performance_based_algorithm::{
+        AdjustedRewardsResults, BaseRewardsResults, PerformanceBasedAlgorithm,
+    };
+    use crate::types::RewardableNode;
     use ic_protobuf::registry::node::v1::NodeRewardType;
     use maplit::btreemap;
     use rust_decimal_macros::dec;
diff --git a/rs/node_rewards/rewards_calculation/src/rewards_calculator/mod.rs b/rs/node_rewards/rewards_calculation/src/rewards_calculator/mod.rs
deleted file mode 100644
index 31ef7811fc..0000000000
--- a/rs/node_rewards/rewards_calculation/src/rewards_calculator/mod.rs
+++ /dev/null
@@ -1,629 +0,0 @@
-use crate::rewards_calculator_results::{
-    BaseRewards, DailyBaseRewardsType3, DailyResults, NodeMetricsDaily, NodeProviderRewards,
-    NodeResults, NodeStatus, Percent, RewardCalculatorError, RewardsCalculatorResults,
-    XDRPermyriad,
-};
-use crate::types::{
-    DayUtc, NodeMetricsDailyRaw, Region, RewardPeriod, RewardableNode, SubnetMetricsDailyKey,
-};
-use ic_base_types::{NodeId, PrincipalId, SubnetId};
-use ic_protobuf::registry::node::v1::NodeRewardType;
-use ic_protobuf::registry::node_rewards::v2::NodeRewardsTable;
-use itertools::Itertools;
-use rust_decimal::Decimal;
-use rust_decimal::prelude::ToPrimitive;
-use rust_decimal_macros::dec;
-use std::cmp::max;
-use std::collections::{BTreeMap, HashMap, HashSet};
-
-pub mod test_utils;
-
-pub struct RewardsCalculatorInput {
-    pub reward_period: RewardPeriod,
-    pub rewards_table: NodeRewardsTable,
-    pub daily_metrics_by_subnet: BTreeMap<SubnetMetricsDailyKey, Vec<NodeMetricsDailyRaw>>,
-    pub provider_rewardable_nodes: BTreeMap<PrincipalId, Vec<RewardableNode>>,
-}
-
-fn validate_input(input: &RewardsCalculatorInput) -> Result<(), RewardCalculatorError> {
-    for (key, daily_metrics) in input.daily_metrics_by_subnet.iter() {
-        // Check if all metrics are within the reward period
-        if !input.reward_period.contains(key.day) {
-            return Err(RewardCalculatorError::SubnetMetricsOutOfRange {
-                subnet_id: key.subnet_id,
-                day: key.day,
-                reward_period: input.reward_period.clone(),
-            });
-        }
-
-        // Metrics are unique if there are no duplicate entries for the same day and subnet.
-        // Metrics with the same timestamp and different subnet are allowed.
-        let unique_node = daily_metrics
-            .iter()
-            .map(|entry| entry.node_id)
-            .collect::<HashSet<_>>();
-        if unique_node.len() != daily_metrics.len() {
-            return Err(RewardCalculatorError::DuplicateMetrics(
-                key.subnet_id,
-                key.day,
-            ));
-        }
-    }
-
-    Ok(())
-}
-
-pub fn calculate_rewards(
-    input: RewardsCalculatorInput,
-) -> Result<RewardsCalculatorResults, RewardCalculatorError> {
-    validate_input(&input)?;
-    let mut results_per_provider = BTreeMap::new();
-
-    // Step 0: Pre-compute subnets and nodes failure rates
-    let Step0Results {
-        subnets_fr,
-        mut nodes_metrics_daily,
-    } = step_0_subnets_nodes_fr(input.daily_metrics_by_subnet);
-
-    for (provider_id, rewardable_nodes) in input.provider_rewardable_nodes {
-        // Step 1: Extract Provider Nodes metrics daily
-        let Step1Results {
-            provider_nodes_metrics_daily,
-        } = step_1_provider_nodes_metrics_daily(&rewardable_nodes, &mut nodes_metrics_daily);
-
-        // Step 2: Extrapolated failure rate for each provider
-        let Step2Results { extrapolated_fr } =
-            step_2_extrapolated_fr(&rewardable_nodes, &provider_nodes_metrics_daily);
-
-        // Step 3: Compute performance multiplier for each node for each provider
-        let relative_nodes_fr = provider_nodes_metrics_daily
-            .iter()
-            .map(|((day, node_id), metrics)| ((*day, *node_id), metrics.relative_fr))
-            .collect::<BTreeMap<_, _>>();
-        let Step3Results {
-            reward_reduction,
-            performance_multiplier,
-        } = step_3_performance_multiplier(&rewardable_nodes, &relative_nodes_fr, &extrapolated_fr);
-
-        // Step 4: Compute base rewards for each node based on its region and node type
-        let Step4Results {
-            base_rewards_per_node,
-            base_rewards,
-            base_rewards_type3,
-        } = step_4_compute_base_rewards_type_region(&input.rewards_table, &rewardable_nodes);
-
-        // Step 5: Adjusted rewards for all the nodes based on their performance
-        let Step5Results { adjusted_rewards } = step_5_adjust_node_rewards(
-            &rewardable_nodes,
-            &base_rewards_per_node,
-            &performance_multiplier,
-        );
-
-        // Step 6: Construct provider results
-        let provider_results = step_6_construct_provider_results(
-            rewardable_nodes,
-            provider_nodes_metrics_daily,
-            extrapolated_fr,
-            reward_reduction,
-            performance_multiplier,
-            base_rewards_per_node,
-            adjusted_rewards,
-            base_rewards,
-            base_rewards_type3,
-        );
-
-        results_per_provider.insert(provider_id, provider_results);
-    }
-
-    Ok(RewardsCalculatorResults {
-        start_day: input.reward_period.from,
-        end_day: input.reward_period.to,
-        subnets_fr,
-        provider_results: results_per_provider,
-    })
-}
-
-// ------------------------------------------------------------------------------------------------
-// Step 0: Pre-compute subnets and nodes failure rates
-// ------------------------------------------------------------------------------------------------
-
-/// The percentile used to calculate the failure rate for a subnet.
-const SUBNET_FAILURE_RATE_PERCENTILE: f64 = 0.75;
-
-#[derive(Default)]
-struct Step0Results {
-    subnets_fr: BTreeMap<(DayUtc, SubnetId), Percent>,
-    nodes_metrics_daily: BTreeMap<(DayUtc, NodeId), NodeMetricsDaily>,
-}
-fn step_0_subnets_nodes_fr(
-    daily_metrics_by_subnet: BTreeMap<SubnetMetricsDailyKey, Vec<NodeMetricsDailyRaw>>,
-) -> Step0Results {
-    fn calculate_daily_node_fr(num_blocks_proposed: u64, num_blocks_failed: u64) -> Decimal {
-        let total_blocks = Decimal::from(num_blocks_proposed + num_blocks_failed);
-        if total_blocks == Decimal::ZERO {
-            Decimal::ZERO
-        } else {
-            let num_blocks_failed = Decimal::from(num_blocks_failed);
-            num_blocks_failed / total_blocks
-        }
-    }
-
-    fn calculate_daily_subnet_fr(nodes_fr: &[Decimal]) -> Decimal {
-        let failure_rates = nodes_fr.iter().sorted().collect::<Vec<_>>();
-        let index = ((nodes_fr.len() as f64) * SUBNET_FAILURE_RATE_PERCENTILE).ceil() as usize - 1;
-        *failure_rates[index]
-    }
-
-    let mut result = Step0Results::default();
-
-    for (SubnetMetricsDailyKey { subnet_id, day }, subnet_nodes_metrics) in daily_metrics_by_subnet
-    {
-        let nodes_original_fr = subnet_nodes_metrics
-            .iter()
-            .map(|metrics| {
-                let original_fr =
-                    calculate_daily_node_fr(metrics.num_blocks_proposed, metrics.num_blocks_failed);
-                (metrics.node_id, original_fr)
-            })
-            .collect::<BTreeMap<_, _>>();
-
-        let subnet_fr =
-            calculate_daily_subnet_fr(&nodes_original_fr.values().cloned().collect::<Vec<_>>());
-        result.subnets_fr.insert((day, subnet_id), subnet_fr);
-
-        for NodeMetricsDailyRaw {
-            node_id,
-            num_blocks_proposed,
-            num_blocks_failed,
-        } in subnet_nodes_metrics
-        {
-            let original_fr = nodes_original_fr[&node_id];
-            let relative_fr = max(Decimal::ZERO, original_fr - subnet_fr);
-
-            result.nodes_metrics_daily.insert(
-                (day, node_id),
-                NodeMetricsDaily {
-                    subnet_assigned: subnet_id,
-                    subnet_assigned_fr: subnet_fr,
-                    num_blocks_proposed,
-                    num_blocks_failed,
-                    original_fr,
-                    relative_fr,
-                },
-            );
-        }
-    }
-    result
-}
-
-// ------------------------------------------------------------------------------------------------
-// Step 1: Extract Provider Nodes metrics daily
-// ------------------------------------------------------------------------------------------------
-#[derive(Default)]
-struct Step1Results {
-    provider_nodes_metrics_daily: BTreeMap<(DayUtc, NodeId), NodeMetricsDaily>,
-}
-
-fn step_1_provider_nodes_metrics_daily(
-    rewardable_nodes: &[RewardableNode],
-    node_metrics_daily: &mut BTreeMap<(DayUtc, NodeId), NodeMetricsDaily>,
-) -> Step1Results {
-    let mut provider_nodes_metrics_daily = BTreeMap::new();
-
-    for node in rewardable_nodes {
-        for day in &node.rewardable_days {
-            if let Some(metrics) = node_metrics_daily.remove(&(*day, node.node_id)) {
-                provider_nodes_metrics_daily.insert((*day, node.node_id), metrics.clone());
-            }
-        }
-    }
-
-    Step1Results {
-        provider_nodes_metrics_daily,
-    }
-}
-
-// ------------------------------------------------------------------------------------------------
-// Step 2: Extrapolated failure rate for each provider
-// ------------------------------------------------------------------------------------------------
-#[derive(Default)]
-struct Step2Results {
-    extrapolated_fr: HashMap<DayUtc, Percent>,
-}
-fn step_2_extrapolated_fr(
-    rewardable_nodes: &[RewardableNode],
-    nodes_metrics_daily: &BTreeMap<(DayUtc, NodeId), NodeMetricsDaily>,
-) -> Step2Results {
-    let mut result = Step2Results::default();
-    // Collect all relative FRs for this provider's nodes grouped by day.
-    let mut grouped_fr: BTreeMap<DayUtc, Vec<Decimal>> = BTreeMap::new();
-    for ((day, _), metrics) in nodes_metrics_daily {
-        grouped_fr
-            .entry(*day)
-            .or_default()
-            .push(metrics.relative_fr);
-    }
-
-    // Include all rewardable days even if there was no data
-    let all_rewardable_days: HashSet<DayUtc> = rewardable_nodes
-        .iter()
-        .flat_map(|n| n.rewardable_days.clone())
-        .collect();
-
-    for day in all_rewardable_days {
-        let frs = grouped_fr.remove(&day).unwrap_or_default();
-
-        // If there are no relative FRs for this day, the extrapolated FR is set to 0
-        let avg_fr = avg(&frs).unwrap_or_default();
-
-        result.extrapolated_fr.insert(day, avg_fr);
-    }
-    result
-}
-
-// ------------------------------------------------------------------------------------------------
-// Step 3: Compute performance multiplier for each node for each provider
-// ------------------------------------------------------------------------------------------------
-
-/// The minimum and maximum failure rates for a node.
-/// Nodes with a failure rate below `MIN_FAILURE_RATE` will not be penalized.
-/// Nodes with a failure rate above `MAX_FAILURE_RATE` will be penalized with `MAX_REWARDS_REDUCTION`.
-const MIN_FAILURE_RATE: Decimal = dec!(0.1);
-const MAX_FAILURE_RATE: Decimal = dec!(0.6);
-
-/// The minimum and maximum rewards reduction for a node.
-const MIN_REWARDS_REDUCTION: Decimal = dec!(0);
-const MAX_REWARDS_REDUCTION: Decimal = dec!(0.8);
-
-#[derive(Default)]
-struct Step3Results {
-    reward_reduction: HashMap<(DayUtc, NodeId), Percent>,
-    performance_multiplier: HashMap<(DayUtc, NodeId), Percent>,
-}
-fn step_3_performance_multiplier(
-    rewardable_nodes: &[RewardableNode],
-    relative_nodes_fr: &BTreeMap<(DayUtc, NodeId), Decimal>,
-    extrapolated_fr: &HashMap<DayUtc, Decimal>,
-) -> Step3Results {
-    let mut results = Step3Results::default();
-    fn calculate_rewards_reduction(fr: Decimal) -> Decimal {
-        if fr < MIN_FAILURE_RATE {
-            MIN_REWARDS_REDUCTION
-        } else if fr > MAX_FAILURE_RATE {
-            MAX_REWARDS_REDUCTION
-        } else {
-            // Linear interpolation between MIN_REWARDS_REDUCTION and MAX_REWARDS_REDUCTION
-            (fr - MIN_FAILURE_RATE) / (MAX_FAILURE_RATE - MIN_FAILURE_RATE) * MAX_REWARDS_REDUCTION
-        }
-    }
-
-    for node in rewardable_nodes {
-        for day in &node.rewardable_days {
-            let daily_fr_used;
-
-            if let Some(relative_fr) = relative_nodes_fr.get(&(*day, node.node_id)) {
-                // If the node is assigned on this day, use the relative failure rate for that day.
-                daily_fr_used = *relative_fr;
-            } else {
-                // If the node is not assigned on this day, use the extrapolated failure rate for that day.
-                daily_fr_used = *extrapolated_fr
-                    .get(day)
-                    .expect("Extrapolated FR expected for every provider");
-            }
-            let rewards_reduction = calculate_rewards_reduction(daily_fr_used);
-            let performance_multiplier = dec!(1) - rewards_reduction;
-
-            results
-                .reward_reduction
-                .insert((*day, node.node_id), rewards_reduction);
-            results
-                .performance_multiplier
-                .insert((*day, node.node_id), performance_multiplier);
-        }
-    }
-    results
-}
-
-// ------------------------------------------------------------------------------------------------
-// Step 4: Compute base rewards for each node based on its region and node type
-// ------------------------------------------------------------------------------------------------
-type RewardsCoefficientPercent = Decimal;
-
-/// From constant [NODE_PROVIDER_REWARD_PERIOD_SECONDS]
-/// const NODE_PROVIDER_REWARD_PERIOD_SECONDS: u64 = 2629800;
-/// const SECONDS_IN_DAY: u64 = 86400;
-/// 2629800 / 86400 = 30.4375 days of rewards
-const REWARDS_TABLE_DAYS: Decimal = dec!(30.4375);
-
-#[derive(Default)]
-struct Step4Results {
-    base_rewards: Vec<BaseRewards>,
-    base_rewards_type3: Vec<DailyBaseRewardsType3>,
-    base_rewards_per_node: BTreeMap<(DayUtc, NodeId), XDRPermyriad>,
-}
-fn step_4_compute_base_rewards_type_region(
-    node_rewards_table: &NodeRewardsTable,
-    rewardable_nodes: &[RewardableNode],
-) -> Step4Results {
-    fn get_monthly_rate(
-        rewards_table: &NodeRewardsTable,
-        region: &Region,
-        node_reward_type: &NodeRewardType,
-    ) -> (Decimal, RewardsCoefficientPercent) {
-        rewards_table
-            .get_rate(region, &node_reward_type.to_string())
-            .map(|rate| {
-                let base_rewards_monthly = Decimal::from(rate.xdr_permyriad_per_node_per_month);
-                // Default reward_coefficient_percent is set to 80%, which is used as a fallback only in the
-                // unlikely case that the type3 entry in the reward table:
-                // a) has xdr_permyriad_per_node_per_month entry set for this region, but
-                // b) does NOT have the reward_coefficient_percent value set
-                let reward_coefficient_percent =
-                    Decimal::from(rate.reward_coefficient_percent.unwrap_or(80)) / dec!(100);
-
-                (base_rewards_monthly, reward_coefficient_percent)
-            })
-            .unwrap_or((dec!(1), dec!(1)))
-    }
-
-    fn is_type3(node_type: &NodeRewardType) -> bool {
-        node_type == &NodeRewardType::Type3 || node_type == &NodeRewardType::Type3dot1
-    }
-
-    fn type3_region_key(region: &Region) -> String {
-        region
-            .splitn(3, ',')
-            .take(2)
-            .collect::<Vec<&str>>()
-            .join(":")
-    }
-
-    let mut base_rewards = BTreeMap::new();
-    let mut base_rewards_type3 = BTreeMap::new();
-    let mut base_rewards_per_node = BTreeMap::new();
-
-    for node in rewardable_nodes {
-        let (base_rewards_monthly, coefficient) =
-            get_monthly_rate(node_rewards_table, &node.region, &node.node_reward_type);
-        let base_rewards_daily = base_rewards_monthly / REWARDS_TABLE_DAYS;
-
-        base_rewards
-            .entry((node.node_reward_type, node.region.clone()))
-            .or_insert((base_rewards_daily, base_rewards_monthly));
-
-        // For nodes which are type3* the base rewards for the single node is computed as the average of base rewards
-        // on DC Country level. Moreover, to de-stimulate the same NP having too many nodes in the same country,
-        // the node rewards is reduced for each node the NP has in the given country. The reduction coefficient is
-        // computed as the average of reduction coefficients on DC Country level.
-        if is_type3(&node.node_reward_type) {
-            // The rewards table contains entries of this form DC Continent + DC Country + DC State/City.
-            // The grouping for type3* nodes will be on DC Continent + DC Country level. This group is used for computing
-            // the reduction coefficient and base reward for the group.
-            let region_key = type3_region_key(&node.region);
-
-            for day in &node.rewardable_days {
-                let key = (day, region_key.clone());
-
-                base_rewards_type3
-                    .entry(key)
-                    .and_modify(
-                        |(rates, coeffs): &mut (Vec<Decimal>, Vec<RewardsCoefficientPercent>)| {
-                            rates.push(base_rewards_daily);
-                            coeffs.push(coefficient);
-                        },
-                    )
-                    .or_insert((vec![base_rewards_daily], vec![coefficient]));
-            }
-        }
-    }
-
-    let base_rewards_type3 = base_rewards_type3
-        .into_iter()
-        .map(|((day, region), (rates, coeff))| {
-            let nodes_count = rates.len();
-            let avg_rate = avg(rates.as_slice()).unwrap_or_default();
-            let avg_coeff = avg(coeff.as_slice()).unwrap_or_default();
-
-            let mut running_coefficient = dec!(1);
-            let mut region_rewards = Vec::new();
-            for _ in 0..nodes_count {
-                region_rewards.push(avg_rate * running_coefficient);
-                running_coefficient *= avg_coeff;
-            }
-            let region_rewards_avg = avg(&region_rewards).unwrap_or_default();
-
-            (
-                (day, region),
-                (region_rewards_avg, nodes_count, avg_rate, avg_coeff),
-            )
-        })
-        .collect::<BTreeMap<_, _>>();
-
-    for node in rewardable_nodes {
-        for day in &node.rewardable_days {
-            let base_rewards_for_day = if is_type3(&node.node_reward_type) {
-                let region_key = type3_region_key(&node.region);
-
-                let (base_rewards_daily, _, _, _) = base_rewards_type3
-                    .get(&(day, region_key))
-                    .expect("Type3 base rewards expected for provider");
-                base_rewards_daily
-            } else {
-                let (base_rewards_daily, _) = base_rewards
-                    .get(&(node.node_reward_type, node.region.clone()))
-                    .expect("base rewards expected for each node");
-                base_rewards_daily
-            };
-
-            base_rewards_per_node.insert((*day, node.node_id), *base_rewards_for_day);
-        }
-    }
-
-    let base_rewards_type3 = base_rewards_type3
-        .into_iter()
-        .map(
-            |((day, region), (daily_rewards, nodes_count, avg_rewards, avg_coefficient))| {
-                DailyBaseRewardsType3 {
-                    day: *day,
-                    region,
-                    nodes_count,
-                    avg_rewards,
-                    avg_coefficient,
-                    value: daily_rewards,
-                }
-            },
-        )
-        .collect();
-
-    let base_rewards = base_rewards
-        .into_iter()
-        .map(
-            |((node_reward_type, region), (daily_rewards, monthly_rewards))| BaseRewards {
-                node_reward_type,
-                region,
-                monthly: monthly_rewards,
-                daily: daily_rewards,
-            },
-        )
-        .collect();
-
-    Step4Results {
-        base_rewards_per_node,
-        base_rewards_type3,
-        base_rewards,
-    }
-}
-
-// ------------------------------------------------------------------------------------------------
-// Step 5: Adjusted rewards for all the nodes based on their performance
-// ------------------------------------------------------------------------------------------------
-
-#[derive(Default)]
-struct Step5Results {
-    adjusted_rewards: BTreeMap<(DayUtc, NodeId), XDRPermyriad>,
-}
-fn step_5_adjust_node_rewards(
-    rewardable_nodes: &[RewardableNode],
-    base_rewards: &BTreeMap<(DayUtc, NodeId), Decimal>,
-    performance_multiplier: &HashMap<(DayUtc, NodeId), Decimal>,
-) -> Step5Results {
-    let mut result = Step5Results::default();
-    for node in rewardable_nodes {
-        for day in &node.rewardable_days {
-            let base_rewards_for_day = base_rewards
-                .get(&(*day, node.node_id))
-                .expect("Base rewards expected for each node");
-
-            let performance_multiplier = performance_multiplier
-                .get(&(*day, node.node_id))
-                .expect("Performance multiplier expected for every node");
-
-            let adjusted_rewards_for_day = base_rewards_for_day * performance_multiplier;
-            result
-                .adjusted_rewards
-                .insert((*day, node.node_id), adjusted_rewards_for_day);
-        }
-    }
-
-    result
-}
-
-// ------------------------------------------------------------------------------------------------
-// Step 6: Construct provider results
-// ------------------------------------------------------------------------------------------------
-fn step_6_construct_provider_results(
-    rewardable_nodes: Vec<RewardableNode>,
-    mut provider_nodes_metrics_daily: BTreeMap<(DayUtc, NodeId), NodeMetricsDaily>,
-    extrapolated_fr: HashMap<DayUtc, Percent>,
-    mut reward_reduction: HashMap<(DayUtc, NodeId), Percent>,
-    mut performance_multiplier: HashMap<(DayUtc, NodeId), Percent>,
-    mut base_rewards_per_node: BTreeMap<(DayUtc, NodeId), XDRPermyriad>,
-    mut adjusted_rewards: BTreeMap<(DayUtc, NodeId), XDRPermyriad>,
-    base_rewards: Vec<BaseRewards>,
-    base_rewards_type3: Vec<DailyBaseRewardsType3>,
-) -> NodeProviderRewards {
-    let mut results_by_node = Vec::new();
-    let mut rewards_total_xdr_permyriad = Decimal::ZERO;
-
-    for node in rewardable_nodes {
-        let node_reward_type = node.node_reward_type;
-        let region = node.region;
-        let dc_id = node.dc_id;
-        let mut daily_results = Vec::new();
-
-        for day in node.rewardable_days {
-            let node_status = if let Some(node_metrics) =
-                provider_nodes_metrics_daily.remove(&(day, node.node_id))
-            {
-                NodeStatus::Assigned { node_metrics }
-            } else {
-                let extrapolated_fr = extrapolated_fr
-                    .get(&day)
-                    .expect("Extrapolated FR expected for every provider");
-
-                NodeStatus::Unassigned {
-                    extrapolated_fr: *extrapolated_fr,
-                }
-            };
-
-            let rewards_reduction_percent = reward_reduction
-                .remove(&(day, node.node_id))
-                .expect("Rewards reduction should be present in rewards");
-
-            let performance_multiplier_percent = performance_multiplier
-                .remove(&(day, node.node_id))
-                .expect("Performance multiplier should be present in rewards");
-
-            let base_rewards_xdr_permyriad = base_rewards_per_node
-                .remove(&(day, node.node_id))
-                .expect("Base rewards should be present in rewards");
-
-            let adjusted_rewards_xdr_permyriad = adjusted_rewards
-                .remove(&(day, node.node_id))
-                .expect("Adjusted rewards should be present in rewards");
-
-            rewards_total_xdr_permyriad += adjusted_rewards_xdr_permyriad;
-
-            daily_results.push(DailyResults {
-                day,
-                node_status,
-                performance_multiplier: performance_multiplier_percent,
-                rewards_reduction: rewards_reduction_percent,
-                base_rewards: base_rewards_xdr_permyriad,
-                adjusted_rewards: adjusted_rewards_xdr_permyriad,
-            });
-        }
-
-        results_by_node.push(NodeResults {
-            node_id: node.node_id,
-            node_reward_type,
-            region,
-            dc_id,
-            daily_results,
-        });
-    }
-
-    let rewards_total_xdr_permyriad = rewards_total_xdr_permyriad.trunc().to_u64().unwrap();
-
-    NodeProviderRewards {
-        rewards_total_xdr_permyriad,
-        base_rewards,
-        base_rewards_type3,
-        nodes_results: results_by_node,
-    }
-}
-
-// ------------------------------------------------------------------------------------------------
-// Helpers
-// ------------------------------------------------------------------------------------------------
-
-fn avg(values: &[Decimal]) -> Option<Decimal> {
-    if values.is_empty() {
-        None
-    } else {
-        Some(values.iter().sum::<Decimal>() / Decimal::from(values.len()))
-    }
-}
-
-#[cfg(test)]
-pub mod tests;
diff --git a/rs/node_rewards/rewards_calculation/src/rewards_calculator/test_utils.rs b/rs/node_rewards/rewards_calculation/src/rewards_calculator/test_utils.rs
deleted file mode 100644
index 49f5a0bda0..0000000000
--- a/rs/node_rewards/rewards_calculation/src/rewards_calculator/test_utils.rs
+++ /dev/null
@@ -1,98 +0,0 @@
-use crate::types::{DayUtc, NodeMetricsDailyRaw, Region, RewardableNode, SubnetMetricsDailyKey};
-use ic_base_types::{NodeId, PrincipalId, SubnetId};
-use ic_protobuf::registry::node::v1::NodeRewardType;
-use ic_protobuf::registry::node_rewards::v2::{NodeRewardRate, NodeRewardRates, NodeRewardsTable};
-use maplit::btreemap;
-use std::collections::BTreeMap;
-
-pub fn test_node_id(id: u64) -> NodeId {
-    NodeId::from(PrincipalId::new_node_test_id(id))
-}
-
-pub fn test_provider_id(id: u64) -> PrincipalId {
-    PrincipalId::new_user_test_id(id)
-}
-
-pub fn test_subnet_id(id: u64) -> SubnetId {
-    SubnetId::from(PrincipalId::new_subnet_test_id(id))
-}
-
-impl Default for RewardableNode {
-    fn default() -> Self {
-        RewardableNode {
-            node_id: NodeId::from(PrincipalId::new_node_test_id(0)),
-            rewardable_days: vec![],
-            region: Region::default(),
-            node_reward_type: NodeRewardType::default(),
-            dc_id: "default_dc".into(),
-        }
-    }
-}
-
-pub fn build_daily_metrics(
-    subnet_id: SubnetId,
-    day: DayUtc,
-    nodes_data: &[(NodeId, u64, u64)],
-) -> (SubnetMetricsDailyKey, Vec<NodeMetricsDailyRaw>) {
-    let key = SubnetMetricsDailyKey { subnet_id, day };
-    let metrics = nodes_data
-        .iter()
-        .map(|(node_id, proposed, failed)| NodeMetricsDailyRaw {
-            node_id: *node_id,
-            num_blocks_proposed: *proposed,
-            num_blocks_failed: *failed,
-        })
-        .collect();
-    (key, metrics)
-}
-
-pub fn generate_rewardable_nodes(
-    nodes_with_rewardable_days: Vec<(NodeId, Vec<DayUtc>)>,
-) -> Vec<RewardableNode> {
-    nodes_with_rewardable_days
-        .into_iter()
-        .map(|(node_id, rewardable_days)| RewardableNode {
-            node_id,
-            rewardable_days,
-            ..Default::default()
-        })
-        .collect()
-}
-
-pub fn create_rewards_table_for_region_test() -> NodeRewardsTable {
-    let mut table = BTreeMap::new();
-    table.insert(
-        "Europe,Switzerland".to_string(),
-        NodeRewardRates {
-            rates: btreemap! {
-                NodeRewardType::Type1.to_string() => NodeRewardRate {
-                    xdr_permyriad_per_node_per_month: 304375, // -> 10000 / day
-                    reward_coefficient_percent: None,
-                },
-            },
-        },
-    );
-    table.insert(
-        "North America,USA,California".to_string(),
-        NodeRewardRates {
-            rates: btreemap! {
-                NodeRewardType::Type3.to_string() => NodeRewardRate {
-                    xdr_permyriad_per_node_per_month: 913125, // -> 30000 / day
-                    reward_coefficient_percent: Some(90),
-                },
-            },
-        },
-    );
-    table.insert(
-        "North America,USA,Nevada".to_string(),
-        NodeRewardRates {
-            rates: btreemap! {
-                NodeRewardType::Type3dot1.to_string() => NodeRewardRate {
-                    xdr_permyriad_per_node_per_month: 1217500, // -> 40000 / day
-                    reward_coefficient_percent: Some(70),
-                },
-            },
-        },
-    );
-    NodeRewardsTable { table }
-}
diff --git a/rs/node_rewards/rewards_calculation/src/rewards_calculator/tests.rs b/rs/node_rewards/rewards_calculation/src/rewards_calculator/tests.rs
deleted file mode 100644
index c588dac7ee..0000000000
--- a/rs/node_rewards/rewards_calculation/src/rewards_calculator/tests.rs
+++ /dev/null
@@ -1,356 +0,0 @@
-use super::*;
-use crate::rewards_calculator::test_utils::{
-    build_daily_metrics, create_rewards_table_for_region_test, generate_rewardable_nodes,
-    test_node_id, test_subnet_id,
-};
-use crate::types::RewardableNode;
-use maplit::{btreemap, hashmap};
-
-// ------------------------------------------------------------------------------------------------
-// Step 0: Pre-compute subnets and nodes failure rates
-// ------------------------------------------------------------------------------------------------
-#[test]
-fn test_compute_subnets_nodes_fr() {
-    let day1 = "2024-01-01".try_into().unwrap();
-    let day2 = "2024-01-02".try_into().unwrap();
-    let subnet1 = test_subnet_id(1);
-    let subnet2 = test_subnet_id(2);
-
-    // Nodes for Subnet 1
-    let s1_node1 = test_node_id(11);
-    let s1_node2 = test_node_id(12);
-    let s1_node3 = test_node_id(13);
-    let s1_node4 = test_node_id(14);
-
-    // Nodes for Subnet 2
-    let s2_node1 = test_node_id(21);
-    let s2_node2 = test_node_id(22);
-
-    // --- Data Setup ---
-    let daily_metrics_by_subnet = BTreeMap::from_iter(vec![
-        // Day 1, Subnet 1
-        build_daily_metrics(
-            subnet1,
-            day1,
-            &[
-                (s1_node1, 75, 25), // FR = 0.25
-                (s1_node2, 90, 10), // FR = 0.10
-                (s1_node3, 95, 5),  // FR = 0.05
-                (s1_node4, 50, 50), // FR = 0.50
-            ],
-        ),
-        // Day 1, Subnet 2
-        build_daily_metrics(
-            subnet2,
-            day1,
-            &[
-                (s2_node1, 80, 20), // FR = 0.20
-                (s2_node2, 60, 40), // FR = 0.40
-            ],
-        ),
-        // Day 2, Subnet 1
-        build_daily_metrics(
-            subnet1,
-            day2,
-            &[
-                (s1_node1, 99, 1), // FR = 0.01
-                (s1_node2, 0, 0),  // FR = 0.0, but not in rewardable_nodes for day2 so ignored
-            ],
-        ),
-    ]);
-
-    // --- Execution ---
-    let result = step_0_subnets_nodes_fr(daily_metrics_by_subnet);
-    let subnets_fr = result.subnets_fr;
-    let original_nodes_fr: BTreeMap<_, _> = result
-        .nodes_metrics_daily
-        .iter()
-        .map(|(k, v)| (*k, v.original_fr))
-        .collect();
-    let relative_nodes_fr: BTreeMap<_, _> = result
-        .nodes_metrics_daily
-        .iter()
-        .map(|(k, v)| (*k, v.relative_fr))
-        .collect();
-
-    // --- Assertions for Day 1, Subnet 1 ---
-    // Sorted FRs: 0.05, 0.10, 0.25, 0.50
-    // 75th percentile index = ceil(4 * 0.75) - 1 = 2. Value is 0.25
-    let expected_subnet1_day1_fr = dec!(0.25);
-    assert_eq!(
-        subnets_fr.get(&(day1, subnet1)),
-        Some(&expected_subnet1_day1_fr)
-    );
-    assert_eq!(original_nodes_fr.get(&(day1, s1_node1)), Some(&dec!(0.25)));
-    // Relative FR = max(0, original - subnet_fr)
-    assert_eq!(relative_nodes_fr.get(&(day1, s1_node1)), Some(&dec!(0.0))); // 0.25 - 0.25 = 0
-    assert_eq!(relative_nodes_fr.get(&(day1, s1_node2)), Some(&dec!(0.0))); // 0.10 - 0.25 < 0
-    assert_eq!(relative_nodes_fr.get(&(day1, s1_node4)), Some(&dec!(0.25))); // 0.50 - 0.25 = 0.25
-
-    // --- Assertions for Day 1, Subnet 2 ---
-    // Sorted FRs: 0.20, 0.40
-    // 75th percentile index = ceil(2 * 0.75) - 1 = 1. Value is 0.40
-    let expected_subnet2_day1_fr = dec!(0.40);
-    assert_eq!(
-        subnets_fr.get(&(day1, subnet2)),
-        Some(&expected_subnet2_day1_fr)
-    );
-    assert_eq!(original_nodes_fr.get(&(day1, s2_node1)), Some(&dec!(0.20)));
-    assert_eq!(relative_nodes_fr.get(&(day1, s2_node1)), Some(&dec!(0.0))); // 0.20 - 0.40 < 0
-    assert_eq!(relative_nodes_fr.get(&(day1, s2_node2)), Some(&dec!(0.0))); // 0.40 - 0.40 = 0
-
-    // --- Assertions for Day 2, Subnet 1 ---
-    // Sorted FRs: 0.0, 0.01
-    // 75th percentile index = ceil(2 * 0.75) - 1 = 1. Value is 0.01
-    let expected_subnet1_day2_fr = dec!(0.01);
-    assert_eq!(
-        subnets_fr.get(&(day2, subnet1)),
-        Some(&expected_subnet1_day2_fr)
-    );
-    assert_eq!(original_nodes_fr.get(&(day2, s1_node1)), Some(&dec!(0.01)));
-    assert_eq!(relative_nodes_fr.get(&(day2, s1_node1)), Some(&dec!(0.0))); // 0.01 - 0.01 = 0
-}
-
-// ------------------------------------------------------------------------------------------------
-// Step 2: Extrapolated failure rate for each provider
-// ------------------------------------------------------------------------------------------------
-
-impl Default for NodeMetricsDaily {
-    fn default() -> Self {
-        Self {
-            subnet_assigned: test_subnet_id(0),
-            subnet_assigned_fr: dec!(0.0),
-            num_blocks_proposed: 0,
-            num_blocks_failed: 0,
-            original_fr: dec!(0.0),
-            relative_fr: dec!(0.0),
-        }
-    }
-}
-
-#[test]
-fn test_compute_providers_extrapolated_fr() {
-    let day = "2024-01-01".try_into().unwrap();
-    let p1_node1 = test_node_id(1);
-    let p2_node1 = test_node_id(2);
-    let p2_node2 = test_node_id(3);
-
-    // --- P1 Data: No nodes with metrics ---
-    let p1_nodes = generate_rewardable_nodes(vec![(p1_node1, vec![day])]);
-    let p1_metrics = BTreeMap::new(); // No metrics available
-    let result_p1 = step_2_extrapolated_fr(&p1_nodes, &p1_metrics);
-    // Extrapolated FR for P1 should be 0 since no nodes are assigned
-    assert_eq!(result_p1.extrapolated_fr.get(&day), Some(&Decimal::ZERO));
-
-    // --- P2 Data: Two nodes with metrics ---
-    let p2_nodes = generate_rewardable_nodes(vec![(p2_node1, vec![day]), (p2_node2, vec![day])]);
-    let p2_metrics = btreemap! {
-        (day, p2_node1) => NodeMetricsDaily { relative_fr: dec!(0.2), ..Default::default() },
-        (day, p2_node2) => NodeMetricsDaily { relative_fr: dec!(0.4), ..Default::default() },
-    };
-    let result_p2 = step_2_extrapolated_fr(&p2_nodes, &p2_metrics);
-    // Extrapolated FR for P2 should be the average of its nodes' relative FR
-    let expected_fr_p2 = (dec!(0.2) + dec!(0.4)) / dec!(2); // 0.3
-    assert_eq!(result_p2.extrapolated_fr.get(&day), Some(&expected_fr_p2));
-}
-
-// ------------------------------------------------------------------------------------------------
-// Step 3: Compute performance multiplier for each node for each provider
-// ------------------------------------------------------------------------------------------------
-#[test]
-fn test_compute_nodes_performance_multiplier() {
-    let day = "2024-01-01".try_into().unwrap();
-    let node_good = test_node_id(1); // FR below threshold
-    let node_mid = test_node_id(2); // FR in penalty zone
-    let node_bad = test_node_id(3); // FR above threshold
-    let node_unassigned = test_node_id(4); // Uses extrapolated FR
-
-    // --- Data Setup ---
-    let rewardable_nodes = generate_rewardable_nodes(vec![
-        (node_good, vec![day]),
-        (node_mid, vec![day]),
-        (node_bad, vec![day]),
-        (node_unassigned, vec![day]),
-    ]);
-
-    // Assigned nodes' relative FR
-    let relative_nodes_fr = btreemap! {
-        (day, node_good) => dec!(0.05), // < 0.1
-        (day, node_mid) => dec!(0.35), // (0.35-0.1)/(0.6-0.1)*0.8 = 0.4
-        (day, node_bad) => dec!(0.7),  // > 0.6
-    };
-    // Unassigned nodes use extrapolated FR
-    let extrapolated_fr = hashmap! {
-        day => dec!(0.35)
-    };
-
-    // --- Execution ---
-    let result =
-        step_3_performance_multiplier(&rewardable_nodes, &relative_nodes_fr, &extrapolated_fr);
-    let reward_reduction = result.reward_reduction;
-    let performance_multiplier = result.performance_multiplier;
-
-    // --- Assertions ---
-    // Good node: reduction = 0, multiplier = 1
-    assert_eq!(
-        reward_reduction.get(&(day, node_good)),
-        Some(&MIN_REWARDS_REDUCTION)
-    );
-    assert_eq!(
-        performance_multiplier.get(&(day, node_good)),
-        Some(&dec!(1.0))
-    );
-
-    // Mid node: reduction = 0.4, multiplier = 0.6
-    assert_eq!(reward_reduction.get(&(day, node_mid)), Some(&dec!(0.4)));
-    assert_eq!(
-        performance_multiplier.get(&(day, node_mid)),
-        Some(&dec!(0.6))
-    );
-
-    // Bad node: reduction = 0.8, multiplier = 0.2
-    assert_eq!(
-        reward_reduction.get(&(day, node_bad)),
-        Some(&MAX_REWARDS_REDUCTION)
-    );
-    assert_eq!(
-        performance_multiplier.get(&(day, node_bad)),
-        Some(&dec!(0.2))
-    );
-
-    // Unassigned node (uses extrapolated FR, same as mid)
-    assert_eq!(
-        performance_multiplier.get(&(day, node_unassigned)),
-        Some(&dec!(0.6))
-    );
-}
-
-// ------------------------------------------------------------------------------------------------
-// Step 4: Compute base rewards for each node based on its region and node type
-// ------------------------------------------------------------------------------------------------
-
-#[test]
-fn test_compute_base_rewards() {
-    let day = "2024-01-01".try_into().unwrap();
-    let type1_node = test_node_id(1);
-    let type3_node_ca = test_node_id(2);
-    let type3_node_nv = test_node_id(3);
-
-    let rewardable_nodes = vec![
-        RewardableNode {
-            node_id: type1_node,
-            node_reward_type: NodeRewardType::Type1,
-            region: "Europe,Switzerland".into(),
-            rewardable_days: vec![day],
-            dc_id: "dc1".into(),
-        },
-        RewardableNode {
-            node_id: type3_node_ca,
-            node_reward_type: NodeRewardType::Type3,
-            region: "North America,USA,California".into(),
-            rewardable_days: vec![day],
-            dc_id: "dc2".into(),
-        },
-        RewardableNode {
-            node_id: type3_node_nv,
-            node_reward_type: NodeRewardType::Type3dot1,
-            region: "North America,USA,Nevada".into(),
-            rewardable_days: vec![day],
-            dc_id: "dc3".into(),
-        },
-    ];
-    let rewards_table = create_rewards_table_for_region_test();
-
-    // --- Execution ---
-    let Step4Results {
-        base_rewards_per_node,
-        ..
-    } = step_4_compute_base_rewards_type_region(&rewards_table, &rewardable_nodes);
-
-    // --- Assertions ---
-    assert_eq!(
-        base_rewards_per_node.get(&(day, type1_node)),
-        Some(&dec!(10000))
-    );
-    assert_eq!(
-        base_rewards_per_node.get(&(day, type3_node_ca)),
-        Some(&dec!(31500))
-    );
-    assert_eq!(
-        base_rewards_per_node.get(&(day, type3_node_nv)),
-        Some(&dec!(31500))
-    );
-}
-
-// ------------------------------------------------------------------------------------------------
-// Step 5: Adjust nodes rewards based on performance and number of nodes
-// ------------------------------------------------------------------------------------------------
-#[test]
-fn test_adjust_nodes_rewards() {
-    let day1 = "2024-01-01".try_into().unwrap();
-    let day2 = "2024-01-02".try_into().unwrap();
-    let day3 = "2024-01-03".try_into().unwrap();
-    let node1 = test_node_id(1);
-    let node2 = test_node_id(2);
-    let node3 = test_node_id(3);
-    let node4 = test_node_id(4);
-    let node5 = test_node_id(5);
-
-    // Day 1 has 5 nodes, Day 2 and Day 3 has 3 nodes.
-    let rewardable_nodes = generate_rewardable_nodes(vec![
-        (node1, vec![day1, day2, day3]),
-        (node2, vec![day1, day2, day3]),
-        (node3, vec![day1, day2, day3]),
-        (node4, vec![day1]),
-        (node5, vec![day1]),
-    ]);
-
-    let mut base_rewards = BTreeMap::new();
-    let mut performance_multiplier = HashMap::new();
-    for node in &rewardable_nodes {
-        for day in &node.rewardable_days {
-            base_rewards.insert((*day, node.node_id), dec!(1000));
-            if *day == day1 || *day == day2 {
-                // Assigned nodes
-                performance_multiplier.insert((*day, node.node_id), dec!(0.5));
-            } else {
-                // Unassigned nodes
-                performance_multiplier.insert((*day, node.node_id), dec!(1.0));
-            }
-        }
-    }
-
-    // --- Execution ---
-    let Step5Results { adjusted_rewards } =
-        step_5_adjust_node_rewards(&rewardable_nodes, &base_rewards, &performance_multiplier);
-
-    // --- Assertions ---
-    // Case 1: More than 4 nodes (5 on day1), penalty applies
-    let expected = dec!(1000) * dec!(0.5);
-
-    for node in &[node1, node2, node3, node4, node5] {
-        assert_eq!(
-            adjusted_rewards.get(&(day1, *node)),
-            Some(&expected),
-            "Unexpected reward for node {node:?} on day {day1:?}"
-        );
-    }
-    // Case 2: fewer than 4 nodes (3 on day2), all assigned penalty applies
-    for node in &[node1, node2, node3] {
-        assert_eq!(
-            adjusted_rewards.get(&(day2, *node)),
-            Some(&expected),
-            "Unexpected reward for node {node:?} on day {day2:?}"
-        );
-    }
-
-    let expected = dec!(1000);
-    // Case 3: fewer than 4 nodes (3 on day3), all unassigned full rewards
-    for node in &[node1, node2, node3] {
-        assert_eq!(
-            adjusted_rewards.get(&(day3, *node)),
-            Some(&expected),
-            "Unexpected reward for node {node:?} on day {day3:?}"
-        );
-    }
-}
diff --git a/rs/node_rewards/rewards_calculation/src/rewards_calculator_results.rs b/rs/node_rewards/rewards_calculation/src/rewards_calculator_results.rs
deleted file mode 100644
index 35dbfbfaa1..0000000000
--- a/rs/node_rewards/rewards_calculation/src/rewards_calculator_results.rs
+++ /dev/null
@@ -1,148 +0,0 @@
-use crate::types::{DayUtc, Region, RewardPeriod, RewardPeriodError};
-use ic_base_types::{NodeId, PrincipalId, SubnetId};
-use ic_protobuf::registry::node::v1::NodeRewardType;
-use rust_decimal::Decimal;
-use serde::{Deserialize, Serialize};
-use std::collections::BTreeMap;
-use std::fmt;
-
-pub type XDRPermyriad = Decimal;
-pub type Percent = Decimal;
-
-#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
-pub struct NodeMetricsDaily {
-    pub subnet_assigned: SubnetId,
-    pub subnet_assigned_fr: Percent,
-    pub num_blocks_proposed: u64,
-    pub num_blocks_failed: u64,
-    /// The failure rate before subnet failure rate reduction.
-    /// Calculated as `blocks_failed` / (`blocks_proposed` + `blocks_failed`)
-    pub original_fr: Percent,
-    /// The failure rate reduced by the subnet assigned failure rate.
-    /// Calculated as Max(0, `original_fr` - `subnet_assigned_fr`)
-    pub relative_fr: Percent,
-}
-
-#[derive(Serialize, Deserialize, Debug, PartialEq, Clone)]
-pub enum NodeStatus {
-    Assigned { node_metrics: NodeMetricsDaily },
-    Unassigned { extrapolated_fr: Percent },
-}
-
-#[derive(Serialize, Deserialize, Debug, PartialEq, Clone)]
-pub struct DailyResults {
-    pub day: DayUtc,
-    pub node_status: NodeStatus,
-    pub performance_multiplier: Percent,
-    pub rewards_reduction: Percent,
-    pub base_rewards: XDRPermyriad,
-    pub adjusted_rewards: XDRPermyriad,
-}
-
-#[derive(Serialize, Deserialize, Debug, PartialEq, Clone)]
-pub struct NodeResults {
-    pub node_id: NodeId,
-    pub node_reward_type: NodeRewardType,
-    pub region: String,
-    pub dc_id: String,
-    pub daily_results: Vec<DailyResults>,
-}
-
-#[derive(Serialize, Deserialize, Debug, PartialEq, Clone)]
-pub struct BaseRewards {
-    pub node_reward_type: NodeRewardType,
-    pub region: Region,
-    pub monthly: XDRPermyriad,
-    pub daily: XDRPermyriad,
-}
-
-#[derive(Serialize, Deserialize, Debug, PartialEq, Clone)]
-pub struct DailyBaseRewardsType3 {
-    pub day: DayUtc,
-    pub region: Region,
-    pub nodes_count: usize,
-    pub avg_rewards: XDRPermyriad,
-    pub avg_coefficient: Percent,
-    pub value: XDRPermyriad,
-}
-
-#[derive(Serialize, Deserialize, Debug, PartialEq, Clone)]
-pub struct NodeProviderRewards {
-    pub rewards_total_xdr_permyriad: u64,
-    pub base_rewards: Vec<BaseRewards>,
-    pub base_rewards_type3: Vec<DailyBaseRewardsType3>,
-    pub nodes_results: Vec<NodeResults>,
-}
-
-pub struct RewardsCalculatorResults {
-    pub start_day: DayUtc,
-    pub end_day: DayUtc,
-    pub subnets_fr: BTreeMap<(DayUtc, SubnetId), Percent>,
-    pub provider_results: BTreeMap<PrincipalId, NodeProviderRewards>,
-}
-
-#[derive(Debug, PartialEq)]
-pub enum RewardCalculatorError {
-    RewardPeriodError(RewardPeriodError),
-    EmptyMetrics,
-    SubnetMetricsOutOfRange {
-        subnet_id: SubnetId,
-        day: DayUtc,
-        reward_period: RewardPeriod,
-    },
-    DuplicateMetrics(SubnetId, DayUtc),
-    ProviderNotFound(PrincipalId),
-    NodeNotInRewardables(NodeId),
-    RewardableNodeOutOfRange(NodeId),
-}
-
-impl From<RewardPeriodError> for RewardCalculatorError {
-    fn from(err: RewardPeriodError) -> Self {
-        RewardCalculatorError::RewardPeriodError(err)
-    }
-}
-
-impl std::error::Error for RewardCalculatorError {}
-
-impl fmt::Display for RewardCalculatorError {
-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
-        match self {
-            RewardCalculatorError::EmptyMetrics => {
-                write!(f, "No daily_metrics_by_node")
-            }
-            RewardCalculatorError::SubnetMetricsOutOfRange {
-                subnet_id,
-                day,
-                reward_period,
-            } => {
-                write!(
-                    f,
-                    "Node {} has metrics outside the reward period: timestamp: {} not in {}",
-                    subnet_id,
-                    day.get(),
-                    reward_period
-                )
-            }
-            RewardCalculatorError::DuplicateMetrics(subnet_id, day) => {
-                write!(
-                    f,
-                    "Subnet {} has multiple metrics for the same node at ts {}",
-                    subnet_id,
-                    day.unix_ts_at_day_end()
-                )
-            }
-            RewardCalculatorError::RewardPeriodError(err) => {
-                write!(f, "Reward period error: {err}")
-            }
-            RewardCalculatorError::ProviderNotFound(provider_id) => {
-                write!(f, "Node Provider: {provider_id} not found")
-            }
-            RewardCalculatorError::NodeNotInRewardables(node_id) => {
-                write!(f, "Node: {node_id} has metrics but is not rewardable")
-            }
-            RewardCalculatorError::RewardableNodeOutOfRange(node_id) => {
-                write!(f, "Node: {node_id} is not rewardable in the reward period")
-            }
-        }
-    }
-}
diff --git a/rs/node_rewards/rewards_calculation/src/types.rs b/rs/node_rewards/rewards_calculation/src/types.rs
index 61159260b0..0eec8c16e3 100644
--- a/rs/node_rewards/rewards_calculation/src/types.rs
+++ b/rs/node_rewards/rewards_calculation/src/types.rs
@@ -1,15 +1,12 @@
 use chrono::{DateTime, NaiveDateTime, ParseError, Utc};
-use ic_base_types::{NodeId, SubnetId};
+use ic_base_types::NodeId;
 use ic_protobuf::registry::node::v1::NodeRewardType;
-use ic_types::Time;
 use serde::{Deserialize, Serialize};
-use std::error::Error;
 use std::fmt;
 use std::fmt::Display;
 
 pub type UnixTsNanos = u64;
 pub type NodesCount = u64;
-
 pub type Region = String;
 
 const NANOS_PER_DAY: UnixTsNanos = 24 * 60 * 60 * 1_000_000_000;
@@ -19,6 +16,17 @@ pub struct DayUtc {
     value: UnixTsNanos,
 }
 
+impl Display for DayUtc {
+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+        let dd_mm_yyyy =
+            DateTime::from_timestamp_nanos(self.unix_ts_at_day_end_nanoseconds() as i64)
+                .naive_utc()
+                .format("%d-%m-%Y")
+                .to_string();
+        write!(f, "{}", dd_mm_yyyy)
+    }
+}
+
 impl From<UnixTsNanos> for DayUtc {
     fn from(value: UnixTsNanos) -> Self {
         let day_end = ((value / NANOS_PER_DAY) + 1) * NANOS_PER_DAY - 1;
@@ -30,7 +38,7 @@ impl TryFrom<&str> for DayUtc {
     type Error = ParseError;
 
     fn try_from(value: &str) -> Result<Self, Self::Error> {
-        let dt = format!("{value} 00:00:00");
+        let dt = format!("{} 00:00:00", value);
         let naive = NaiveDateTime::parse_from_str(&dt, "%Y-%m-%d %H:%M:%S")?;
         let datetime: DateTime<Utc> = DateTime::from_naive_utc_and_offset(naive, Utc);
         let ts = datetime.timestamp_nanos_opt().unwrap() as u64;
@@ -45,19 +53,8 @@ impl Default for DayUtc {
     }
 }
 
-impl Display for DayUtc {
-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
-        let dd_mm_yyyy = DateTime::from_timestamp_nanos(self.unix_ts_at_day_end() as i64)
-            .naive_utc()
-            .format("%d-%m-%Y")
-            .to_string();
-
-        write!(f, "{dd_mm_yyyy}")
-    }
-}
-
 impl DayUtc {
-    pub fn unix_ts_at_day_end(&self) -> UnixTsNanos {
+    pub fn unix_ts_at_day_end_nanoseconds(&self) -> UnixTsNanos {
         self.value
     }
 
@@ -65,10 +62,14 @@ impl DayUtc {
         self.value
     }
 
-    pub fn unix_ts_at_day_start(&self) -> UnixTsNanos {
+    pub fn unix_ts_at_day_start_nanoseconds(&self) -> UnixTsNanos {
         (self.value / NANOS_PER_DAY) * NANOS_PER_DAY
     }
 
+    pub fn unix_ts_at_day_end_seconds(&self) -> u64 {
+        self.unix_ts_at_day_end_nanoseconds() / 1_000_000_000
+    }
+
     pub fn next_day(&self) -> DayUtc {
         DayUtc {
             value: self.value + NANOS_PER_DAY,
@@ -101,103 +102,21 @@ impl DayUtc {
     }
 }
 
-#[cfg(target_arch = "wasm32")]
-fn current_time() -> Time {
-    let current_time = ic_cdk::api::time();
-    Time::from_nanos_since_unix_epoch(current_time)
-}
-
-#[cfg(not(any(target_arch = "wasm32")))]
-fn current_time() -> Time {
-    ic_types::time::current_time()
-}
-
-/// Reward period in which we want to reward the node providers
-///
-/// This period ensures that all `BlockmakerMetrics` collected during the reward period are included consistently
-/// with the invariant defined in [`ic_replicated_state::metadata_state::BlockmakerMetricsTimeSeries`].
-#[derive(Debug, Clone, PartialEq)]
-pub struct RewardPeriod {
-    pub from: DayUtc,
-    pub to: DayUtc,
-}
-
-impl Display for RewardPeriod {
-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
-        write!(
-            f,
-            "RewardPeriod: {} - {}",
-            self.from.unix_ts_at_day_start(),
-            self.to.unix_ts_at_day_end()
-        )
-    }
-}
-
-impl RewardPeriod {
-    pub fn new(from: DayUtc, to: DayUtc) -> Result<Self, RewardPeriodError> {
-        if from > to {
-            return Err(RewardPeriodError::FromDayUtcLaterThanToDayUtc);
-        }
-
-        // Metrics are collected at the end of the day, so we need to ensure that
-        // the end timestamp is not later than the first ts of today.
-        let today: DayUtc = current_time().as_nanos_since_unix_epoch().into();
-
-        if to >= today {
-            return Err(RewardPeriodError::ToDayUtcLaterThanToday);
-        }
-
-        Ok(Self { from, to })
-    }
-
-    pub fn contains(&self, day: DayUtc) -> bool {
-        day >= self.from && day <= self.to
-    }
-}
-
-#[derive(Debug, PartialEq)]
-pub enum RewardPeriodError {
-    FromDayUtcLaterThanToDayUtc,
-    ToDayUtcLaterThanToday,
-}
-
-impl fmt::Display for RewardPeriodError {
-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
-        match self {
-            RewardPeriodError::FromDayUtcLaterThanToDayUtc => {
-                write!(f, "FromDayUtc must be earlier or equal ToDayUtc.")
-            }
-            RewardPeriodError::ToDayUtcLaterThanToday => {
-                write!(f, "ToDayUtc must be earlier than today")
-            }
-        }
-    }
+#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
+pub struct NodeMetricsDailyRaw {
+    pub node_id: NodeId,
+    pub num_blocks_proposed: u64,
+    pub num_blocks_failed: u64,
 }
 
-impl Error for RewardPeriodError {}
-
 #[derive(Eq, Hash, PartialEq, Clone, Ord, PartialOrd, Debug)]
 pub struct RewardableNode {
     pub node_id: NodeId,
-    pub rewardable_days: Vec<DayUtc>,
     pub region: Region,
     pub node_reward_type: NodeRewardType,
     pub dc_id: String,
 }
 
-#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
-pub struct NodeMetricsDailyRaw {
-    pub node_id: NodeId,
-    pub num_blocks_proposed: u64,
-    pub num_blocks_failed: u64,
-}
-
-#[derive(Clone, Debug, Eq, PartialEq, PartialOrd, Ord, Hash)]
-pub struct SubnetMetricsDailyKey {
-    pub subnet_id: SubnetId,
-    pub day: DayUtc,
-}
-
 #[cfg(test)]
 mod tests {
     use super::*;
@@ -213,45 +132,15 @@ mod tests {
 
     #[test]
     fn test_valid_rewarding_period() {
-        let from_ts = ymdh_to_ts(2020, 1, 12, 12);
-        let end_ts = ymdh_to_ts(2020, 1, 15, 15);
-
-        let rp = RewardPeriod::new(DayUtc::from(from_ts), DayUtc::from(end_ts)).unwrap();
-        let expected_start_ts = ymdh_to_ts(2020, 1, 12, 0);
-        let expected_end_ts = ymdh_to_ts(2020, 1, 16, 0) - 1;
-        let days = rp.from.days_until(&rp.to).unwrap().len();
+        let from_day: DayUtc = ymdh_to_ts(2020, 1, 12, 0).into();
+        let to_day = (ymdh_to_ts(2020, 1, 16, 0) - 1).into();
+        let days = from_day.days_until(&to_day).unwrap().len();
 
-        assert_eq!(rp.from.unix_ts_at_day_start(), expected_start_ts);
-        assert_eq!(rp.to.unix_ts_at_day_end(), expected_end_ts);
         assert_eq!(days, 4);
 
-        let end_ts = ymdh_to_ts(2020, 1, 12, 13);
-
-        let rp = RewardPeriod::new(DayUtc::from(from_ts), DayUtc::from(end_ts)).unwrap();
-        let days = rp.from.days_until(&rp.to).unwrap().len();
+        let to_day = ymdh_to_ts(2020, 1, 12, 13).into();
+        let days = from_day.days_until(&to_day).unwrap().len();
 
         assert_eq!(days, 1);
     }
-
-    #[test]
-    fn test_error_too_recent_end_ts() {
-        let to_ts = current_time().as_nanos_since_unix_epoch();
-        let from_ts = 0;
-
-        let rp = RewardPeriod::new(DayUtc::from(from_ts), DayUtc::from(to_ts));
-        assert_eq!(rp.unwrap_err(), RewardPeriodError::ToDayUtcLaterThanToday);
-    }
-
-    #[test]
-    fn test_error_unaligned_start_ts_greater_unaligned_end_ts() {
-        let to_ts = 0;
-        let from_ts = 86499999999999;
-
-        let rp = RewardPeriod::new(DayUtc::from(from_ts), DayUtc::from(to_ts));
-
-        assert_eq!(
-            rp.unwrap_err(),
-            RewardPeriodError::FromDayUtcLaterThanToDayUtc
-        );
-    }
 }
```

---

### Commit `b9221277cd5e0dc9a2cd5af5ed7ddc9aff10e7a3`

**Author:** Nikola Milosavljevic <73236646+NikolaMilosa@users.noreply.github.com>  
**Date:** 2025-09-12  
**Message:** chore: bumping edition to 2024 (#6715)

**Files Changed:**
- `rs/node_rewards/canister/protobuf_generator/src/main.rs`
- `rs/node_rewards/canister/src/api_conversion.rs`
- `rs/node_rewards/canister/src/canister/mod.rs`
- `rs/node_rewards/canister/src/canister/test/get_node_providers_monthly_xdr_rewards.rs`
- `rs/node_rewards/canister/src/canister/test/get_node_providers_rewards.rs`
- `rs/node_rewards/canister/src/canister/test/sync_all.rs`
- `rs/node_rewards/canister/src/canister/test/test_utils.rs`
- `rs/node_rewards/canister/src/lib.rs`
- `rs/node_rewards/canister/src/main.rs`
- `rs/node_rewards/canister/src/metrics.rs`
- `rs/node_rewards/canister/src/metrics/tests.rs`
- `rs/node_rewards/canister/src/registry_querier.rs`
- `rs/node_rewards/canister/src/registry_querier/tests.rs`
- `rs/node_rewards/canister/src/telemetry.rs`
- `rs/node_rewards/canister/tests/get_node_providers_monthly_xdr_rewards.rs`
- `rs/node_rewards/rewards_calculation/src/performance_based_algorithm/mod.rs`
- `rs/node_rewards/rewards_calculation/src/performance_based_algorithm/v1.rs`
- `rs/node_rewards/rewards_calculation/src/rewards_calculator/mod.rs`
- `rs/node_rewards/rewards_calculation/src/rewards_calculator/tests.rs`
- `rs/node_rewards/rewards_calculation/src/rewards_calculator_results.rs`
- `rs/node_rewards/rewards_calculation/src/types.rs`
- `rs/registry/node_provider_rewards/src/lib.rs`
- `rs/registry/node_provider_rewards/src/logs.rs`

**Code Changes:**

```diff
commit b9221277cd5e0dc9a2cd5af5ed7ddc9aff10e7a3
Author: Nikola Milosavljevic <73236646+NikolaMilosa@users.noreply.github.com>
Date:   Fri Sep 12 22:02:32 2025 +0200

    chore: bumping edition to 2024 (#6715)
    
    This PR bumps the edition to the newest one.
    
    **NOTE**: 99% of the code is `rustfmt` + `cargo clippy ‚Äîfix` and `cargo
    fix`. 1% is some borrowchecker differences

diff --git a/rs/node_rewards/canister/protobuf_generator/src/main.rs b/rs/node_rewards/canister/protobuf_generator/src/main.rs
index 8bc35247d6..53783daaca 100644
--- a/rs/node_rewards/canister/protobuf_generator/src/main.rs
+++ b/rs/node_rewards/canister/protobuf_generator/src/main.rs
@@ -1,4 +1,4 @@
-use ic_node_rewards_protobuf_generator::{generate_prost_files, ProtoPaths};
+use ic_node_rewards_protobuf_generator::{ProtoPaths, generate_prost_files};
 use std::path::PathBuf;
 
 fn main() {
diff --git a/rs/node_rewards/canister/src/api_conversion.rs b/rs/node_rewards/canister/src/api_conversion.rs
index 6c2a12443a..a8c9ec8725 100644
--- a/rs/node_rewards/canister/src/api_conversion.rs
+++ b/rs/node_rewards/canister/src/api_conversion.rs
@@ -1,10 +1,10 @@
 use ic_node_rewards_canister_api::provider_rewards_calculation::{
-    node_status::Status as StatusCandid, Assigned as AssignedCandid,
-    BaseRewards as BaseRewardsCandid, DailyBaseRewardsType3 as DailyBaseRewardsType3Candid,
-    DailyResults as DailyResultsCandid, DayUtc as DayUtcCandid,
-    NodeMetricsDaily as NodeMetricsDailyCandid, NodeProviderRewards as NodeProviderRewardsCandid,
-    NodeResults as NodeResultsCandid, NodeStatus as NodeStatusCandid,
-    Unassigned as UnassignedCandid,
+    Assigned as AssignedCandid, BaseRewards as BaseRewardsCandid,
+    DailyBaseRewardsType3 as DailyBaseRewardsType3Candid, DailyResults as DailyResultsCandid,
+    DayUtc as DayUtcCandid, NodeMetricsDaily as NodeMetricsDailyCandid,
+    NodeProviderRewards as NodeProviderRewardsCandid, NodeResults as NodeResultsCandid,
+    NodeStatus as NodeStatusCandid, Unassigned as UnassignedCandid,
+    node_status::Status as StatusCandid,
 };
 use rewards_calculation::rewards_calculator_results::{NodeProviderRewards, NodeStatus};
 
diff --git a/rs/node_rewards/canister/src/canister/mod.rs b/rs/node_rewards/canister/src/canister/mod.rs
index c0bec07e99..62e969f73b 100644
--- a/rs/node_rewards/canister/src/canister/mod.rs
+++ b/rs/node_rewards/canister/src/canister/mod.rs
@@ -18,12 +18,12 @@ use ic_protobuf::registry::dc::v1::DataCenterRecord;
 use ic_protobuf::registry::node_operator::v1::NodeOperatorRecord;
 use ic_protobuf::registry::node_rewards::v2::NodeRewardsTable;
 use ic_registry_canister_client::{
-    get_decoded_value, CanisterRegistryClient, RegistryDataStableMemory,
+    CanisterRegistryClient, RegistryDataStableMemory, get_decoded_value,
 };
 use ic_registry_keys::{
     DATA_CENTER_KEY_PREFIX, NODE_OPERATOR_RECORD_KEY_PREFIX, NODE_REWARDS_TABLE_KEY,
 };
-use ic_registry_node_provider_rewards::{calculate_rewards_v0, RewardsPerNodeProvider};
+use ic_registry_node_provider_rewards::{RewardsPerNodeProvider, calculate_rewards_v0};
 use ic_types::RegistryVersion;
 use rewards_calculation::rewards_calculator::RewardsCalculatorInput;
 use rewards_calculation::rewards_calculator_results::RewardsCalculatorResults;
@@ -73,7 +73,7 @@ impl NodeRewardsCanister {
     pub fn get_registry_value(&self, key: String) -> Result<Option<Vec<u8>>, String> {
         self.registry_client
             .get_value(key.as_ref(), self.registry_client.get_latest_version())
-            .map_err(|e| format!("Failed to get registry value: {:?}", e))
+            .map_err(|e| format!("Failed to get registry value: {e:?}"))
     }
 
     pub async fn schedule_registry_sync(
@@ -148,10 +148,9 @@ impl NodeRewardsCanister {
             daily_metrics_by_subnet,
             provider_rewardable_nodes,
         };
-        let result = rewards_calculation::rewards_calculator::calculate_rewards(input)
-            .map_err(|e| format!("Could not calculate rewards: {e:?}"));
 
-        result
+        rewards_calculation::rewards_calculator::calculate_rewards(input)
+            .map_err(|e| format!("Could not calculate rewards: {e:?}"))
     }
 }
 
@@ -189,8 +188,7 @@ impl NodeRewardsCanister {
             registry_client.sync_registry_stored().await.map_err(|e| {
                 format!(
                     "Could not sync registry store to latest version, \
-                    please try again later: {:?}",
-                    e
+                    please try again later: {e:?}"
                 )
             })?;
 
@@ -235,8 +233,7 @@ impl NodeRewardsCanister {
             .map_err(|e| {
                 format!(
                     "Could not sync registry store to latest version, \
-                    please try again later: {:?}",
-                    e
+                    please try again later: {e:?}"
                 )
             })?;
         NodeRewardsCanister::schedule_metrics_sync(canister).await;
@@ -267,10 +264,10 @@ impl NodeRewardsCanister {
         let mut result = canister.with_borrow(|canister| {
             canister.calculate_rewards::<S>(request_inner, Some(provider_id))
         })?;
-        let node_provider_rewards = result.provider_results.remove(&provider_id).ok_or(format!(
-            "No rewards found for node provider {}",
-            provider_id
-        ))?;
+        let node_provider_rewards = result
+            .provider_results
+            .remove(&provider_id)
+            .ok_or(format!("No rewards found for node provider {provider_id}"))?;
 
         Ok(to_candid_type(node_provider_rewards))
     }
diff --git a/rs/node_rewards/canister/src/canister/test/get_node_providers_monthly_xdr_rewards.rs b/rs/node_rewards/canister/src/canister/test/get_node_providers_monthly_xdr_rewards.rs
index 0ecd48f44a..53becdff51 100644
--- a/rs/node_rewards/canister/src/canister/test/get_node_providers_monthly_xdr_rewards.rs
+++ b/rs/node_rewards/canister/src/canister/test/get_node_providers_monthly_xdr_rewards.rs
@@ -1,5 +1,5 @@
-use crate::canister::test::test_utils::{setup_thread_local_canister_for_test, CANISTER_TEST};
 use crate::canister::NodeRewardsCanister;
+use crate::canister::test::test_utils::{CANISTER_TEST, setup_thread_local_canister_for_test};
 use futures_util::FutureExt;
 use ic_nervous_system_canisters::registry::fake::FakeRegistry;
 use ic_nns_test_utils::registry::invariant_compliant_mutation;
@@ -13,7 +13,7 @@ use ic_protobuf::registry::node_rewards::v2::{
     NodeRewardRate, NodeRewardRates, NodeRewardsTable, UpdateNodeRewardsTableProposalPayload,
 };
 use ic_registry_keys::{
-    make_data_center_record_key, make_node_operator_record_key, NODE_REWARDS_TABLE_KEY,
+    NODE_REWARDS_TABLE_KEY, make_data_center_record_key, make_node_operator_record_key,
 };
 use ic_types::PrincipalId;
 use maplit::btreemap;
@@ -535,7 +535,7 @@ fn test_get_node_providers_monthly_xdr_rewards_type3() {
     let mut np2_expected_reward_ch = 0;
     let mut node_reward_ch = 22000000.0;
     for _ in 0..14 {
-        println!("node_reward CH {}", node_reward_ch);
+        println!("node_reward CH {node_reward_ch}");
         np2_expected_reward_ch += node_reward_ch as u64;
         node_reward_ch *= 0.7;
     }
@@ -561,7 +561,7 @@ fn test_get_node_providers_monthly_xdr_rewards_type3() {
     let mut np2_expected_reward_de = 0;
     let mut node_reward_de = 22000000.0;
     for _ in 0..11 {
-        println!("node_reward DE {}", node_reward_de);
+        println!("node_reward DE {node_reward_de}");
         np2_expected_reward_de += node_reward_de as u64;
         node_reward_de *= 0.7;
     }
@@ -597,7 +597,7 @@ fn test_get_node_providers_monthly_xdr_rewards_type3() {
     );
 
     for _ in 0..10 {
-        println!("node_reward CH {}", node_reward_ch);
+        println!("node_reward CH {node_reward_ch}");
         np2_expected_reward_ch += node_reward_ch as u64;
         node_reward_ch *= 0.7;
     }
diff --git a/rs/node_rewards/canister/src/canister/test/get_node_providers_rewards.rs b/rs/node_rewards/canister/src/canister/test/get_node_providers_rewards.rs
index eb3db428bf..041b326ddb 100644
--- a/rs/node_rewards/canister/src/canister/test/get_node_providers_rewards.rs
+++ b/rs/node_rewards/canister/src/canister/test/get_node_providers_rewards.rs
@@ -1,8 +1,8 @@
 use crate::api_conversion::to_candid_type;
+use crate::canister::NodeRewardsCanister;
 use crate::canister::test::test_utils::{
-    setup_thread_local_canister_for_test, TestState, CANISTER_TEST, VM,
+    CANISTER_TEST, TestState, VM, setup_thread_local_canister_for_test,
 };
-use crate::canister::NodeRewardsCanister;
 use crate::metrics::MetricsManager;
 use crate::pb::v1::{NodeMetrics, SubnetMetricsKey, SubnetMetricsValue};
 use futures_util::FutureExt;
@@ -15,8 +15,8 @@ use ic_protobuf::registry::dc::v1::DataCenterRecord;
 use ic_protobuf::registry::node::v1::{NodeRecord, NodeRewardType};
 use ic_protobuf::registry::node_operator::v1::NodeOperatorRecord;
 use ic_registry_keys::{
-    make_data_center_record_key, make_node_operator_record_key, make_node_record_key,
-    NODE_REWARDS_TABLE_KEY,
+    NODE_REWARDS_TABLE_KEY, make_data_center_record_key, make_node_operator_record_key,
+    make_node_record_key,
 };
 use ic_types::PrincipalId;
 use maplit::btreemap;
diff --git a/rs/node_rewards/canister/src/canister/test/sync_all.rs b/rs/node_rewards/canister/src/canister/test/sync_all.rs
index b51b9a4a7c..ba53d290a5 100644
--- a/rs/node_rewards/canister/src/canister/test/sync_all.rs
+++ b/rs/node_rewards/canister/src/canister/test/sync_all.rs
@@ -1,10 +1,10 @@
-use crate::canister::test::test_utils::{setup_thread_local_canister_for_test, CANISTER_TEST};
 use crate::canister::NodeRewardsCanister;
+use crate::canister::test::test_utils::{CANISTER_TEST, setup_thread_local_canister_for_test};
 use crate::metrics::tests::subnet_id;
 use futures_util::FutureExt;
 use ic_base_types::{RegistryVersion, SubnetId};
-use ic_nervous_system_canisters::registry::fake::FakeRegistry;
 use ic_nervous_system_canisters::registry::Registry;
+use ic_nervous_system_canisters::registry::fake::FakeRegistry;
 use ic_protobuf::registry::subnet::v1::SubnetListRecord;
 use ic_registry_keys::make_subnet_list_record_key;
 use std::sync::Arc;
diff --git a/rs/node_rewards/canister/src/canister/test/test_utils.rs b/rs/node_rewards/canister/src/canister/test/test_utils.rs
index 317b1fcf03..248313de41 100644
--- a/rs/node_rewards/canister/src/canister/test/test_utils.rs
+++ b/rs/node_rewards/canister/src/canister/test/test_utils.rs
@@ -7,8 +7,8 @@ use ic_management_canister_types::NodeMetricsHistoryRecord;
 use ic_nervous_system_canisters::registry::fake::FakeRegistry;
 use ic_registry_canister_client::RegistryDataStableMemory;
 use ic_registry_canister_client::{
-    test_registry_data_stable_memory_impl, StableCanisterRegistryClient, StorableRegistryKey,
-    StorableRegistryValue,
+    StableCanisterRegistryClient, StorableRegistryKey, StorableRegistryValue,
+    test_registry_data_stable_memory_impl,
 };
 use ic_stable_structures::memory_manager::{MemoryId, MemoryManager, VirtualMemory};
 use ic_stable_structures::{DefaultMemoryImpl, StableBTreeMap};
diff --git a/rs/node_rewards/canister/src/lib.rs b/rs/node_rewards/canister/src/lib.rs
index 37cb0670d6..0cf146f7ea 100644
--- a/rs/node_rewards/canister/src/lib.rs
+++ b/rs/node_rewards/canister/src/lib.rs
@@ -8,8 +8,8 @@
 use candid::Principal;
 use ic_base_types::{PrincipalId, SubnetId};
 use ic_management_canister_types::NodeMetrics;
-use ic_stable_structures::storable::Bound;
 use ic_stable_structures::Storable;
+use ic_stable_structures::storable::Bound;
 use prost::Message;
 use rewards_calculation::types::SubnetMetricsDailyKey;
 use std::borrow::Cow;
diff --git a/rs/node_rewards/canister/src/main.rs b/rs/node_rewards/canister/src/main.rs
index 9e71766aa1..525644133a 100644
--- a/rs/node_rewards/canister/src/main.rs
+++ b/rs/node_rewards/canister/src/main.rs
@@ -3,7 +3,7 @@ use ic_cdk::{init, post_upgrade, pre_upgrade, query, update};
 use ic_nervous_system_canisters::registry::RegistryCanister;
 use ic_nns_constants::GOVERNANCE_CANISTER_ID;
 use ic_node_rewards_canister::canister::NodeRewardsCanister;
-use ic_node_rewards_canister::storage::{RegistryStoreStableMemoryBorrower, METRICS_MANAGER};
+use ic_node_rewards_canister::storage::{METRICS_MANAGER, RegistryStoreStableMemoryBorrower};
 use ic_node_rewards_canister::telemetry;
 use ic_node_rewards_canister_api::monthly_rewards::{
     GetNodeProvidersMonthlyXdrRewardsRequest, GetNodeProvidersMonthlyXdrRewardsResponse,
@@ -138,7 +138,7 @@ fn get_node_provider_rewards_calculation(
 #[cfg(test)]
 mod tests {
     use super::*;
-    use candid_parser::utils::{service_equal, CandidSource};
+    use candid_parser::utils::{CandidSource, service_equal};
     #[test]
     fn test_implemented_interface_matches_declared_interface_exactly() {
         let declared_interface = CandidSource::Text(include_str!("../node-rewards-canister.did"));
diff --git a/rs/node_rewards/canister/src/metrics.rs b/rs/node_rewards/canister/src/metrics.rs
index 8d9c7a6629..3116b784ec 100644
--- a/rs/node_rewards/canister/src/metrics.rs
+++ b/rs/node_rewards/canister/src/metrics.rs
@@ -1,6 +1,6 @@
 #![allow(deprecated)]
-use crate::pb::v1::{SubnetIdKey, SubnetMetricsKey, SubnetMetricsValue};
 use crate::KeyRange;
+use crate::pb::v1::{SubnetIdKey, SubnetMetricsKey, SubnetMetricsValue};
 use async_trait::async_trait;
 use candid::Principal;
 use ic_base_types::{NodeId, SubnetId};
diff --git a/rs/node_rewards/canister/src/metrics/tests.rs b/rs/node_rewards/canister/src/metrics/tests.rs
index 5813510bfc..95ac66faf7 100644
--- a/rs/node_rewards/canister/src/metrics/tests.rs
+++ b/rs/node_rewards/canister/src/metrics/tests.rs
@@ -3,8 +3,8 @@ use crate::pb::v1::SubnetMetricsKey;
 use ic_base_types::{NodeId, PrincipalId, SubnetId};
 use ic_cdk::api::call::{CallResult, RejectionCode};
 use ic_management_canister_types::{NodeMetrics, NodeMetricsHistoryArgs, NodeMetricsHistoryRecord};
-use ic_stable_structures::memory_manager::{MemoryId, VirtualMemory};
 use ic_stable_structures::DefaultMemoryImpl;
+use ic_stable_structures::memory_manager::{MemoryId, VirtualMemory};
 use rewards_calculation::types::{DayUtc, NodeMetricsDailyRaw};
 use std::cell::RefCell;
 use std::collections::{BTreeMap, HashMap};
@@ -122,8 +122,7 @@ async fn multiple_subnets_metrics_added_correctly() {
             };
             assert!(
                 mm.subnets_metrics.borrow().get(&key).is_some(),
-                "Metrics missing for subnet {:?}",
-                subnet
+                "Metrics missing for subnet {subnet:?}"
             );
         }
     }
@@ -146,8 +145,7 @@ async fn retry_count_increments_on_failure() {
         assert_eq!(
             mm.subnets_to_retry.borrow().get(&subnet_1.into()),
             Some(retry_attempt),
-            "Retry count should be {}",
-            retry_attempt
+            "Retry count should be {retry_attempt}"
         );
     }
 }
diff --git a/rs/node_rewards/canister/src/registry_querier.rs b/rs/node_rewards/canister/src/registry_querier.rs
index 1404d61db6..18a9e474af 100644
--- a/rs/node_rewards/canister/src/registry_querier.rs
+++ b/rs/node_rewards/canister/src/registry_querier.rs
@@ -6,11 +6,11 @@ use ic_protobuf::registry::node_operator::v1::NodeOperatorRecord;
 use ic_protobuf::registry::node_rewards::v2::NodeRewardsTable;
 use ic_protobuf::registry::subnet::v1::SubnetListRecord;
 use ic_registry_canister_client::{
-    get_decoded_value, CanisterRegistryClient, RegistryDataStableMemory, StorableRegistryKey,
+    CanisterRegistryClient, RegistryDataStableMemory, StorableRegistryKey, get_decoded_value,
 };
 use ic_registry_keys::{
-    make_data_center_record_key, make_node_operator_record_key, make_subnet_list_record_key,
-    NODE_RECORD_KEY_PREFIX, NODE_REWARDS_TABLE_KEY,
+    NODE_RECORD_KEY_PREFIX, NODE_REWARDS_TABLE_KEY, make_data_center_record_key,
+    make_node_operator_record_key, make_subnet_list_record_key,
 };
 use ic_types::registry::RegistryClientError;
 use itertools::Itertools;
@@ -256,7 +256,7 @@ impl RegistryQuerier {
             version,
         )
         .map_err(|e| RegistryClientError::DecodeError {
-            error: format!("Failed to decode NodeOperatorRecord: {}", e),
+            error: format!("Failed to decode NodeOperatorRecord: {e}"),
         })?
         else {
             return Ok(None);
@@ -269,7 +269,7 @@ impl RegistryQuerier {
             version,
         )
         .map_err(|e| RegistryClientError::DecodeError {
-            error: format!("Failed to decode DataCenterRecord: {}", e),
+            error: format!("Failed to decode DataCenterRecord: {e}"),
         })?
         else {
             return Ok(None);
diff --git a/rs/node_rewards/canister/src/registry_querier/tests.rs b/rs/node_rewards/canister/src/registry_querier/tests.rs
index 698399c713..0272e7e2df 100644
--- a/rs/node_rewards/canister/src/registry_querier/tests.rs
+++ b/rs/node_rewards/canister/src/registry_querier/tests.rs
@@ -7,12 +7,12 @@ use ic_protobuf::registry::node_operator::v1::NodeOperatorRecord;
 use ic_protobuf::registry::node_rewards::v2::{NodeRewardRate, NodeRewardRates, NodeRewardsTable};
 use ic_protobuf::registry::subnet::v1::SubnetListRecord;
 use ic_registry_canister_client::{
-    test_registry_data_stable_memory_impl, RegistryDataStableMemory, StableCanisterRegistryClient,
-    StorableRegistryKey, StorableRegistryValue,
+    RegistryDataStableMemory, StableCanisterRegistryClient, StorableRegistryKey,
+    StorableRegistryValue, test_registry_data_stable_memory_impl,
 };
 use ic_registry_keys::{
-    make_subnet_list_record_key, DATA_CENTER_KEY_PREFIX, NODE_OPERATOR_RECORD_KEY_PREFIX,
-    NODE_RECORD_KEY_PREFIX, NODE_REWARDS_TABLE_KEY,
+    DATA_CENTER_KEY_PREFIX, NODE_OPERATOR_RECORD_KEY_PREFIX, NODE_RECORD_KEY_PREFIX,
+    NODE_REWARDS_TABLE_KEY, make_subnet_list_record_key,
 };
 use ic_stable_structures::memory_manager::{MemoryId, MemoryManager, VirtualMemory};
 use ic_stable_structures::{DefaultMemoryImpl, StableBTreeMap};
@@ -88,7 +88,7 @@ fn generate_node_operator_key_value(
         dc_id,
         ..NodeOperatorRecord::default()
     };
-    let key = format!("{}{}", NODE_OPERATOR_RECORD_KEY_PREFIX, principal_id);
+    let key = format!("{NODE_OPERATOR_RECORD_KEY_PREFIX}{principal_id}");
 
     (key, value)
 }
@@ -99,7 +99,7 @@ fn generate_dc_key_value(dc_id: String) -> (String, DataCenterRecord) {
         region: "A".to_string(),
         ..DataCenterRecord::default()
     };
-    let key = format!("{}{}", DATA_CENTER_KEY_PREFIX, dc_id);
+    let key = format!("{DATA_CENTER_KEY_PREFIX}{dc_id}");
 
     (key, value)
 }
@@ -165,7 +165,7 @@ fn node_rewardable_days(rewardable_nodes: &[RewardableNode], node_id: u64) -> Ve
     rewardable_nodes
         .iter()
         .find(|n| n.node_id == node_id)
-        .unwrap_or_else(|| panic!("Node {} should be present", node_id))
+        .unwrap_or_else(|| panic!("Node {node_id} should be present"))
         .clone()
         .rewardable_days
 }
@@ -394,7 +394,7 @@ fn test_node_re_registered_after_deletion() {
 
     // Re-register node_1 after it was deleted
     let node_id = PrincipalId::new_node_test_id(node_1_id);
-    let node_key = format!("{}{}", NODE_RECORD_KEY_PREFIX, node_id);
+    let node_key = format!("{NODE_RECORD_KEY_PREFIX}{node_id}");
     let node_record = NodeRecord {
         node_reward_type: Some(NodeRewardType::Type0 as i32),
         node_operator_id: PrincipalId::new_user_test_id(no_1_id).to_vec(),
@@ -499,7 +499,6 @@ fn test_node_operator_data_returns_expected_data() {
     .unwrap();
     assert!(
         data.is_none(),
-        "Data should not exist for version {} because Operator was not yet added",
-        not_yet_added_no_version
+        "Data should not exist for version {not_yet_added_no_version} because Operator was not yet added"
     );
 }
diff --git a/rs/node_rewards/canister/src/telemetry.rs b/rs/node_rewards/canister/src/telemetry.rs
index 08a508d5b9..4e85ffbcb8 100644
--- a/rs/node_rewards/canister/src/telemetry.rs
+++ b/rs/node_rewards/canister/src/telemetry.rs
@@ -71,12 +71,9 @@ static LAST_SYNC_START_HELP: &str = "Last time the sync of metrics started.  If
 static LAST_SYNC_END_HELP: &str = "Last time the sync of metrics ended (successfully or with failure).  If this metric is present but zero, the first sync during this canister's current execution has not started or finished yet, either successfully or with errors.   Else, subtracting this from the last sync start should yield a positive value if the sync ended (successfully or with errors), and a negative value if the sync is still ongoing but has not finished.";
 static LAST_SYNC_SUCCESS_HELP: &str = "Last time the sync of metrics succeeded.  If this metric is present but zero, no sync has yet succeeded during this canister's current execution.  Else, subtracting this number from last_sync_start_timestamp_seconds gives a positive time delta when the last sync succeeded, or a negative value if either the last sync failed or a sync is currently being performed.  By definition, this and last_sync_end_timestamp_seconds will be identical when the last sync succeeded.";
 static LAST_SYNC_INSTRUCTIONS_HELP: &str = "Count of instructions that the last sync incurred.  Label total is the sum total of instructions, and the other labels represent different phases.";
-static QUERY_CALL_INSTRUCTIONS_HELP: &str =
-    "Count of instructions for the query call as labeled by the method being invoked.  Query calls are exercised hourly unless stated otherwise.";
-static QUERY_CALL_SUCCESS_HELP: &str =
-    "Whether the the query call as labeled by the method being invoked was successful.  Query calls are exercised hourly unless stated otherwise.";
-static QUERY_CALL_RESPONSE_SIZE_BYTES_HELP: &str =
-    "The size in bytes of the response generated by the query call.  Query calls are exercised hourly unless stated otherwise.";
+static QUERY_CALL_INSTRUCTIONS_HELP: &str = "Count of instructions for the query call as labeled by the method being invoked.  Query calls are exercised hourly unless stated otherwise.";
+static QUERY_CALL_SUCCESS_HELP: &str = "Whether the the query call as labeled by the method being invoked was successful.  Query calls are exercised hourly unless stated otherwise.";
+static QUERY_CALL_RESPONSE_SIZE_BYTES_HELP: &str = "The size in bytes of the response generated by the query call.  Query calls are exercised hourly unless stated otherwise.";
 
 impl<'b> PrometheusMetrics<'b> {
     fn new() -> Self {
diff --git a/rs/node_rewards/canister/tests/get_node_providers_monthly_xdr_rewards.rs b/rs/node_rewards/canister/tests/get_node_providers_monthly_xdr_rewards.rs
index fb5983a549..c475ed4ceb 100644
--- a/rs/node_rewards/canister/tests/get_node_providers_monthly_xdr_rewards.rs
+++ b/rs/node_rewards/canister/tests/get_node_providers_monthly_xdr_rewards.rs
@@ -1,6 +1,6 @@
 use candid::{Encode, Principal};
-use ic_nervous_system_agent::nns::node_rewards::get_node_providers_monthly_xdr_rewards;
 use ic_nervous_system_agent::AgentFor;
+use ic_nervous_system_agent::nns::node_rewards::get_node_providers_monthly_xdr_rewards;
 use ic_nns_constants::NODE_REWARDS_CANISTER_ID;
 use ic_nns_test_utils::common::build_node_rewards_test_wasm;
 use ic_node_rewards_canister_api::monthly_rewards::GetNodeProvidersMonthlyXdrRewardsRequest;
@@ -8,9 +8,9 @@ use ic_node_rewards_canister_api::provider_rewards_calculation::{
     GetNodeProviderRewardsCalculationRequest, GetNodeProviderRewardsCalculationResponse,
 };
 use ic_types::PrincipalId;
-use pocket_ic::common::rest::{IcpFeatures, IcpFeaturesConfig};
-use pocket_ic::nonblocking::{query_candid, update_candid, PocketIc};
 use pocket_ic::PocketIcBuilder;
+use pocket_ic::common::rest::{IcpFeatures, IcpFeaturesConfig};
+use pocket_ic::nonblocking::{PocketIc, query_candid, update_candid};
 use std::time::Duration;
 
 async fn setup_env() -> PocketIc {
@@ -57,8 +57,7 @@ async fn get_node_providers_monthly_xdr_rewards_is_only_callable_by_governance()
 
     assert!(
         error.contains("Only the governance canister can call this method"),
-        "Expected error message not found, was {}",
-        error
+        "Expected error message not found, was {error}"
     );
 
     let governance_agent = pocket_ic.agent_for(ic_nns_constants::GOVERNANCE_CANISTER_ID.get());
diff --git a/rs/node_rewards/rewards_calculation/src/performance_based_algorithm/mod.rs b/rs/node_rewards/rewards_calculation/src/performance_based_algorithm/mod.rs
index 4a2b82bd5f..3977717337 100644
--- a/rs/node_rewards/rewards_calculation/src/performance_based_algorithm/mod.rs
+++ b/rs/node_rewards/rewards_calculation/src/performance_based_algorithm/mod.rs
@@ -10,8 +10,8 @@ use ic_protobuf::registry::node::v1::NodeRewardType;
 use ic_protobuf::registry::node_rewards::v2::NodeRewardsTable;
 use ic_types::Time;
 use itertools::Itertools;
-use rust_decimal::prelude::ToPrimitive;
 use rust_decimal::Decimal;
+use rust_decimal::prelude::ToPrimitive;
 use rust_decimal_macros::dec;
 use std::cmp::max;
 use std::collections::BTreeMap;
diff --git a/rs/node_rewards/rewards_calculation/src/performance_based_algorithm/v1.rs b/rs/node_rewards/rewards_calculation/src/performance_based_algorithm/v1.rs
index 06e233718f..63a9a5ccbc 100644
--- a/rs/node_rewards/rewards_calculation/src/performance_based_algorithm/v1.rs
+++ b/rs/node_rewards/rewards_calculation/src/performance_based_algorithm/v1.rs
@@ -54,12 +54,12 @@ impl RewardsCalculationV1 {
 
 mod tests {
     #![allow(dead_code)]
+    use crate::performance_based_algorithm::PerformanceBasedAlgorithm;
     use crate::performance_based_algorithm::test_utils::{
-        build_daily_metrics, create_rewards_table_for_region_test, generate_rewardable_nodes,
-        test_node_id, test_subnet_id, RewardableNode,
+        RewardableNode, build_daily_metrics, create_rewards_table_for_region_test,
+        generate_rewardable_nodes, test_node_id, test_subnet_id,
     };
     use crate::performance_based_algorithm::v1::RewardsCalculationV1;
-    use crate::performance_based_algorithm::PerformanceBasedAlgorithm;
     use crate::performance_based_algorithm::{AdjustedRewardsResults, BaseRewardsResults};
     use ic_protobuf::registry::node::v1::NodeRewardType;
     use maplit::btreemap;
diff --git a/rs/node_rewards/rewards_calculation/src/rewards_calculator/mod.rs b/rs/node_rewards/rewards_calculation/src/rewards_calculator/mod.rs
index 9a5f9d77a6..31ef7811fc 100644
--- a/rs/node_rewards/rewards_calculation/src/rewards_calculator/mod.rs
+++ b/rs/node_rewards/rewards_calculation/src/rewards_calculator/mod.rs
@@ -10,8 +10,8 @@ use ic_base_types::{NodeId, PrincipalId, SubnetId};
 use ic_protobuf::registry::node::v1::NodeRewardType;
 use ic_protobuf::registry::node_rewards::v2::NodeRewardsTable;
 use itertools::Itertools;
-use rust_decimal::prelude::ToPrimitive;
 use rust_decimal::Decimal;
+use rust_decimal::prelude::ToPrimitive;
 use rust_decimal_macros::dec;
 use std::cmp::max;
 use std::collections::{BTreeMap, HashMap, HashSet};
diff --git a/rs/node_rewards/rewards_calculation/src/rewards_calculator/tests.rs b/rs/node_rewards/rewards_calculation/src/rewards_calculator/tests.rs
index 978d4dafdd..c588dac7ee 100644
--- a/rs/node_rewards/rewards_calculation/src/rewards_calculator/tests.rs
+++ b/rs/node_rewards/rewards_calculation/src/rewards_calculator/tests.rs
@@ -332,9 +332,7 @@ fn test_adjust_nodes_rewards() {
         assert_eq!(
             adjusted_rewards.get(&(day1, *node)),
             Some(&expected),
-            "Unexpected reward for node {:?} on day {:?}",
-            node,
-            day1
+            "Unexpected reward for node {node:?} on day {day1:?}"
         );
     }
     // Case 2: fewer than 4 nodes (3 on day2), all assigned penalty applies
@@ -342,9 +340,7 @@ fn test_adjust_nodes_rewards() {
         assert_eq!(
             adjusted_rewards.get(&(day2, *node)),
             Some(&expected),
-            "Unexpected reward for node {:?} on day {:?}",
-            node,
-            day2
+            "Unexpected reward for node {node:?} on day {day2:?}"
         );
     }
 
@@ -354,9 +350,7 @@ fn test_adjust_nodes_rewards() {
         assert_eq!(
             adjusted_rewards.get(&(day3, *node)),
             Some(&expected),
-            "Unexpected reward for node {:?} on day {:?}",
-            node,
-            day3
+            "Unexpected reward for node {node:?} on day {day3:?}"
         );
     }
 }
diff --git a/rs/node_rewards/rewards_calculation/src/rewards_calculator_results.rs b/rs/node_rewards/rewards_calculation/src/rewards_calculator_results.rs
index 0440b9f4f7..35dbfbfaa1 100644
--- a/rs/node_rewards/rewards_calculation/src/rewards_calculator_results.rs
+++ b/rs/node_rewards/rewards_calculation/src/rewards_calculator_results.rs
@@ -132,20 +132,16 @@ impl fmt::Display for RewardCalculatorError {
                 )
             }
             RewardCalculatorError::RewardPeriodError(err) => {
-                write!(f, "Reward period error: {}", err)
+                write!(f, "Reward period error: {err}")
             }
             RewardCalculatorError::ProviderNotFound(provider_id) => {
-                write!(f, "Node Provider: {} not found", provider_id)
+                write!(f, "Node Provider: {provider_id} not found")
             }
             RewardCalculatorError::NodeNotInRewardables(node_id) => {
-                write!(f, "Node: {} has metrics but is not rewardable", node_id)
+                write!(f, "Node: {node_id} has metrics but is not rewardable")
             }
             RewardCalculatorError::RewardableNodeOutOfRange(node_id) => {
-                write!(
-                    f,
-                    "Node: {} is not rewardable in the reward period",
-                    node_id
-                )
+                write!(f, "Node: {node_id} is not rewardable in the reward period")
             }
         }
     }
diff --git a/rs/node_rewards/rewards_calculation/src/types.rs b/rs/node_rewards/rewards_calculation/src/types.rs
index 7ad33e89bd..61159260b0 100644
--- a/rs/node_rewards/rewards_calculation/src/types.rs
+++ b/rs/node_rewards/rewards_calculation/src/types.rs
@@ -30,7 +30,7 @@ impl TryFrom<&str> for DayUtc {
     type Error = ParseError;
 
     fn try_from(value: &str) -> Result<Self, Self::Error> {
-        let dt = format!("{} 00:00:00", value);
+        let dt = format!("{value} 00:00:00");
         let naive = NaiveDateTime::parse_from_str(&dt, "%Y-%m-%d %H:%M:%S")?;
         let datetime: DateTime<Utc> = DateTime::from_naive_utc_and_offset(naive, Utc);
         let ts = datetime.timestamp_nanos_opt().unwrap() as u64;
@@ -52,7 +52,7 @@ impl Display for DayUtc {
             .format("%d-%m-%Y")
             .to_string();
 
-        write!(f, "{}", dd_mm_yyyy)
+        write!(f, "{dd_mm_yyyy}")
     }
 }
 
diff --git a/rs/registry/node_provider_rewards/src/lib.rs b/rs/registry/node_provider_rewards/src/lib.rs
index cfbe1d52e2..0efc64b0f0 100644
--- a/rs/registry/node_provider_rewards/src/lib.rs
+++ b/rs/registry/node_provider_rewards/src/lib.rs
@@ -31,17 +31,15 @@ pub fn calculate_rewards_v0(
         let node_operator_id = PrincipalId::try_from(&node_operator.node_operator_principal_id)
             .map_err(|e| {
                 format!(
-                    "Node Operator key '{:?}' cannot be parsed as a PrincipalId: '{}'",
-                    key_string, e
+                    "Node Operator key '{key_string:?}' cannot be parsed as a PrincipalId: '{e}'"
                 )
             })?;
 
         let node_provider_id = PrincipalId::try_from(&node_operator.node_provider_principal_id)
             .map_err(|e| {
                 format!(
-                    "Node Operator with key '{}' has a node_provider_principal_id \
-                                 that cannot be parsed as a PrincipalId: '{}'",
-                    node_operator_id, e
+                    "Node Operator with key '{node_operator_id}' has a node_provider_principal_id \
+                                 that cannot be parsed as a PrincipalId: '{e}'"
                 )
             })?;
 
diff --git a/rs/registry/node_provider_rewards/src/logs.rs b/rs/registry/node_provider_rewards/src/logs.rs
index 9d90e1524a..39811537ea 100644
--- a/rs/registry/node_provider_rewards/src/logs.rs
+++ b/rs/registry/node_provider_rewards/src/logs.rs
@@ -37,8 +37,7 @@ impl std::fmt::Display for LogEntry {
                 write!(
                     f,
                     "The Node Rewards Table does not have an entry for \
-                    node type '{}' within region '{}' or parent region, defaulting to 1 xdr per month per node, for Node Operator '{}'",
-                    region, node_type, node_operator_id
+                    node type '{region}' within region '{node_type}' or parent region, defaulting to 1 xdr per month per node, for Node Operator '{node_operator_id}'"
                 )
             }
             LogEntry::NodeRewards {
@@ -49,8 +48,7 @@ impl std::fmt::Display for LogEntry {
                 rewards_xdr_permyriad,
             } => write!(
                 f,
-                "{}/{} {} node in {} DC: rewarded {}",
-                node_idx, rewardable_count, node_type, dc_id, rewards_xdr_permyriad
+                "{node_idx}/{rewardable_count} {node_type} node in {dc_id} DC: rewarded {rewards_xdr_permyriad}"
             ),
             LogEntry::DCRewards {
                 dc_id,
@@ -59,8 +57,7 @@ impl std::fmt::Display for LogEntry {
                 rewards_xdr_permyriad,
             } => write!(
                 f,
-                "Rewards for all {} {} nodes in {} DC: reward {}",
-                rewardable_count, node_type, dc_id, rewards_xdr_permyriad
+                "Rewards for all {rewardable_count} {node_type} nodes in {dc_id} DC: reward {rewards_xdr_permyriad}"
             ),
         }
     }
```

---

### Commit `0226e886d73fa5396d39d71d297e2527cb8cb43f`

**Author:** pietrodimarco-dfinity <124565147+pietrodimarco-dfinity@users.noreply.github.com>  
**Date:** 2025-09-12  
**Message:** feat(NRC): Refactor rewards calculator to compute daily rewards (#6724)

**Files Changed:**
- `rs/node_rewards/rewards_calculation/src/lib.rs`
- `rs/node_rewards/rewards_calculation/src/performance_based_algorithm/mod.rs`
- `rs/node_rewards/rewards_calculation/src/performance_based_algorithm/results.rs`
- `rs/node_rewards/rewards_calculation/src/performance_based_algorithm/test_utils.rs`
- `rs/node_rewards/rewards_calculation/src/performance_based_algorithm/v1.rs`

**Code Changes:**

```diff
commit 0226e886d73fa5396d39d71d297e2527cb8cb43f
Author: pietrodimarco-dfinity <124565147+pietrodimarco-dfinity@users.noreply.github.com>
Date:   Fri Sep 12 10:01:45 2025 +0200

    feat(NRC): Refactor rewards calculator to compute daily rewards (#6724)

diff --git a/rs/node_rewards/rewards_calculation/src/lib.rs b/rs/node_rewards/rewards_calculation/src/lib.rs
index 78c1b3dabd..f198983a33 100644
--- a/rs/node_rewards/rewards_calculation/src/lib.rs
+++ b/rs/node_rewards/rewards_calculation/src/lib.rs
@@ -1,3 +1,4 @@
+mod performance_based_algorithm;
 pub mod rewards_calculator;
 pub mod rewards_calculator_results;
 pub mod types;
diff --git a/rs/node_rewards/rewards_calculation/src/performance_based_algorithm/mod.rs b/rs/node_rewards/rewards_calculation/src/performance_based_algorithm/mod.rs
new file mode 100644
index 0000000000..4a2b82bd5f
--- /dev/null
+++ b/rs/node_rewards/rewards_calculation/src/performance_based_algorithm/mod.rs
@@ -0,0 +1,627 @@
+#![allow(dead_code)]
+use crate::performance_based_algorithm::results::{
+    BaseRewards, BaseRewardsType3, DailyResults, NodeMetricsDaily, NodeProviderRewards,
+    NodeResults, NodeStatus, Percent, RewardsCalculatorResults, XDRPermyriad,
+};
+use crate::performance_based_algorithm::test_utils::RewardableNode;
+use crate::types::{DayUtc, NodeMetricsDailyRaw, Region};
+use ic_base_types::{NodeId, PrincipalId, SubnetId};
+use ic_protobuf::registry::node::v1::NodeRewardType;
+use ic_protobuf::registry::node_rewards::v2::NodeRewardsTable;
+use ic_types::Time;
+use itertools::Itertools;
+use rust_decimal::prelude::ToPrimitive;
+use rust_decimal::Decimal;
+use rust_decimal_macros::dec;
+use std::cmp::max;
+use std::collections::BTreeMap;
+
+pub mod results;
+mod test_utils;
+pub mod v1;
+
+// ================================================================================================
+// VERSIONING SAFETY WARNING
+// ================================================================================================
+//
+// This PerformanceBasedAlgorithm trait defines the core reward calculation interface.
+//
+// The trait methods in this module should NOT be modified directly as they serve as the
+// stable API contract for all reward calculation versions. Instead, new algorithm versions
+// should be created by implementing this trait with different behavior, as demonstrated
+// by RewardsCalculationV1.
+//
+// This approach ensures:
+//
+// 1. **API Stability**: The trait interface remains consistent across versions
+// 2. **Backward Compatibility**: Existing implementations continue to work
+// 3. **Version Isolation**: Each version can have its own calculation logic
+// 4. **Historical Reproducibility**: Past calculations remain verifiable
+//
+//
+// To create a new algorithm version:
+// 1. Create a new module (e.g., v2.rs)
+// 2. Implement the PerformanceBasedAlgorithm trait
+// 3. Override only the methods that need different behavior
+// 4. Keep the same trait interface for compatibility
+// ================================================================================================
+
+#[derive(Default)]
+struct FailureRateResults {
+    subnets_fr: BTreeMap<SubnetId, Percent>,
+    nodes_metrics_daily: BTreeMap<NodeId, NodeMetricsDaily>,
+}
+
+#[derive(Default)]
+struct PerformanceMultiplierResults {
+    reward_reduction: BTreeMap<NodeId, Percent>,
+    performance_multiplier: BTreeMap<NodeId, Percent>,
+}
+
+#[derive(Default)]
+struct BaseRewardsResults {
+    base_rewards: Vec<BaseRewards>,
+    base_rewards_type3: Vec<BaseRewardsType3>,
+    base_rewards_per_node: BTreeMap<NodeId, XDRPermyriad>,
+}
+
+type RewardsCoefficientPercent = Decimal;
+
+#[derive(Default)]
+struct AdjustedRewardsResults {
+    adjusted_rewards: BTreeMap<NodeId, XDRPermyriad>,
+}
+
+#[cfg(target_arch = "wasm32")]
+fn current_time() -> Time {
+    let current_time = ic_cdk::api::time();
+    Time::from_nanos_since_unix_epoch(current_time)
+}
+
+#[cfg(not(any(target_arch = "wasm32")))]
+fn current_time() -> Time {
+    ic_types::time::current_time()
+}
+
+pub trait DataProvider {
+    fn get_rewards_table(&self, day: &DayUtc) -> Result<NodeRewardsTable, String>;
+
+    fn get_daily_metrics_by_subnet(
+        &self,
+        day: &DayUtc,
+    ) -> Result<BTreeMap<SubnetId, Vec<NodeMetricsDailyRaw>>, String>;
+
+    fn get_rewardable_nodes(
+        &self,
+        day: &DayUtc,
+    ) -> Result<BTreeMap<PrincipalId, Vec<RewardableNode>>, String>;
+
+    fn get_provider_rewardable_nodes(
+        &self,
+        day: &DayUtc,
+        provider_id: &PrincipalId,
+    ) -> Result<BTreeMap<PrincipalId, Vec<RewardableNode>>, String>;
+}
+
+trait PerformanceBasedAlgorithm {
+    /// The percentile used to calculate the failure rate for a subnet.
+    const SUBNET_FAILURE_RATE_PERCENTILE: f64;
+
+    /// The minimum and maximum failure rates for a node.
+    /// Nodes with a failure rate below `MIN_FAILURE_RATE` will not be penalized.
+    const MIN_FAILURE_RATE: Decimal;
+
+    /// The maximum failure rate for a node.
+    /// Nodes with a failure rate above `MAX_FAILURE_RATE` will be penalized with `MAX_REWARDS_REDUCTION`.
+    const MAX_FAILURE_RATE: Decimal;
+
+    /// The minimum rewards reduction for a node.
+    const MIN_REWARDS_REDUCTION: Decimal;
+
+    /// The maximum rewards reduction for a node.
+    const MAX_REWARDS_REDUCTION: Decimal;
+
+    /// From constant [NODE_PROVIDER_REWARD_PERIOD_SECONDS]
+    /// const NODE_PROVIDER_REWARD_PERIOD_SECONDS: u64 = 2629800;
+    /// const SECONDS_IN_DAY: u64 = 86400;
+    /// 2629800 / 86400 = 30.4375 days of rewards
+    const REWARDS_TABLE_DAYS: Decimal = dec!(30.4375);
+
+    fn validate_reward_period(from_day: &DayUtc, to_day: &DayUtc) -> Result<(), String> {
+        let today: DayUtc = current_time().as_nanos_since_unix_epoch().into();
+        if from_day > to_day {
+            return Err("from_day must be before to_day".to_string());
+        }
+        if to_day >= &today {
+            return Err("to_day_timestamp_nanos must be earlier than today".to_string());
+        }
+        Ok(())
+    }
+
+    fn calculate_rewards(
+        from_day: &DayUtc,
+        to_day: &DayUtc,
+        node_provider_filter: Option<PrincipalId>,
+        data_provider: impl DataProvider,
+    ) -> Result<RewardsCalculatorResults, String> {
+        Self::validate_reward_period(from_day, to_day)?;
+
+        let reward_period = from_day.days_until(to_day)?;
+        let mut total_rewards_per_provider = BTreeMap::new();
+        let mut daily_results = BTreeMap::new();
+
+        // Process each day in the reward period
+        for day in reward_period {
+            let result_for_day =
+                Self::calculate_daily_rewards(&data_provider, &day, &node_provider_filter)?;
+
+            // Accumulate total rewards per provider across all days
+            for (provider_id, provider_rewards) in &result_for_day.provider_results {
+                total_rewards_per_provider
+                    .entry(*provider_id)
+                    .and_modify(|total| *total += provider_rewards.rewards_total)
+                    .or_insert(provider_rewards.rewards_total);
+            }
+            daily_results.insert(day, result_for_day);
+        }
+
+        let total_rewards_xdr_permyriad = total_rewards_per_provider
+            .into_iter()
+            .map(|(provider_id, total)| (provider_id, total.trunc().to_u64().unwrap()))
+            .collect();
+
+        Ok(RewardsCalculatorResults {
+            total_rewards_xdr_permyriad,
+            daily_results,
+        })
+    }
+
+    fn calculate_daily_rewards(
+        data_provider: &impl DataProvider,
+        day: &DayUtc,
+        node_provider_filter: &Option<PrincipalId>,
+    ) -> Result<DailyResults, String> {
+        let rewards_table = data_provider.get_rewards_table(day)?;
+        let metrics_by_subnet = data_provider.get_daily_metrics_by_subnet(day)?;
+        let providers_rewardable_nodes = if let Some(provider_id) = node_provider_filter {
+            data_provider.get_provider_rewardable_nodes(day, provider_id)?
+        } else {
+            data_provider.get_rewardable_nodes(day)?
+        };
+        let mut results_per_provider = BTreeMap::new();
+
+        // Calculate failure rates for subnets and individual nodes
+        let FailureRateResults {
+            subnets_fr,
+            mut nodes_metrics_daily,
+        } = Self::calculate_failure_rates(metrics_by_subnet);
+
+        // Process each provider's nodes
+        for (provider_id, rewardable_nodes) in providers_rewardable_nodes {
+            let provider_results = Self::calculate_provider_rewards(
+                &rewards_table,
+                &mut nodes_metrics_daily,
+                rewardable_nodes,
+            );
+            results_per_provider.insert(provider_id, provider_results);
+        }
+
+        Ok(DailyResults {
+            subnets_fr,
+            provider_results: results_per_provider,
+        })
+    }
+
+    fn calculate_provider_rewards(
+        rewards_table: &NodeRewardsTable,
+        nodes_metrics_daily: &mut BTreeMap<NodeId, NodeMetricsDaily>,
+        rewardable_nodes: Vec<RewardableNode>,
+    ) -> NodeProviderRewards {
+        let mut provider_nodes_metrics_daily = BTreeMap::new();
+        for node in &rewardable_nodes {
+            if let Some(metrics) = nodes_metrics_daily.remove(&node.node_id) {
+                provider_nodes_metrics_daily.insert(node.node_id, metrics);
+            }
+        }
+
+        let relative_nodes_fr: BTreeMap<NodeId, Decimal> = provider_nodes_metrics_daily
+            .iter()
+            .map(|(node_id, metrics)| (*node_id, metrics.relative_fr))
+            .collect();
+
+        // Calculate extrapolated failure rate for unassigned nodes
+        // This is the average of relative failure rates for assigned nodes
+        let extrapolated_fr = if !relative_nodes_fr.is_empty() {
+            let values: Vec<Decimal> = relative_nodes_fr.values().cloned().collect();
+            avg(&values).unwrap_or_default()
+        } else {
+            Decimal::ZERO
+        };
+
+        // Calculate performance multipliers based on failure rates
+        // Assigned nodes use actual failure rate, unassigned nodes use extrapolated rate
+        let PerformanceMultiplierResults {
+            reward_reduction,
+            performance_multiplier,
+        } = Self::calculate_performance_multipliers(
+            &rewardable_nodes,
+            &relative_nodes_fr,
+            &extrapolated_fr,
+        );
+
+        // Calculate base rewards for each node based on region and node type
+        // Handles special logic for Type3 nodes (grouped by country, with reduction coefficients)
+        let BaseRewardsResults {
+            base_rewards_per_node,
+            base_rewards,
+            base_rewards_type3,
+        } = Self::calculate_base_rewards_by_region_and_type(rewards_table, &rewardable_nodes);
+
+        // Apply performance multipliers to base rewards to get final daily rewards
+        let AdjustedRewardsResults { adjusted_rewards } = Self::apply_performance_adjustments(
+            &rewardable_nodes,
+            &base_rewards_per_node,
+            &performance_multiplier,
+        );
+
+        // Combine all calculated values into the final NodeProviderRewards structure
+        Self::build_provider_rewards_summary(
+            rewardable_nodes,
+            provider_nodes_metrics_daily,
+            extrapolated_fr,
+            reward_reduction,
+            performance_multiplier,
+            base_rewards_per_node,
+            adjusted_rewards,
+            base_rewards,
+            base_rewards_type3,
+        )
+    }
+
+    // ------------------------------------------------------------------------------------------------
+    // Calculate failure rates for subnets and individual nodes
+    // ------------------------------------------------------------------------------------------------
+    fn calculate_failure_rates(
+        daily_metrics_by_subnet: BTreeMap<SubnetId, Vec<NodeMetricsDailyRaw>>,
+    ) -> FailureRateResults {
+        fn calculate_daily_node_fr(num_blocks_proposed: u64, num_blocks_failed: u64) -> Decimal {
+            let total_blocks = Decimal::from(num_blocks_proposed + num_blocks_failed);
+            if total_blocks == Decimal::ZERO {
+                Decimal::ZERO
+            } else {
+                let num_blocks_failed = Decimal::from(num_blocks_failed);
+                num_blocks_failed / total_blocks
+            }
+        }
+
+        let mut result = FailureRateResults::default();
+
+        for (subnet_id, subnet_nodes_metrics) in daily_metrics_by_subnet {
+            let nodes_original_fr = subnet_nodes_metrics
+                .iter()
+                .map(|metrics| {
+                    let original_fr = calculate_daily_node_fr(
+                        metrics.num_blocks_proposed,
+                        metrics.num_blocks_failed,
+                    );
+                    (metrics.node_id, original_fr)
+                })
+                .collect::<BTreeMap<_, _>>();
+            let nodes_fr = nodes_original_fr.values().cloned().collect::<Vec<_>>();
+            let failure_rates = nodes_fr.iter().sorted().collect::<Vec<_>>();
+            let index = ((nodes_fr.len() as f64) * Self::SUBNET_FAILURE_RATE_PERCENTILE).ceil()
+                as usize
+                - 1;
+            let subnet_fr = *failure_rates[index];
+            result.subnets_fr.insert(subnet_id, subnet_fr);
+
+            for NodeMetricsDailyRaw {
+                node_id,
+                num_blocks_proposed,
+                num_blocks_failed,
+            } in subnet_nodes_metrics
+            {
+                let original_fr = nodes_original_fr[&node_id];
+                let relative_fr = max(Decimal::ZERO, original_fr - subnet_fr);
+
+                result.nodes_metrics_daily.insert(
+                    node_id,
+                    NodeMetricsDaily {
+                        subnet_assigned: subnet_id,
+                        subnet_assigned_fr: subnet_fr,
+                        num_blocks_proposed,
+                        num_blocks_failed,
+                        original_fr,
+                        relative_fr,
+                    },
+                );
+            }
+        }
+        result
+    }
+
+    fn calculate_performance_multipliers(
+        rewardable_nodes: &[RewardableNode],
+        relative_nodes_fr: &BTreeMap<NodeId, Decimal>,
+        extrapolated_fr: &Decimal,
+    ) -> PerformanceMultiplierResults {
+        let mut reward_reduction = BTreeMap::new();
+        let mut performance_multiplier = BTreeMap::new();
+
+        let calculate_rewards_reduction = |fr: Decimal| -> Decimal {
+            if fr < Self::MIN_FAILURE_RATE {
+                Self::MIN_REWARDS_REDUCTION
+            } else if fr > Self::MAX_FAILURE_RATE {
+                Self::MAX_REWARDS_REDUCTION
+            } else {
+                // Linear interpolation between MIN_REWARDS_REDUCTION and MAX_REWARDS_REDUCTION
+                (fr - Self::MIN_FAILURE_RATE) / (Self::MAX_FAILURE_RATE - Self::MIN_FAILURE_RATE)
+                    * Self::MAX_REWARDS_REDUCTION
+            }
+        };
+
+        for node in rewardable_nodes {
+            let daily_fr_used = relative_nodes_fr
+                .get(&node.node_id)
+                .copied()
+                .unwrap_or(*extrapolated_fr);
+
+            let rewards_reduction = calculate_rewards_reduction(daily_fr_used);
+            let performance_mult = dec!(1) - rewards_reduction;
+
+            reward_reduction.insert(node.node_id, rewards_reduction);
+            performance_multiplier.insert(node.node_id, performance_mult);
+        }
+
+        PerformanceMultiplierResults {
+            reward_reduction,
+            performance_multiplier,
+        }
+    }
+
+    // ------------------------------------------------------------------------------------------------
+    // Calculate base rewards for each node based on region and node type
+    // ------------------------------------------------------------------------------------------------
+    fn calculate_base_rewards_by_region_and_type(
+        node_rewards_table: &NodeRewardsTable,
+        rewardable_nodes: &[RewardableNode],
+    ) -> BaseRewardsResults {
+        fn get_monthly_rate(
+            rewards_table: &NodeRewardsTable,
+            region: &Region,
+            node_reward_type: &NodeRewardType,
+        ) -> (Decimal, RewardsCoefficientPercent) {
+            rewards_table
+                .get_rate(region, &node_reward_type.to_string())
+                .map(|rate| {
+                    let base_rewards_monthly = Decimal::from(rate.xdr_permyriad_per_node_per_month);
+                    // Default reward_coefficient_percent is set to 80%, which is used as a fallback only in the
+                    // unlikely case that the type3 entry in the reward table:
+                    // a) has xdr_permyriad_per_node_per_month entry set for this region, but
+                    // b) does NOT have the reward_coefficient_percent value set
+                    let reward_coefficient_percent =
+                        Decimal::from(rate.reward_coefficient_percent.unwrap_or(80)) / dec!(100);
+
+                    (base_rewards_monthly, reward_coefficient_percent)
+                })
+                .unwrap_or((dec!(1), dec!(1)))
+        }
+
+        fn is_type3(node_type: &NodeRewardType) -> bool {
+            node_type == &NodeRewardType::Type3 || node_type == &NodeRewardType::Type3dot1
+        }
+
+        fn type3_region_key(region: &Region) -> String {
+            region
+                .splitn(3, ',')
+                .take(2)
+                .collect::<Vec<&str>>()
+                .join(":")
+        }
+
+        let mut base_rewards = BTreeMap::new();
+        let mut base_rewards_type3 = BTreeMap::new();
+        let mut base_rewards_per_node = BTreeMap::new();
+
+        for node in rewardable_nodes {
+            let (base_rewards_monthly, coefficient) =
+                get_monthly_rate(node_rewards_table, &node.region, &node.node_reward_type);
+            let base_rewards_daily = base_rewards_monthly / Self::REWARDS_TABLE_DAYS;
+
+            base_rewards
+                .entry((node.node_reward_type, node.region.clone()))
+                .or_insert((base_rewards_daily, base_rewards_monthly));
+
+            // For nodes which are type3* the base rewards for the single node is computed as the average of base rewards
+            // on DC Country level. Moreover, to de-stimulate the same NP having too many nodes in the same country,
+            // the node rewards is reduced for each node the NP has in the given country. The reduction coefficient is
+            // computed as the average of reduction coefficients on DC Country level.
+            if is_type3(&node.node_reward_type) {
+                // The rewards table contains entries of this form DC Continent + DC Country + DC State/City.
+                // The grouping for type3* nodes will be on DC Continent + DC Country level. This group is used for computing
+                // the reduction coefficient and base reward for the group.
+                let region_key = type3_region_key(&node.region);
+
+                base_rewards_type3
+                    .entry(region_key.clone())
+                    .and_modify(
+                        |(rates, coeffs): &mut (Vec<Decimal>, Vec<RewardsCoefficientPercent>)| {
+                            rates.push(base_rewards_daily);
+                            coeffs.push(coefficient);
+                        },
+                    )
+                    .or_insert((vec![base_rewards_daily], vec![coefficient]));
+            }
+        }
+
+        let base_rewards_type3 = base_rewards_type3
+            .into_iter()
+            .map(|(region, (rates, coeff))| {
+                let nodes_count = rates.len();
+                let avg_rate = avg(rates.as_slice()).unwrap_or_default();
+                let avg_coeff = avg(coeff.as_slice()).unwrap_or_default();
+
+                let mut running_coefficient = dec!(1);
+                let mut region_rewards = Vec::new();
+                for _ in 0..nodes_count {
+                    region_rewards.push(avg_rate * running_coefficient);
+                    running_coefficient *= avg_coeff;
+                }
+                let region_rewards_avg = avg(&region_rewards).unwrap_or_default();
+
+                (
+                    region,
+                    (region_rewards_avg, nodes_count, avg_rate, avg_coeff),
+                )
+            })
+            .collect::<BTreeMap<_, _>>();
+
+        for node in rewardable_nodes {
+            let base_rewards_for_day = if is_type3(&node.node_reward_type) {
+                let region_key = type3_region_key(&node.region);
+
+                let (base_rewards_daily, _, _, _) = base_rewards_type3
+                    .get(&region_key)
+                    .expect("Type3 base rewards expected for provider");
+                base_rewards_daily
+            } else {
+                let (base_rewards_daily, _) = base_rewards
+                    .get(&(node.node_reward_type, node.region.clone()))
+                    .expect("base rewards expected for each node");
+                base_rewards_daily
+            };
+
+            base_rewards_per_node.insert(node.node_id, *base_rewards_for_day);
+        }
+
+        let base_rewards_type3 = base_rewards_type3
+            .into_iter()
+            .map(
+                |(region, (daily_rewards, nodes_count, avg_rewards, avg_coefficient))| {
+                    BaseRewardsType3 {
+                        region,
+                        nodes_count,
+                        avg_rewards,
+                        avg_coefficient,
+                        value: daily_rewards,
+                    }
+                },
+            )
+            .collect();
+
+        let base_rewards = base_rewards
+            .into_iter()
+            .map(
+                |((node_reward_type, region), (daily_rewards, monthly_rewards))| BaseRewards {
+                    node_reward_type,
+                    region,
+                    monthly: monthly_rewards,
+                    daily: daily_rewards,
+                },
+            )
+            .collect();
+
+        BaseRewardsResults {
+            base_rewards_per_node,
+            base_rewards_type3,
+            base_rewards,
+        }
+    }
+
+    fn apply_performance_adjustments(
+        rewardable_nodes: &[RewardableNode],
+        base_rewards: &BTreeMap<NodeId, Decimal>,
+        performance_multiplier: &BTreeMap<NodeId, Decimal>,
+    ) -> AdjustedRewardsResults {
+        let mut adjusted_rewards = BTreeMap::new();
+
+        for node in rewardable_nodes {
+            let base_rewards_for_day = base_rewards
+                .get(&node.node_id)
+                .expect("Base rewards expected for each node");
+
+            let performance_mult = performance_multiplier
+                .get(&node.node_id)
+                .expect("Performance multiplier expected for every node");
+
+            let adjusted_rewards_for_day = base_rewards_for_day * performance_mult;
+            adjusted_rewards.insert(node.node_id, adjusted_rewards_for_day);
+        }
+
+        AdjustedRewardsResults { adjusted_rewards }
+    }
+
+    /// Build provider rewards summary using BTreeMap for consistency and better performance
+    fn build_provider_rewards_summary(
+        rewardable_nodes: Vec<RewardableNode>,
+        mut provider_nodes_metrics_daily: BTreeMap<NodeId, NodeMetricsDaily>,
+        extrapolated_fr: Percent,
+        mut reward_reduction: BTreeMap<NodeId, Percent>,
+        mut performance_multiplier: BTreeMap<NodeId, Percent>,
+        mut base_rewards_per_node: BTreeMap<NodeId, XDRPermyriad>,
+        mut adjusted_rewards: BTreeMap<NodeId, XDRPermyriad>,
+        base_rewards: Vec<BaseRewards>,
+        base_rewards_type3: Vec<BaseRewardsType3>,
+    ) -> NodeProviderRewards {
+        let mut results_by_node = Vec::new();
+        let mut rewards_total = Decimal::ZERO;
+
+        for node in rewardable_nodes {
+            let node_status =
+                if let Some(node_metrics) = provider_nodes_metrics_daily.remove(&node.node_id) {
+                    NodeStatus::Assigned { node_metrics }
+                } else {
+                    NodeStatus::Unassigned { extrapolated_fr }
+                };
+
+            let rewards_reduction_percent = reward_reduction
+                .remove(&node.node_id)
+                .expect("Rewards reduction should be present in rewards");
+
+            let performance_multiplier_percent = performance_multiplier
+                .remove(&node.node_id)
+                .expect("Performance multiplier should be present in rewards");
+
+            let base_rewards_xdr_permyriad = base_rewards_per_node
+                .remove(&node.node_id)
+                .expect("Base rewards should be present in rewards");
+
+            let adjusted_rewards_xdr_permyriad = adjusted_rewards
+                .remove(&node.node_id)
+                .expect("Adjusted rewards should be present in rewards");
+
+            rewards_total += adjusted_rewards_xdr_permyriad;
+
+            results_by_node.push(NodeResults {
+                node_id: node.node_id,
+                node_reward_type: node.node_reward_type,
+                region: node.region,
+                dc_id: node.dc_id,
+                node_status,
+                performance_multiplier: performance_multiplier_percent,
+                rewards_reduction: rewards_reduction_percent,
+                base_rewards: base_rewards_xdr_permyriad,
+                adjusted_rewards: adjusted_rewards_xdr_permyriad,
+            });
+        }
+
+        NodeProviderRewards {
+            rewards_total,
+            base_rewards,
+            base_rewards_type3,
+            nodes_results: results_by_node,
+        }
+    }
+}
+
+// ------------------------------------------------------------------------------------------------
+// Helpers
+// ------------------------------------------------------------------------------------------------
+
+fn avg(values: &[Decimal]) -> Option<Decimal> {
+    if values.is_empty() {
+        None
+    } else {
+        Some(values.iter().sum::<Decimal>() / Decimal::from(values.len()))
+    }
+}
diff --git a/rs/node_rewards/rewards_calculation/src/performance_based_algorithm/results.rs b/rs/node_rewards/rewards_calculation/src/performance_based_algorithm/results.rs
new file mode 100644
index 0000000000..a5201b3a24
--- /dev/null
+++ b/rs/node_rewards/rewards_calculation/src/performance_based_algorithm/results.rs
@@ -0,0 +1,77 @@
+#![allow(dead_code)]
+use crate::types::DayUtc;
+use ic_base_types::{NodeId, PrincipalId, SubnetId};
+use ic_protobuf::registry::node::v1::NodeRewardType;
+use rust_decimal::Decimal;
+use serde::{Deserialize, Serialize};
+use std::collections::BTreeMap;
+
+pub type XDRPermyriad = Decimal;
+pub type Percent = Decimal;
+pub type Region = String;
+
+#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
+pub struct NodeMetricsDaily {
+    pub subnet_assigned: SubnetId,
+    pub subnet_assigned_fr: Percent,
+    pub num_blocks_proposed: u64,
+    pub num_blocks_failed: u64,
+    pub original_fr: Percent,
+    pub relative_fr: Percent,
+}
+
+#[derive(Serialize, Deserialize, Debug, PartialEq, Clone)]
+pub enum NodeStatus {
+    Assigned { node_metrics: NodeMetricsDaily },
+    Unassigned { extrapolated_fr: Percent },
+}
+
+#[derive(Serialize, Deserialize, Debug, PartialEq, Clone)]
+pub struct NodeResults {
+    pub node_id: NodeId,
+    pub node_reward_type: NodeRewardType,
+    pub region: String,
+    pub dc_id: String,
+    pub node_status: NodeStatus,
+    pub performance_multiplier: Percent,
+    pub rewards_reduction: Percent,
+    pub base_rewards: XDRPermyriad,
+    pub adjusted_rewards: XDRPermyriad,
+}
+
+#[derive(Serialize, Deserialize, Debug, PartialEq, Clone)]
+pub struct BaseRewards {
+    pub node_reward_type: NodeRewardType,
+    pub region: Region,
+    pub monthly: XDRPermyriad,
+    pub daily: XDRPermyriad,
+}
+
+#[derive(Serialize, Deserialize, Debug, PartialEq, Clone)]
+pub struct BaseRewardsType3 {
+    pub region: Region,
+    pub nodes_count: usize,
+    pub avg_rewards: XDRPermyriad,
+    pub avg_coefficient: Percent,
+    pub value: XDRPermyriad,
+}
+
+#[derive(Serialize, Deserialize, Debug, PartialEq, Clone)]
+pub struct NodeProviderRewards {
+    pub rewards_total: XDRPermyriad,
+    pub base_rewards: Vec<BaseRewards>,
+    pub base_rewards_type3: Vec<BaseRewardsType3>,
+    pub nodes_results: Vec<NodeResults>,
+}
+
+#[derive(Serialize, Deserialize)]
+pub struct DailyResults {
+    pub subnets_fr: BTreeMap<SubnetId, Percent>,
+    pub provider_results: BTreeMap<PrincipalId, NodeProviderRewards>,
+}
+
+#[derive(Serialize, Deserialize)]
+pub struct RewardsCalculatorResults {
+    pub total_rewards_xdr_permyriad: BTreeMap<PrincipalId, u64>,
+    pub daily_results: BTreeMap<DayUtc, DailyResults>,
+}
diff --git a/rs/node_rewards/rewards_calculation/src/performance_based_algorithm/test_utils.rs b/rs/node_rewards/rewards_calculation/src/performance_based_algorithm/test_utils.rs
new file mode 100644
index 0000000000..ea7ee0e044
--- /dev/null
+++ b/rs/node_rewards/rewards_calculation/src/performance_based_algorithm/test_utils.rs
@@ -0,0 +1,101 @@
+#![allow(dead_code)]
+use crate::types::{NodeMetricsDailyRaw, Region};
+use ic_base_types::{NodeId, PrincipalId, SubnetId};
+use ic_protobuf::registry::node::v1::NodeRewardType;
+use ic_protobuf::registry::node_rewards::v2::{NodeRewardRate, NodeRewardRates, NodeRewardsTable};
+use maplit::btreemap;
+use std::collections::BTreeMap;
+
+pub fn test_node_id(id: u64) -> NodeId {
+    NodeId::from(PrincipalId::new_node_test_id(id))
+}
+
+pub fn test_provider_id(id: u64) -> PrincipalId {
+    PrincipalId::new_user_test_id(id)
+}
+
+pub fn test_subnet_id(id: u64) -> SubnetId {
+    SubnetId::from(PrincipalId::new_subnet_test_id(id))
+}
+
+#[derive(Eq, Hash, PartialEq, Clone, Ord, PartialOrd, Debug)]
+pub struct RewardableNode {
+    pub node_id: NodeId,
+    pub region: Region,
+    pub node_reward_type: NodeRewardType,
+    pub dc_id: String,
+}
+
+impl Default for RewardableNode {
+    fn default() -> Self {
+        RewardableNode {
+            node_id: NodeId::from(PrincipalId::new_node_test_id(0)),
+            region: Region::default(),
+            node_reward_type: NodeRewardType::default(),
+            dc_id: "default_dc".into(),
+        }
+    }
+}
+
+pub fn build_daily_metrics(
+    subnet_id: SubnetId,
+    nodes_data: &[(NodeId, u64, u64)],
+) -> (SubnetId, Vec<NodeMetricsDailyRaw>) {
+    let metrics = nodes_data
+        .iter()
+        .map(|(node_id, proposed, failed)| NodeMetricsDailyRaw {
+            node_id: *node_id,
+            num_blocks_proposed: *proposed,
+            num_blocks_failed: *failed,
+        })
+        .collect();
+    (subnet_id, metrics)
+}
+
+pub fn generate_rewardable_nodes(nodes_with_rewardable_days: Vec<NodeId>) -> Vec<RewardableNode> {
+    nodes_with_rewardable_days
+        .into_iter()
+        .map(|node_id| RewardableNode {
+            node_id,
+            ..Default::default()
+        })
+        .collect()
+}
+
+pub fn create_rewards_table_for_region_test() -> NodeRewardsTable {
+    let mut table = BTreeMap::new();
+    table.insert(
+        "Europe,Switzerland".to_string(),
+        NodeRewardRates {
+            rates: btreemap! {
+                NodeRewardType::Type1.to_string() => NodeRewardRate {
+                    xdr_permyriad_per_node_per_month: 304375, // -> 10000 / day
+                    reward_coefficient_percent: None,
+                },
+            },
+        },
+    );
+    table.insert(
+        "North America,USA,California".to_string(),
+        NodeRewardRates {
+            rates: btreemap! {
+                NodeRewardType::Type3.to_string() => NodeRewardRate {
+                    xdr_permyriad_per_node_per_month: 913125, // -> 30000 / day
+                    reward_coefficient_percent: Some(90),
+                },
+            },
+        },
+    );
+    table.insert(
+        "North America,USA,Nevada".to_string(),
+        NodeRewardRates {
+            rates: btreemap! {
+                NodeRewardType::Type3dot1.to_string() => NodeRewardRate {
+                    xdr_permyriad_per_node_per_month: 1217500, // -> 40000 / day
+                    reward_coefficient_percent: Some(70),
+                },
+            },
+        },
+    );
+    NodeRewardsTable { table }
+}
diff --git a/rs/node_rewards/rewards_calculation/src/performance_based_algorithm/v1.rs b/rs/node_rewards/rewards_calculation/src/performance_based_algorithm/v1.rs
new file mode 100644
index 0000000000..06e233718f
--- /dev/null
+++ b/rs/node_rewards/rewards_calculation/src/performance_based_algorithm/v1.rs
@@ -0,0 +1,325 @@
+#![allow(dead_code)]
+#![allow(unused_imports)]
+use crate::performance_based_algorithm::results::RewardsCalculatorResults;
+use crate::performance_based_algorithm::{DataProvider, PerformanceBasedAlgorithm};
+use crate::types::DayUtc;
+use ic_base_types::PrincipalId;
+use rust_decimal::Decimal;
+use rust_decimal_macros::dec;
+
+// ================================================================================================
+// VERSIONING SAFETY WARNING
+// ================================================================================================
+//
+// CRITICAL: This RewardsCalculationV1 implementation must maintain historical reproducibility.
+//
+// Any changes to the calculation logic, constants, or data structures in this version MUST NOT
+// affect the results of previously calculated rewards. This is essential for:
+//
+// 1. **Audit Trail Integrity**: Historical reward calculations must remain verifiable
+// 3. **Financial Accuracy**: Incorrect historical calculations could have legal implications
+// 4. **System Reliability**: Users depend on consistent reward calculations over time
+//
+// If you need to change the calculation logic, create a new version (V2, V3, etc.) instead
+// of modifying this V1 implementation. This ensures backward compatibility and historical
+// reproducibility while allowing for future algorithm improvements.
+//
+// ================================================================================================
+
+pub struct RewardsCalculationV1;
+
+impl PerformanceBasedAlgorithm for RewardsCalculationV1 {
+    const SUBNET_FAILURE_RATE_PERCENTILE: f64 = 0.75;
+    const MIN_FAILURE_RATE: Decimal = dec!(0.1);
+    const MAX_FAILURE_RATE: Decimal = dec!(0.6);
+    const MIN_REWARDS_REDUCTION: Decimal = dec!(0);
+    const MAX_REWARDS_REDUCTION: Decimal = dec!(0.8);
+}
+
+impl RewardsCalculationV1 {
+    pub fn calculate_rewards(
+        from_day: &DayUtc,
+        to_day: &DayUtc,
+        node_provider_filter: Option<PrincipalId>,
+        data_provider: impl DataProvider,
+    ) -> Result<RewardsCalculatorResults, String> {
+        <RewardsCalculationV1 as PerformanceBasedAlgorithm>::calculate_rewards(
+            from_day,
+            to_day,
+            node_provider_filter,
+            data_provider,
+        )
+    }
+}
+
+mod tests {
+    #![allow(dead_code)]
+    use crate::performance_based_algorithm::test_utils::{
+        build_daily_metrics, create_rewards_table_for_region_test, generate_rewardable_nodes,
+        test_node_id, test_subnet_id, RewardableNode,
+    };
+    use crate::performance_based_algorithm::v1::RewardsCalculationV1;
+    use crate::performance_based_algorithm::PerformanceBasedAlgorithm;
+    use crate::performance_based_algorithm::{AdjustedRewardsResults, BaseRewardsResults};
+    use ic_protobuf::registry::node::v1::NodeRewardType;
+    use maplit::btreemap;
+    use rust_decimal_macros::dec;
+    use std::collections::BTreeMap;
+
+    // ------------------------------------------------------------------------------------------------
+    // Step 0: Pre-compute subnets and nodes failure rates
+    // ------------------------------------------------------------------------------------------------
+    #[test]
+    fn test_compute_subnets_nodes_fr() {
+        let subnet1 = test_subnet_id(1);
+        let subnet2 = test_subnet_id(2);
+
+        // Nodes for Subnet 1
+        let s1_node1 = test_node_id(11);
+        let s1_node2 = test_node_id(12);
+        let s1_node3 = test_node_id(13);
+        let s1_node4 = test_node_id(14);
+
+        // Nodes for Subnet 2
+        let s2_node1 = test_node_id(21);
+        let s2_node2 = test_node_id(22);
+
+        // --- Data Setup ---
+        let daily_metrics_by_subnet = BTreeMap::from_iter(vec![
+            build_daily_metrics(
+                subnet1,
+                &[
+                    (s1_node1, 75, 25), // FR = 0.25
+                    (s1_node2, 90, 10), // FR = 0.10
+                    (s1_node3, 95, 5),  // FR = 0.05
+                    (s1_node4, 50, 50), // FR = 0.50
+                ],
+            ),
+            build_daily_metrics(
+                subnet2,
+                &[
+                    (s2_node1, 80, 20), // FR = 0.20
+                    (s2_node2, 60, 40), // FR = 0.40
+                ],
+            ),
+        ]);
+
+        // --- Execution ---
+        let result = RewardsCalculationV1::calculate_failure_rates(daily_metrics_by_subnet);
+        let subnets_fr = result.subnets_fr;
+        let original_nodes_fr: BTreeMap<_, _> = result
+            .nodes_metrics_daily
+            .iter()
+            .map(|(k, v)| (*k, v.original_fr))
+            .collect();
+        let relative_nodes_fr: BTreeMap<_, _> = result
+            .nodes_metrics_daily
+            .iter()
+            .map(|(k, v)| (*k, v.relative_fr))
+            .collect();
+
+        // --- Assertions for Day 1, Subnet 1 ---
+        // Sorted FRs: 0.05, 0.10, 0.25, 0.50
+        // 75th percentile index = ceil(4 * 0.75) - 1 = 2. Value is 0.25
+        let expected_subnet1_day1_fr = dec!(0.25);
+        assert_eq!(subnets_fr.get(&subnet1), Some(&expected_subnet1_day1_fr));
+        assert_eq!(original_nodes_fr.get(&s1_node1), Some(&dec!(0.25)));
+        // Relative FR = max(0, original - subnet_fr)
+        assert_eq!(relative_nodes_fr.get(&s1_node1), Some(&dec!(0.0))); // 0.25 - 0.25 = 0
+        assert_eq!(relative_nodes_fr.get(&s1_node2), Some(&dec!(0.0))); // 0.10 - 0.25 < 0
+        assert_eq!(relative_nodes_fr.get(&s1_node4), Some(&dec!(0.25))); // 0.50 - 0.25 = 0.25
+
+        // --- Assertions for Day 1, Subnet 2 ---
+        // Sorted FRs: 0.20, 0.40
+        // 75th percentile index = ceil(2 * 0.75) - 1 = 1. Value is 0.40
+        let expected_subnet2_day1_fr = dec!(0.40);
+        assert_eq!(subnets_fr.get(&subnet2), Some(&expected_subnet2_day1_fr));
+        assert_eq!(original_nodes_fr.get(&s2_node1), Some(&dec!(0.20)));
+        assert_eq!(relative_nodes_fr.get(&s2_node1), Some(&dec!(0.0))); // 0.20 - 0.40 < 0
+        assert_eq!(relative_nodes_fr.get(&s2_node1), Some(&dec!(0.0))); // 0.40 - 0.40 = 0
+
+        // --- Data Setup ---
+        let daily_metrics_by_subnet = BTreeMap::from_iter(vec![build_daily_metrics(
+            subnet1,
+            &[
+                (s1_node1, 99, 1), // FR = 0.01
+                (s1_node2, 0, 0),  // FR = 0.0, but not in rewardable_nodes for day2 so ignored
+            ],
+        )]);
+        let result = RewardsCalculationV1::calculate_failure_rates(daily_metrics_by_subnet);
+        let subnets_fr = result.subnets_fr;
+        let original_nodes_fr: BTreeMap<_, _> = result
+            .nodes_metrics_daily
+            .iter()
+            .map(|(k, v)| (*k, v.original_fr))
+            .collect();
+        let relative_nodes_fr: BTreeMap<_, _> = result
+            .nodes_metrics_daily
+            .iter()
+            .map(|(k, v)| (*k, v.relative_fr))
+            .collect();
+
+        // --- Assertions for Day 2, Subnet 1 ---
+        // Sorted FRs: 0.0, 0.01
+        // 75th percentile index = ceil(2 * 0.75) - 1 = 1. Value is 0.01
+        let expected_subnet1_day2_fr = dec!(0.01);
+
+        assert_eq!(subnets_fr.get(&subnet1), Some(&expected_subnet1_day2_fr));
+        assert_eq!(original_nodes_fr.get(&s1_node1), Some(&dec!(0.01)));
+        assert_eq!(relative_nodes_fr.get(&s1_node1), Some(&dec!(0.0))); // 0.01 - 0.01 = 0
+    }
+
+    // ------------------------------------------------------------------------------------------------
+    // Step 3: Compute performance multiplier for each node for each provider
+    // ------------------------------------------------------------------------------------------------
+    #[test]
+    fn test_compute_nodes_performance_multiplier() {
+        let node_good = test_node_id(1); // FR below threshold
+        let node_mid = test_node_id(2); // FR in penalty zone
+        let node_bad = test_node_id(3); // FR above threshold
+        let node_unassigned = test_node_id(4); // Uses extrapolated FR
+
+        // --- Data Setup ---
+        let rewardable_nodes =
+            generate_rewardable_nodes(vec![node_good, node_mid, node_bad, node_unassigned]);
+
+        // Assigned nodes' relative FR
+        let relative_nodes_fr = btreemap! {
+            node_good => dec!(0.05), // < 0.1
+            node_mid => dec!(0.35), // (0.35-0.1)/(0.6-0.1)*0.8 = 0.4
+            node_bad => dec!(0.7),  // > 0.6
+        };
+        // Unassigned nodes use extrapolated FR
+        let extrapolated_fr = dec!(0.35);
+
+        // --- Execution ---
+        let result = RewardsCalculationV1::calculate_performance_multipliers(
+            &rewardable_nodes,
+            &relative_nodes_fr,
+            &extrapolated_fr,
+        );
+        let reward_reduction = result.reward_reduction;
+        let performance_multiplier = result.performance_multiplier;
+
+        // --- Assertions ---
+        // Good node: reduction = 0, multiplier = 1
+        assert_eq!(
+            reward_reduction.get(&node_good),
+            Some(&RewardsCalculationV1::MIN_REWARDS_REDUCTION)
+        );
+        assert_eq!(performance_multiplier.get(&node_good), Some(&dec!(1.0)));
+
+        // Mid node: reduction = 0.4, multiplier = 0.6
+        assert_eq!(reward_reduction.get(&node_mid), Some(&dec!(0.4)));
+        assert_eq!(performance_multiplier.get(&node_mid), Some(&dec!(0.6)));
+
+        // Bad node: reduction = 0.8, multiplier = 0.2
+        assert_eq!(
+            reward_reduction.get(&node_bad),
+            Some(&RewardsCalculationV1::MAX_REWARDS_REDUCTION)
+        );
+        assert_eq!(performance_multiplier.get(&node_bad), Some(&dec!(0.2)));
+
+        // Unassigned node (uses extrapolated FR, same as mid)
+        assert_eq!(
+            performance_multiplier.get(&node_unassigned),
+            Some(&dec!(0.6))
+        );
+    }
+
+    // ------------------------------------------------------------------------------------------------
+    // Step 4: Compute base rewards for each node based on its region and node type
+    // ------------------------------------------------------------------------------------------------
+
+    #[test]
+    fn test_compute_base_rewards() {
+        let type1_node = test_node_id(1);
+        let type3_node_ca = test_node_id(2);
+        let type3_node_nv = test_node_id(3);
+
+        let rewardable_nodes = vec![
+            RewardableNode {
+                node_id: type1_node,
+                node_reward_type: NodeRewardType::Type1,
+                region: "Europe,Switzerland".into(),
+                dc_id: "dc1".into(),
+            },
+            RewardableNode {
+                node_id: type3_node_ca,
+                node_reward_type: NodeRewardType::Type3,
+                region: "North America,USA,California".into(),
+                dc_id: "dc2".into(),
+            },
+            RewardableNode {
+                node_id: type3_node_nv,
+                node_reward_type: NodeRewardType::Type3dot1,
+                region: "North America,USA,Nevada".into(),
+                dc_id: "dc3".into(),
+            },
+        ];
+        let rewards_table = create_rewards_table_for_region_test();
+
+        // --- Execution ---
+        let BaseRewardsResults {
+            base_rewards_per_node,
+            ..
+        } = RewardsCalculationV1::calculate_base_rewards_by_region_and_type(
+            &rewards_table,
+            &rewardable_nodes,
+        );
+
+        // --- Assertions ---
+        assert_eq!(base_rewards_per_node.get(&type1_node), Some(&dec!(10000)));
+        assert_eq!(
+            base_rewards_per_node.get(&type3_node_ca),
+            Some(&dec!(31500))
+        );
+        assert_eq!(
+            base_rewards_per_node.get(&type3_node_nv),
+            Some(&dec!(31500))
+        );
+    }
+
+    // ------------------------------------------------------------------------------------------------
+    // Step 5: Adjust nodes rewards based on performance and number of nodes
+    // ------------------------------------------------------------------------------------------------
+    #[test]
+    fn test_adjust_nodes_rewards() {
+        let node1 = test_node_id(1);
+        let node2 = test_node_id(2);
+        let node3 = test_node_id(3);
+        let node4 = test_node_id(4);
+        let node5 = test_node_id(5);
+
+        // Day 1 has 5 nodes, Day 2 and Day 3 has 3 nodes.
+        let rewardable_nodes = generate_rewardable_nodes(vec![node1, node2, node3, node4, node5]);
+
+        let mut base_rewards = BTreeMap::new();
+        let mut performance_multiplier = BTreeMap::new();
+        for node in &rewardable_nodes {
+            base_rewards.insert(node.node_id, dec!(1000));
+            // Assigned nodes
+            performance_multiplier.insert(node.node_id, dec!(0.5));
+        }
+
+        // --- Execution ---
+        let AdjustedRewardsResults { adjusted_rewards } =
+            RewardsCalculationV1::apply_performance_adjustments(
+                &rewardable_nodes,
+                &base_rewards,
+                &performance_multiplier,
+            );
+
+        // --- Assertions ---
+        let expected = dec!(1000) * dec!(0.5);
+
+        for node in &[node1, node2, node3, node4, node5] {
+            assert_eq!(
+                adjusted_rewards.get(node),
+                Some(&expected),
+                "Unexpected reward for node {:?}",
+                node
+            );
+        }
+    }
+}
```

---

### Commit `861616d46ded00091fecbfe01f441b38b56b483c`

**Author:** pietrodimarco-dfinity <124565147+pietrodimarco-dfinity@users.noreply.github.com>  
**Date:** 2025-09-11  
**Message:** fix(NRC): Remove API types from proto (#6693)

**Files Changed:**
- `rs/node_rewards/canister/BUILD.bazel`
- `rs/node_rewards/canister/Cargo.toml`
- `rs/node_rewards/canister/api/BUILD.bazel`
- `rs/node_rewards/canister/api/Cargo.toml`
- `rs/node_rewards/canister/api/src/provider_rewards_calculation.rs`
- `rs/node_rewards/canister/proto/rewards_calculator/pb/v1/types.proto`
- `rs/node_rewards/canister/protobuf/BUILD.bazel`
- `rs/node_rewards/canister/protobuf/Cargo.toml`
- `rs/node_rewards/canister/protobuf/src/conversions.rs`
- `rs/node_rewards/canister/protobuf/src/gen/rewards_calculator.pb.v1.rs`
- `rs/node_rewards/canister/protobuf/src/lib.rs`
- `rs/node_rewards/canister/protobuf/src/pb/ic_node_rewards/mod.rs`
- `rs/node_rewards/canister/protobuf/src/pb/mod.rs`
- `rs/node_rewards/canister/protobuf/src/pb/rewards_calculator/mod.rs`
- `rs/node_rewards/canister/protobuf_generator/src/lib.rs`
- `rs/node_rewards/canister/protobuf_generator/src/main.rs`
- `rs/node_rewards/canister/src/api_conversion.rs`
- `rs/node_rewards/canister/src/canister/mod.rs`
- `rs/node_rewards/canister/src/canister/test/get_node_providers_rewards.rs`
- `rs/node_rewards/canister/src/gen/ic_node_rewards.pb.v1.rs`
- `rs/node_rewards/canister/src/lib.rs`
- `rs/node_rewards/canister/src/metrics.rs`
- `rs/node_rewards/canister/src/metrics/tests.rs`
- `rs/node_rewards/canister/src/pb/mod.rs`

**Code Changes:**

```diff
commit 861616d46ded00091fecbfe01f441b38b56b483c
Author: pietrodimarco-dfinity <124565147+pietrodimarco-dfinity@users.noreply.github.com>
Date:   Thu Sep 11 08:59:40 2025 +0200

    fix(NRC): Remove API types from proto (#6693)
    
    Changes:
    - Moved API types in `ic-node-rewards-canister-api`
    - Removed `protobuf` module
    - Handled conversion `rewards-calculation` to
    `ic-node-rewards-canister-api` types within the canister

diff --git a/rs/node_rewards/canister/BUILD.bazel b/rs/node_rewards/canister/BUILD.bazel
index 45c9b72f61..f640f6783a 100644
--- a/rs/node_rewards/canister/BUILD.bazel
+++ b/rs/node_rewards/canister/BUILD.bazel
@@ -11,7 +11,6 @@ DEPENDENCIES = [
     "//rs/nervous_system/common",
     "//rs/nns/constants",
     "//rs/node_rewards/canister/api",
-    "//rs/node_rewards/canister/protobuf",
     "//rs/node_rewards/rewards_calculation",
     "//rs/protobuf",
     "//rs/registry/canister-client",
diff --git a/rs/node_rewards/canister/Cargo.toml b/rs/node_rewards/canister/Cargo.toml
index 524c28e7dc..c1df86922c 100644
--- a/rs/node_rewards/canister/Cargo.toml
+++ b/rs/node_rewards/canister/Cargo.toml
@@ -26,7 +26,6 @@ ic-nervous-system-canisters = { path = "../../nervous_system/canisters" }
 ic-nervous-system-common = { path = "../../nervous_system/common" }
 ic-nns-constants = { path = "../../nns/constants" }
 ic-node-rewards-canister-api = { path = "./api" }
-ic-node-rewards-canister-protobuf = { path = "./protobuf" }
 ic-registry-canister-client = { path = "../../registry/canister-client" }
 ic-registry-keys = { path = "../../registry/keys" }
 ic-registry-node-provider-rewards = { path = "../../registry/node_provider_rewards" }
diff --git a/rs/node_rewards/canister/api/BUILD.bazel b/rs/node_rewards/canister/api/BUILD.bazel
index 1594106175..5cede2d4c8 100644
--- a/rs/node_rewards/canister/api/BUILD.bazel
+++ b/rs/node_rewards/canister/api/BUILD.bazel
@@ -4,8 +4,8 @@ package(default_visibility = ["//visibility:public"])
 
 DEPENDENCIES = [
     # Keep sorted.
-    "//rs/node_rewards/canister/protobuf",
-    "//rs/node_rewards/rewards_calculation",
+    "//rs/nervous_system/proto",
+    "//rs/types/base_types",
     "@crate_index//:candid",
     "@crate_index//:ic-cdk",
     "@crate_index//:serde",
diff --git a/rs/node_rewards/canister/api/Cargo.toml b/rs/node_rewards/canister/api/Cargo.toml
index e5067938a8..4c7ddb9b62 100644
--- a/rs/node_rewards/canister/api/Cargo.toml
+++ b/rs/node_rewards/canister/api/Cargo.toml
@@ -11,6 +11,6 @@ path = "src/lib.rs"
 
 [dependencies]
 candid = { workspace = true }
-ic-node-rewards-canister-protobuf = { path = "../protobuf" }
-rewards-calculation = { path = "../../rewards_calculation" }
+ic-base-types = { path = "../../../types/base_types" }
+ic-nervous-system-proto = { path = "../../../nervous_system/proto" }
 serde = { workspace = true }
diff --git a/rs/node_rewards/canister/api/src/provider_rewards_calculation.rs b/rs/node_rewards/canister/api/src/provider_rewards_calculation.rs
index 57bf86c85b..3d674857e3 100644
--- a/rs/node_rewards/canister/api/src/provider_rewards_calculation.rs
+++ b/rs/node_rewards/canister/api/src/provider_rewards_calculation.rs
@@ -1,6 +1,4 @@
 use candid::{CandidType, Deserialize, Principal};
-use ic_node_rewards_canister_protobuf::pb::rewards_calculator::v1::NodeProviderRewards;
-
 #[derive(CandidType, Clone, Deserialize)]
 pub struct GetNodeProviderRewardsCalculationRequest {
     pub from_nanos: u64,
@@ -9,3 +7,89 @@ pub struct GetNodeProviderRewardsCalculationRequest {
 }
 
 pub type GetNodeProviderRewardsCalculationResponse = Result<NodeProviderRewards, String>;
+
+#[derive(
+    PartialOrd, Ord, Eq, candid::CandidType, candid::Deserialize, Clone, Copy, PartialEq, Debug,
+)]
+pub struct DayUtc {
+    pub value: Option<u64>,
+}
+
+#[derive(candid::CandidType, candid::Deserialize, Clone, PartialEq, Debug)]
+pub struct NodeMetricsDaily {
+    pub subnet_assigned: Option<::ic_base_types::PrincipalId>,
+    pub subnet_assigned_fr_percent: Option<::ic_nervous_system_proto::pb::v1::Decimal>,
+    pub num_blocks_proposed: Option<u64>,
+    pub num_blocks_failed: Option<u64>,
+    pub original_fr_percent: Option<::ic_nervous_system_proto::pb::v1::Decimal>,
+    pub relative_fr_percent: Option<::ic_nervous_system_proto::pb::v1::Decimal>,
+}
+
+#[derive(candid::CandidType, candid::Deserialize, Clone, PartialEq, Debug)]
+pub struct Assigned {
+    pub node_metrics: Option<NodeMetricsDaily>,
+}
+
+#[derive(candid::CandidType, candid::Deserialize, Clone, PartialEq, Debug)]
+pub struct Unassigned {
+    pub extrapolated_fr_percent: Option<::ic_nervous_system_proto::pb::v1::Decimal>,
+}
+
+#[derive(candid::CandidType, candid::Deserialize, Clone, PartialEq, Debug)]
+pub struct NodeStatus {
+    pub status: Option<node_status::Status>,
+}
+
+/// Nested message and enum types in `NodeStatus`.
+pub mod node_status {
+    #[derive(candid::CandidType, candid::Deserialize, Clone, PartialEq, Debug)]
+    pub enum Status {
+        Assigned(super::Assigned),
+        Unassigned(super::Unassigned),
+    }
+}
+
+#[derive(candid::CandidType, candid::Deserialize, Clone, PartialEq, Debug)]
+pub struct DailyResults {
+    pub day: Option<DayUtc>,
+    pub node_status: Option<NodeStatus>,
+    pub performance_multiplier_percent: Option<::ic_nervous_system_proto::pb::v1::Decimal>,
+    pub rewards_reduction_percent: Option<::ic_nervous_system_proto::pb::v1::Decimal>,
+    pub base_rewards_xdr_permyriad: Option<::ic_nervous_system_proto::pb::v1::Decimal>,
+    pub adjusted_rewards_xdr_permyriad: Option<::ic_nervous_system_proto::pb::v1::Decimal>,
+}
+
+#[derive(candid::CandidType, candid::Deserialize, Clone, PartialEq, Debug)]
+pub struct NodeResults {
+    pub node_id: Option<::ic_base_types::PrincipalId>,
+    pub node_reward_type: Option<String>,
+    pub region: Option<String>,
+    pub dc_id: Option<String>,
+    pub daily_results: Vec<DailyResults>,
+}
+
+#[derive(candid::CandidType, candid::Deserialize, Clone, PartialEq, Debug)]
+pub struct BaseRewards {
+    pub monthly_xdr_permyriad: Option<::ic_nervous_system_proto::pb::v1::Decimal>,
+    pub daily_xdr_permyriad: Option<::ic_nervous_system_proto::pb::v1::Decimal>,
+    pub node_reward_type: Option<String>,
+    pub region: Option<String>,
+}
+
+#[derive(candid::CandidType, candid::Deserialize, Clone, PartialEq, Debug)]
+pub struct DailyBaseRewardsType3 {
+    pub day: Option<DayUtc>,
+    pub region: Option<String>,
+    pub nodes_count: Option<u64>,
+    pub avg_rewards_xdr_permyriad: Option<::ic_nervous_system_proto::pb::v1::Decimal>,
+    pub avg_coefficient_percent: Option<::ic_nervous_system_proto::pb::v1::Decimal>,
+    pub value_xdr_permyriad: Option<::ic_nervous_system_proto::pb::v1::Decimal>,
+}
+
+#[derive(candid::CandidType, candid::Deserialize, Clone, PartialEq, Debug)]
+pub struct NodeProviderRewards {
+    pub rewards_total_xdr_permyriad: Option<u64>,
+    pub base_rewards: Vec<BaseRewards>,
+    pub base_rewards_type3: Vec<DailyBaseRewardsType3>,
+    pub nodes_results: Vec<NodeResults>,
+}
diff --git a/rs/node_rewards/canister/proto/rewards_calculator/pb/v1/types.proto b/rs/node_rewards/canister/proto/rewards_calculator/pb/v1/types.proto
deleted file mode 100644
index bdcaaab580..0000000000
--- a/rs/node_rewards/canister/proto/rewards_calculator/pb/v1/types.proto
+++ /dev/null
@@ -1,74 +0,0 @@
-syntax = "proto3";
-
-package rewards_calculator.pb.v1;
-
-import "ic_base_types/pb/v1/types.proto";
-import "ic_nervous_system/pb/v1/nervous_system.proto";
-
-message DayUtc {
-  optional uint64 value = 1;
-}
-
-message NodeMetricsDaily {
-  ic_base_types.pb.v1.PrincipalId subnet_assigned = 1;
-  ic_nervous_system.pb.v1.Decimal subnet_assigned_fr_percent = 2;
-  optional uint64 num_blocks_proposed = 3;
-  optional uint64 num_blocks_failed = 4;
-  ic_nervous_system.pb.v1.Decimal original_fr_percent = 5;
-  ic_nervous_system.pb.v1.Decimal relative_fr_percent = 6;
-}
-
-message Assigned {
-  optional NodeMetricsDaily node_metrics = 1;
-}
-
-message Unassigned {
-  ic_nervous_system.pb.v1.Decimal extrapolated_fr_percent = 1;
-}
-
-message NodeStatus {
-  oneof status {
-    Assigned assigned = 1;
-    Unassigned unassigned = 2;
-  }
-}
-
-message DailyResults {
-  DayUtc day = 1;
-  optional NodeStatus node_status = 2;
-  ic_nervous_system.pb.v1.Decimal performance_multiplier_percent = 3;
-  ic_nervous_system.pb.v1.Decimal rewards_reduction_percent = 4;
-  ic_nervous_system.pb.v1.Decimal base_rewards_xdr_permyriad = 5;
-  ic_nervous_system.pb.v1.Decimal adjusted_rewards_xdr_permyriad = 6;
-}
-
-message NodeResults {
-  ic_base_types.pb.v1.PrincipalId node_id = 1;
-  optional string node_reward_type = 2;
-  optional string region = 3;
-  optional string dc_id = 4;
-  repeated DailyResults daily_results = 5;
-}
-
-message BaseRewards {
-  ic_nervous_system.pb.v1.Decimal monthly_xdr_permyriad = 1;
-  ic_nervous_system.pb.v1.Decimal daily_xdr_permyriad = 2;
-  optional string node_reward_type = 3;
-  optional string region = 4;
-}
-
-message DailyBaseRewardsType3 {
-  DayUtc day = 1;
-  optional string region = 2;
-  optional uint64 nodes_count = 3;
-  ic_nervous_system.pb.v1.Decimal avg_rewards_xdr_permyriad = 4;
-  ic_nervous_system.pb.v1.Decimal avg_coefficient_percent = 5;
-  ic_nervous_system.pb.v1.Decimal value_xdr_permyriad = 6;
-}
-
-message NodeProviderRewards {
-  optional uint64 rewards_total_xdr_permyriad = 1;
-  repeated BaseRewards base_rewards = 2;
-  repeated DailyBaseRewardsType3 base_rewards_type3 = 3;
-  repeated NodeResults nodes_results = 4;
-}
diff --git a/rs/node_rewards/canister/protobuf/BUILD.bazel b/rs/node_rewards/canister/protobuf/BUILD.bazel
deleted file mode 100644
index bb07cab601..0000000000
--- a/rs/node_rewards/canister/protobuf/BUILD.bazel
+++ /dev/null
@@ -1,36 +0,0 @@
-load("@rules_rust//rust:defs.bzl", "rust_library")
-
-package(default_visibility = ["//visibility:public"])
-
-DEPENDENCIES = [
-    # Keep sorted.
-    "//rs/nervous_system/proto",
-    "//rs/node_rewards/rewards_calculation",
-    "//rs/types/base_types",
-    "@crate_index//:candid",
-    "@crate_index//:ic-cdk",
-    "@crate_index//:ic-management-canister-types",
-    "@crate_index//:ic-stable-structures",
-    "@crate_index//:prost",
-    "@crate_index//:serde",
-]
-
-MACRO_DEPENDENCIES = [
-    # Keep sorted.
-]
-
-LIB_SRCS = glob(
-    [
-        "src/**/*.rs",
-    ],
-    exclude = ["**/*tests*/**"],
-)
-
-rust_library(
-    name = "protobuf",
-    srcs = LIB_SRCS,
-    crate_name = "ic_node_rewards_canister_protobuf",
-    proc_macro_deps = MACRO_DEPENDENCIES,
-    version = "0.9.0",
-    deps = DEPENDENCIES,
-)
diff --git a/rs/node_rewards/canister/protobuf/Cargo.toml b/rs/node_rewards/canister/protobuf/Cargo.toml
deleted file mode 100644
index 71a1ddfb5d..0000000000
--- a/rs/node_rewards/canister/protobuf/Cargo.toml
+++ /dev/null
@@ -1,20 +0,0 @@
-[package]
-name = "ic-node-rewards-canister-protobuf"
-version.workspace = true
-authors.workspace = true
-edition.workspace = true
-description.workspace = true
-documentation.workspace = true
-
-[lib]
-path = "src/lib.rs"
-
-[dependencies]
-candid = { workspace = true }
-ic-base-types = { path = "../../../types/base_types" }
-ic-management-canister-types = { workspace = true }
-ic-nervous-system-proto = { path = "../../../nervous_system/proto" }
-ic-stable-structures = { workspace = true }
-prost = { workspace = true }
-rewards-calculation = { path = "../../rewards_calculation" }
-serde = { workspace = true }
diff --git a/rs/node_rewards/canister/protobuf/src/conversions.rs b/rs/node_rewards/canister/protobuf/src/conversions.rs
deleted file mode 100644
index 605186f2b7..0000000000
--- a/rs/node_rewards/canister/protobuf/src/conversions.rs
+++ /dev/null
@@ -1,192 +0,0 @@
-use crate::pb;
-use ic_base_types::SubnetId;
-use ic_management_canister_types::NodeMetrics;
-use rewards_calculation::rewards_calculator_results::{
-    BaseRewards, DailyBaseRewardsType3, DailyResults, NodeMetricsDaily, NodeProviderRewards,
-    NodeResults, NodeStatus,
-};
-use rewards_calculation::types::{DayUtc, SubnetMetricsDailyKey};
-
-impl From<SubnetId> for pb::ic_node_rewards::v1::SubnetIdKey {
-    fn from(subnet_id: SubnetId) -> Self {
-        Self {
-            subnet_id: Some(subnet_id.get()),
-        }
-    }
-}
-
-impl From<pb::ic_node_rewards::v1::SubnetIdKey> for SubnetId {
-    fn from(subnet_id: pb::ic_node_rewards::v1::SubnetIdKey) -> Self {
-        subnet_id.subnet_id.unwrap().into()
-    }
-}
-
-impl From<pb::ic_node_rewards::v1::SubnetMetricsKey> for SubnetMetricsDailyKey {
-    fn from(key: pb::ic_node_rewards::v1::SubnetMetricsKey) -> Self {
-        Self {
-            day: key.timestamp_nanos.into(),
-            subnet_id: SubnetId::from(key.subnet_id.unwrap()),
-        }
-    }
-}
-
-impl From<NodeMetrics> for pb::ic_node_rewards::v1::NodeMetrics {
-    fn from(metrics: NodeMetrics) -> Self {
-        pb::ic_node_rewards::v1::NodeMetrics {
-            node_id: Some(metrics.node_id.into()),
-            num_blocks_proposed_total: metrics.num_blocks_proposed_total,
-            num_blocks_failed_total: metrics.num_block_failures_total,
-        }
-    }
-}
-
-impl From<NodeProviderRewards> for pb::rewards_calculator::v1::NodeProviderRewards {
-    fn from(
-        NodeProviderRewards {
-            rewards_total_xdr_permyriad,
-            base_rewards,
-            base_rewards_type3,
-            nodes_results,
-        }: NodeProviderRewards,
-    ) -> Self {
-        Self {
-            rewards_total_xdr_permyriad: rewards_total_xdr_permyriad.into(),
-            base_rewards: base_rewards.into_iter().map(Into::into).collect(),
-            base_rewards_type3: base_rewards_type3.into_iter().map(Into::into).collect(),
-            nodes_results: nodes_results.into_iter().map(Into::into).collect(),
-        }
-    }
-}
-
-impl From<NodeResults> for pb::rewards_calculator::v1::NodeResults {
-    fn from(
-        NodeResults {
-            node_id,
-            node_reward_type,
-            region,
-            dc_id,
-            daily_results,
-        }: NodeResults,
-    ) -> Self {
-        Self {
-            node_id: Some(node_id.get()),
-            node_reward_type: Some(node_reward_type.to_string()),
-            region: Some(region),
-            dc_id: Some(dc_id),
-            daily_results: daily_results.into_iter().map(Into::into).collect(),
-        }
-    }
-}
-
-impl From<DailyResults> for pb::rewards_calculator::v1::DailyResults {
-    fn from(
-        DailyResults {
-            day,
-            node_status,
-            performance_multiplier,
-            rewards_reduction,
-            base_rewards,
-            adjusted_rewards,
-        }: DailyResults,
-    ) -> Self {
-        Self {
-            day: Some(day.into()),
-            node_status: Some(node_status.into()),
-            performance_multiplier_percent: Some(performance_multiplier.into()),
-            rewards_reduction_percent: Some(rewards_reduction.into()),
-            base_rewards_xdr_permyriad: Some(base_rewards.into()),
-            adjusted_rewards_xdr_permyriad: Some(adjusted_rewards.into()),
-        }
-    }
-}
-
-impl From<BaseRewards> for pb::rewards_calculator::v1::BaseRewards {
-    fn from(
-        BaseRewards {
-            node_reward_type,
-            region,
-            monthly,
-            daily,
-        }: BaseRewards,
-    ) -> Self {
-        Self {
-            node_reward_type: Some(node_reward_type.as_str_name().to_string()),
-            region: Some(region),
-            monthly_xdr_permyriad: Some(monthly.into()),
-            daily_xdr_permyriad: Some(daily.into()),
-        }
-    }
-}
-
-impl From<DailyBaseRewardsType3> for pb::rewards_calculator::v1::DailyBaseRewardsType3 {
-    fn from(
-        DailyBaseRewardsType3 {
-            day,
-            region,
-            nodes_count,
-            avg_rewards,
-            avg_coefficient,
-            value,
-        }: DailyBaseRewardsType3,
-    ) -> Self {
-        Self {
-            day: Some(day.into()),
-            region: Some(region),
-            nodes_count: Some(nodes_count as u64),
-            avg_rewards_xdr_permyriad: Some(avg_rewards.into()),
-            avg_coefficient_percent: Some(avg_coefficient.into()),
-            value_xdr_permyriad: Some(value.into()),
-        }
-    }
-}
-
-impl From<NodeStatus> for pb::rewards_calculator::v1::NodeStatus {
-    fn from(value: NodeStatus) -> Self {
-        match value {
-            NodeStatus::Assigned { node_metrics } => Self {
-                status: Some(pb::rewards_calculator::v1::node_status::Status::Assigned(
-                    pb::rewards_calculator::v1::Assigned {
-                        node_metrics: Some(node_metrics.into()),
-                    },
-                )),
-            },
-            NodeStatus::Unassigned { extrapolated_fr } => Self {
-                status: Some(pb::rewards_calculator::v1::node_status::Status::Unassigned(
-                    pb::rewards_calculator::v1::Unassigned {
-                        extrapolated_fr_percent: Some(extrapolated_fr.into()),
-                    },
-                )),
-            },
-        }
-    }
-}
-
-impl From<DayUtc> for pb::rewards_calculator::v1::DayUtc {
-    fn from(day: DayUtc) -> Self {
-        Self {
-            value: Some(day.unix_ts_at_day_end()),
-        }
-    }
-}
-
-impl From<NodeMetricsDaily> for pb::rewards_calculator::v1::NodeMetricsDaily {
-    fn from(
-        NodeMetricsDaily {
-            subnet_assigned,
-            subnet_assigned_fr,
-            num_blocks_proposed,
-            num_blocks_failed,
-            original_fr,
-            relative_fr,
-        }: NodeMetricsDaily,
-    ) -> Self {
-        Self {
-            subnet_assigned: Some(subnet_assigned.get()),
-            subnet_assigned_fr_percent: Some(subnet_assigned_fr.into()),
-            num_blocks_proposed: Some(num_blocks_proposed),
-            num_blocks_failed: Some(num_blocks_failed),
-            original_fr_percent: Some(original_fr.into()),
-            relative_fr_percent: Some(relative_fr.into()),
-        }
-    }
-}
diff --git a/rs/node_rewards/canister/protobuf/src/gen/rewards_calculator.pb.v1.rs b/rs/node_rewards/canister/protobuf/src/gen/rewards_calculator.pb.v1.rs
deleted file mode 100644
index 87931f0ba5..0000000000
--- a/rs/node_rewards/canister/protobuf/src/gen/rewards_calculator.pb.v1.rs
+++ /dev/null
@@ -1,127 +0,0 @@
-// This file is @generated by prost-build.
-#[derive(
-    PartialOrd,
-    Ord,
-    Eq,
-    candid::CandidType,
-    candid::Deserialize,
-    Clone,
-    Copy,
-    PartialEq,
-    ::prost::Message,
-)]
-pub struct DayUtc {
-    #[prost(uint64, optional, tag = "1")]
-    pub value: ::core::option::Option<u64>,
-}
-#[derive(candid::CandidType, candid::Deserialize, Clone, PartialEq, ::prost::Message)]
-pub struct NodeMetricsDaily {
-    #[prost(message, optional, tag = "1")]
-    pub subnet_assigned: ::core::option::Option<::ic_base_types::PrincipalId>,
-    #[prost(message, optional, tag = "2")]
-    pub subnet_assigned_fr_percent:
-        ::core::option::Option<::ic_nervous_system_proto::pb::v1::Decimal>,
-    #[prost(uint64, optional, tag = "3")]
-    pub num_blocks_proposed: ::core::option::Option<u64>,
-    #[prost(uint64, optional, tag = "4")]
-    pub num_blocks_failed: ::core::option::Option<u64>,
-    #[prost(message, optional, tag = "5")]
-    pub original_fr_percent: ::core::option::Option<::ic_nervous_system_proto::pb::v1::Decimal>,
-    #[prost(message, optional, tag = "6")]
-    pub relative_fr_percent: ::core::option::Option<::ic_nervous_system_proto::pb::v1::Decimal>,
-}
-#[derive(candid::CandidType, candid::Deserialize, Clone, PartialEq, ::prost::Message)]
-pub struct Assigned {
-    #[prost(message, optional, tag = "1")]
-    pub node_metrics: ::core::option::Option<NodeMetricsDaily>,
-}
-#[derive(candid::CandidType, candid::Deserialize, Clone, PartialEq, ::prost::Message)]
-pub struct Unassigned {
-    #[prost(message, optional, tag = "1")]
-    pub extrapolated_fr_percent: ::core::option::Option<::ic_nervous_system_proto::pb::v1::Decimal>,
-}
-#[derive(candid::CandidType, candid::Deserialize, Clone, PartialEq, ::prost::Message)]
-pub struct NodeStatus {
-    #[prost(oneof = "node_status::Status", tags = "1, 2")]
-    pub status: ::core::option::Option<node_status::Status>,
-}
-/// Nested message and enum types in `NodeStatus`.
-pub mod node_status {
-    #[derive(candid::CandidType, candid::Deserialize, Clone, PartialEq, ::prost::Oneof)]
-    pub enum Status {
-        #[prost(message, tag = "1")]
-        Assigned(super::Assigned),
-        #[prost(message, tag = "2")]
-        Unassigned(super::Unassigned),
-    }
-}
-#[derive(candid::CandidType, candid::Deserialize, Clone, PartialEq, ::prost::Message)]
-pub struct DailyResults {
-    #[prost(message, optional, tag = "1")]
-    pub day: ::core::option::Option<DayUtc>,
-    #[prost(message, optional, tag = "2")]
-    pub node_status: ::core::option::Option<NodeStatus>,
-    #[prost(message, optional, tag = "3")]
-    pub performance_multiplier_percent:
-        ::core::option::Option<::ic_nervous_system_proto::pb::v1::Decimal>,
-    #[prost(message, optional, tag = "4")]
-    pub rewards_reduction_percent:
-        ::core::option::Option<::ic_nervous_system_proto::pb::v1::Decimal>,
-    #[prost(message, optional, tag = "5")]
-    pub base_rewards_xdr_permyriad:
-        ::core::option::Option<::ic_nervous_system_proto::pb::v1::Decimal>,
-    #[prost(message, optional, tag = "6")]
-    pub adjusted_rewards_xdr_permyriad:
-        ::core::option::Option<::ic_nervous_system_proto::pb::v1::Decimal>,
-}
-#[derive(candid::CandidType, candid::Deserialize, Clone, PartialEq, ::prost::Message)]
-pub struct NodeResults {
-    #[prost(message, optional, tag = "1")]
-    pub node_id: ::core::option::Option<::ic_base_types::PrincipalId>,
-    #[prost(string, optional, tag = "2")]
-    pub node_reward_type: ::core::option::Option<::prost::alloc::string::String>,
-    #[prost(string, optional, tag = "3")]
-    pub region: ::core::option::Option<::prost::alloc::string::String>,
-    #[prost(string, optional, tag = "4")]
-    pub dc_id: ::core::option::Option<::prost::alloc::string::String>,
-    #[prost(message, repeated, tag = "5")]
-    pub daily_results: ::prost::alloc::vec::Vec<DailyResults>,
-}
-#[derive(candid::CandidType, candid::Deserialize, Clone, PartialEq, ::prost::Message)]
-pub struct BaseRewards {
-    #[prost(message, optional, tag = "1")]
-    pub monthly_xdr_permyriad: ::core::option::Option<::ic_nervous_system_proto::pb::v1::Decimal>,
-    #[prost(message, optional, tag = "2")]
-    pub daily_xdr_permyriad: ::core::option::Option<::ic_nervous_system_proto::pb::v1::Decimal>,
-    #[prost(string, optional, tag = "3")]
-    pub node_reward_type: ::core::option::Option<::prost::alloc::string::String>,
-    #[prost(string, optional, tag = "4")]
-    pub region: ::core::option::Option<::prost::alloc::string::String>,
-}
-#[derive(candid::CandidType, candid::Deserialize, Clone, PartialEq, ::prost::Message)]
-pub struct DailyBaseRewardsType3 {
-    #[prost(message, optional, tag = "1")]
-    pub day: ::core::option::Option<DayUtc>,
-    #[prost(string, optional, tag = "2")]
-    pub region: ::core::option::Option<::prost::alloc::string::String>,
-    #[prost(uint64, optional, tag = "3")]
-    pub nodes_count: ::core::option::Option<u64>,
-    #[prost(message, optional, tag = "4")]
-    pub avg_rewards_xdr_permyriad:
-        ::core::option::Option<::ic_nervous_system_proto::pb::v1::Decimal>,
-    #[prost(message, optional, tag = "5")]
-    pub avg_coefficient_percent: ::core::option::Option<::ic_nervous_system_proto::pb::v1::Decimal>,
-    #[prost(message, optional, tag = "6")]
-    pub value_xdr_permyriad: ::core::option::Option<::ic_nervous_system_proto::pb::v1::Decimal>,
-}
-#[derive(candid::CandidType, candid::Deserialize, Clone, PartialEq, ::prost::Message)]
-pub struct NodeProviderRewards {
-    #[prost(uint64, optional, tag = "1")]
-    pub rewards_total_xdr_permyriad: ::core::option::Option<u64>,
-    #[prost(message, repeated, tag = "2")]
-    pub base_rewards: ::prost::alloc::vec::Vec<BaseRewards>,
-    #[prost(message, repeated, tag = "3")]
-    pub base_rewards_type3: ::prost::alloc::vec::Vec<DailyBaseRewardsType3>,
-    #[prost(message, repeated, tag = "4")]
-    pub nodes_results: ::prost::alloc::vec::Vec<NodeResults>,
-}
diff --git a/rs/node_rewards/canister/protobuf/src/lib.rs b/rs/node_rewards/canister/protobuf/src/lib.rs
deleted file mode 100644
index fa31b07d8f..0000000000
--- a/rs/node_rewards/canister/protobuf/src/lib.rs
+++ /dev/null
@@ -1,131 +0,0 @@
-use candid::Principal;
-use ic_base_types::PrincipalId;
-use ic_stable_structures::storable::Bound;
-use ic_stable_structures::Storable;
-use prost::Message;
-use std::borrow::Cow;
-
-pub mod conversions;
-pub mod pb;
-
-// Maximum sizes for the storable types chosen as result of test `max_bound_size`
-const MAX_BYTES_SUBNET_ID_STORED: u32 = 33;
-const MAX_BYTES_NODE_METRICS_STORED_KEY: u32 = 44;
-const PRINCIPAL_MAX_LENGTH_IN_BYTES: usize = 29;
-
-pub const MIN_PRINCIPAL_ID: PrincipalId = PrincipalId(Principal::from_slice(&[]));
-pub const MAX_PRINCIPAL_ID: PrincipalId = PrincipalId(Principal::from_slice(
-    &[0xFF_u8; PRINCIPAL_MAX_LENGTH_IN_BYTES],
-));
-
-pub trait KeyRange {
-    fn min_key() -> Self;
-    fn max_key() -> Self;
-}
-
-impl KeyRange for pb::ic_node_rewards::v1::SubnetMetricsKey {
-    fn min_key() -> Self {
-        Self {
-            timestamp_nanos: u64::MIN,
-            subnet_id: Some(MIN_PRINCIPAL_ID),
-        }
-    }
-
-    fn max_key() -> Self {
-        Self {
-            timestamp_nanos: u64::MAX,
-            subnet_id: Some(MAX_PRINCIPAL_ID),
-        }
-    }
-}
-
-//------------ Storable Implementations ------------//
-
-impl Storable for pb::ic_node_rewards::v1::SubnetIdKey {
-    fn to_bytes(&self) -> std::borrow::Cow<[u8]> {
-        let mut buf = Vec::with_capacity(self.encoded_len());
-        self.encode(&mut buf).unwrap();
-        Cow::Owned(self.encode_to_vec())
-    }
-
-    fn from_bytes(bytes: std::borrow::Cow<[u8]>) -> Self {
-        Self::decode(bytes.as_ref()).unwrap()
-    }
-
-    const BOUND: Bound = Bound::Bounded {
-        max_size: MAX_BYTES_SUBNET_ID_STORED,
-        is_fixed_size: false,
-    };
-}
-
-impl Storable for pb::ic_node_rewards::v1::SubnetMetricsKey {
-    fn to_bytes(&self) -> std::borrow::Cow<[u8]> {
-        Cow::Owned(self.encode_to_vec())
-    }
-
-    fn from_bytes(bytes: std::borrow::Cow<[u8]>) -> Self {
-        Self::decode(bytes.as_ref()).unwrap()
-    }
-
-    const BOUND: Bound = Bound::Bounded {
-        max_size: 2 * MAX_BYTES_NODE_METRICS_STORED_KEY,
-        is_fixed_size: false,
-    };
-}
-
-impl Storable for pb::ic_node_rewards::v1::SubnetMetricsValue {
-    fn to_bytes(&self) -> std::borrow::Cow<[u8]> {
-        Cow::Owned(self.encode_to_vec())
-    }
-
-    fn from_bytes(bytes: std::borrow::Cow<[u8]>) -> Self {
-        Self::decode(bytes.as_ref()).unwrap()
-    }
-
-    const BOUND: Bound = Bound::Unbounded;
-}
-
-impl Storable for pb::ic_node_rewards::v1::NodeMetrics {
-    fn to_bytes(&self) -> std::borrow::Cow<[u8]> {
-        Cow::Owned(self.encode_to_vec())
-    }
-    fn from_bytes(bytes: std::borrow::Cow<[u8]>) -> Self {
-        Self::decode(bytes.as_ref()).unwrap()
-    }
-    const BOUND: Bound = Bound::Unbounded;
-}
-
-impl Storable for pb::rewards_calculator::v1::NodeProviderRewards {
-    fn to_bytes(&self) -> std::borrow::Cow<[u8]> {
-        Cow::Owned(self.encode_to_vec())
-    }
-    fn from_bytes(bytes: std::borrow::Cow<[u8]>) -> Self {
-        Self::decode(bytes.as_ref()).unwrap()
-    }
-    const BOUND: Bound = Bound::Unbounded;
-}
-
-#[cfg(test)]
-mod tests {
-    use super::*;
-    #[test]
-    fn max_bound_size() {
-        let max_subnet_id_stored = pb::ic_node_rewards::v1::SubnetIdKey {
-            subnet_id: MAX_PRINCIPAL_ID.into(),
-        };
-        let max_subnet_metrics_stored_key = pb::ic_node_rewards::v1::SubnetMetricsKey {
-            timestamp_nanos: u64::MAX,
-            subnet_id: MAX_PRINCIPAL_ID.into(),
-        };
-
-        assert_eq!(
-            max_subnet_id_stored.to_bytes().len(),
-            MAX_BYTES_SUBNET_ID_STORED as usize
-        );
-
-        assert_eq!(
-            max_subnet_metrics_stored_key.to_bytes().len(),
-            MAX_BYTES_NODE_METRICS_STORED_KEY as usize
-        );
-    }
-}
diff --git a/rs/node_rewards/canister/protobuf/src/pb/ic_node_rewards/mod.rs b/rs/node_rewards/canister/protobuf/src/pb/ic_node_rewards/mod.rs
deleted file mode 100644
index 4aee645c2b..0000000000
--- a/rs/node_rewards/canister/protobuf/src/pb/ic_node_rewards/mod.rs
+++ /dev/null
@@ -1,3 +0,0 @@
-#[allow(clippy::all)]
-#[path = "../../gen/ic_node_rewards.pb.v1.rs"]
-pub mod v1;
diff --git a/rs/node_rewards/canister/protobuf/src/pb/mod.rs b/rs/node_rewards/canister/protobuf/src/pb/mod.rs
deleted file mode 100644
index 33a6a6d5c1..0000000000
--- a/rs/node_rewards/canister/protobuf/src/pb/mod.rs
+++ /dev/null
@@ -1,2 +0,0 @@
-pub mod ic_node_rewards;
-pub mod rewards_calculator;
diff --git a/rs/node_rewards/canister/protobuf/src/pb/rewards_calculator/mod.rs b/rs/node_rewards/canister/protobuf/src/pb/rewards_calculator/mod.rs
deleted file mode 100644
index eb31b78efd..0000000000
--- a/rs/node_rewards/canister/protobuf/src/pb/rewards_calculator/mod.rs
+++ /dev/null
@@ -1,3 +0,0 @@
-#[allow(clippy::all)]
-#[path = "../../gen/rewards_calculator.pb.v1.rs"]
-pub mod v1;
diff --git a/rs/node_rewards/canister/protobuf_generator/src/lib.rs b/rs/node_rewards/canister/protobuf_generator/src/lib.rs
index f6fd25e263..aa9d482d9a 100644
--- a/rs/node_rewards/canister/protobuf_generator/src/lib.rs
+++ b/rs/node_rewards/canister/protobuf_generator/src/lib.rs
@@ -4,64 +4,30 @@ use std::path::Path;
 pub struct ProtoPaths<'a> {
     pub base_types: &'a Path,
     pub node_rewards: &'a Path,
-    pub nervous_system: &'a Path,
+    pub node_proto: &'a Path,
 }
 
 /// Build protos using prost_build.
 pub fn generate_prost_files(proto: ProtoPaths<'_>, out: &Path) {
-    let proto_files = [
-        proto.node_rewards.join("node_rewards/pb/v1/types.proto"),
-        proto
-            .node_rewards
-            .join("rewards_calculator/pb/v1/types.proto"),
-    ];
+    let proto_files = [proto.node_rewards.join("node_rewards/pb/v1/types.proto")];
 
     let mut config = Config::new();
     config.extern_path(".ic_base_types.pb.v1", "::ic-base-types");
-    config.extern_path(
-        ".ic_nervous_system.pb.v1",
-        "::ic-nervous-system-proto::pb::v1",
-    );
+    config.extern_path(".registry.node.v1", "::ic-protobuf::registry::node::v1");
 
-    for message_name in ["SubnetIdKey", "SubnetMetricsKey"] {
+    for message_name in ["SubnetIdKey", "SubnetMetricsKey", "RewardableNodesKey"] {
         config.type_attribute(
             format!("ic_node_rewards.pb.v1.{message_name}"),
             ["#[derive(PartialOrd, Ord, Eq)]"].join(" "),
         );
     }
 
-    for message_name in ["NodeProviderRewardsKey", "DayUtc", "SubnetsFailureRateKey"] {
-        config.type_attribute(
-            format!("rewards_calculator.pb.v1.{message_name}"),
-            ["#[derive(PartialOrd, Ord, Eq)]"].join(" "),
-        );
-    }
-
-    for message_name in [
-        "DayUtc",
-        "NodeMetricsDaily",
-        "Assigned",
-        "Unassigned",
-        "NodeStatus.status",
-        "NodeStatus",
-        "DailyResults",
-        "NodeResults",
-        "BaseRewards",
-        "DailyBaseRewardsType3",
-        "NodeProviderRewards",
-    ] {
-        config.type_attribute(
-            format!("rewards_calculator.pb.v1.{message_name}"),
-            ["#[derive(candid::CandidType, candid::Deserialize)]"].join(" "),
-        );
-    }
-
     std::fs::create_dir_all(out).expect("failed to create output directory");
     config.out_dir(out);
     config
         .compile_protos(
             &proto_files,
-            &[proto.node_rewards, proto.base_types, proto.nervous_system],
+            &[proto.node_rewards, proto.base_types, proto.node_proto],
         )
         .unwrap();
 
diff --git a/rs/node_rewards/canister/protobuf_generator/src/main.rs b/rs/node_rewards/canister/protobuf_generator/src/main.rs
index 5ad5cce89e..8bc35247d6 100644
--- a/rs/node_rewards/canister/protobuf_generator/src/main.rs
+++ b/rs/node_rewards/canister/protobuf_generator/src/main.rs
@@ -6,10 +6,10 @@ fn main() {
         std::env::var("CARGO_MANIFEST_DIR")
             .expect("CARGO_MANIFEST_DIR env variable is not defined"),
     );
-    let out = manifest_dir.join("../protobuf/src/gen");
+    let out = manifest_dir.join("../src/gen");
     let node_rewards_proto = manifest_dir.join("../proto");
     let base_types_proto = manifest_dir.join("../../../types/base_types/proto");
-    let nervous_system_proto = manifest_dir.join("../../../nervous_system/proto/proto");
+    let node_proto = manifest_dir.join("../../../protobuf");
 
     match std::fs::remove_dir_all(&out) {
         Ok(_) => (),
@@ -24,7 +24,7 @@ fn main() {
         ProtoPaths {
             node_rewards: &node_rewards_proto,
             base_types: &base_types_proto,
-            nervous_system: &nervous_system_proto,
+            node_proto: &node_proto,
         },
         out.as_ref(),
     );
diff --git a/rs/node_rewards/canister/src/api_conversion.rs b/rs/node_rewards/canister/src/api_conversion.rs
new file mode 100644
index 0000000000..6c2a12443a
--- /dev/null
+++ b/rs/node_rewards/canister/src/api_conversion.rs
@@ -0,0 +1,83 @@
+use ic_node_rewards_canister_api::provider_rewards_calculation::{
+    node_status::Status as StatusCandid, Assigned as AssignedCandid,
+    BaseRewards as BaseRewardsCandid, DailyBaseRewardsType3 as DailyBaseRewardsType3Candid,
+    DailyResults as DailyResultsCandid, DayUtc as DayUtcCandid,
+    NodeMetricsDaily as NodeMetricsDailyCandid, NodeProviderRewards as NodeProviderRewardsCandid,
+    NodeResults as NodeResultsCandid, NodeStatus as NodeStatusCandid,
+    Unassigned as UnassignedCandid,
+};
+use rewards_calculation::rewards_calculator_results::{NodeProviderRewards, NodeStatus};
+
+pub fn to_candid_type(rewards: NodeProviderRewards) -> NodeProviderRewardsCandid {
+    NodeProviderRewardsCandid {
+        rewards_total_xdr_permyriad: Some(rewards.rewards_total_xdr_permyriad),
+        base_rewards: rewards
+            .base_rewards
+            .into_iter()
+            .map(|br| BaseRewardsCandid {
+                node_reward_type: Some(br.node_reward_type.to_string()),
+                region: Some(br.region),
+                monthly_xdr_permyriad: Some(br.monthly.into()),
+                daily_xdr_permyriad: Some(br.daily.into()),
+            })
+            .collect(),
+        base_rewards_type3: rewards
+            .base_rewards_type3
+            .into_iter()
+            .map(|br3| DailyBaseRewardsType3Candid {
+                day: Some(DayUtcCandid {
+                    value: Some(br3.day.unix_ts_at_day_end()),
+                }),
+                region: Some(br3.region),
+                nodes_count: Some(br3.nodes_count as u64),
+                avg_rewards_xdr_permyriad: Some(br3.avg_rewards.into()),
+                avg_coefficient_percent: Some(br3.avg_coefficient.into()),
+                value_xdr_permyriad: Some(br3.value.into()),
+            })
+            .collect(),
+        nodes_results: rewards
+            .nodes_results
+            .into_iter()
+            .map(|nr| NodeResultsCandid {
+                node_id: Some(nr.node_id.get()),
+                node_reward_type: Some(nr.node_reward_type.to_string()),
+                region: Some(nr.region),
+                dc_id: Some(nr.dc_id),
+                daily_results: nr
+                    .daily_results
+                    .into_iter()
+                    .map(|dr| DailyResultsCandid {
+                        day: Some(DayUtcCandid {
+                            value: Some(dr.day.unix_ts_at_day_end()),
+                        }),
+                        node_status: match dr.node_status {
+                            NodeStatus::Assigned { node_metrics } => Some(NodeStatusCandid {
+                                status: Some(StatusCandid::Assigned(AssignedCandid {
+                                    node_metrics: Some(NodeMetricsDailyCandid {
+                                        subnet_assigned: Some(node_metrics.subnet_assigned.get()),
+                                        subnet_assigned_fr_percent: Some(
+                                            node_metrics.subnet_assigned_fr.into(),
+                                        ),
+                                        num_blocks_proposed: Some(node_metrics.num_blocks_proposed),
+                                        num_blocks_failed: Some(node_metrics.num_blocks_failed),
+                                        original_fr_percent: Some(node_metrics.original_fr.into()),
+                                        relative_fr_percent: Some(node_metrics.relative_fr.into()),
+                                    }),
+                                })),
+                            }),
+                            NodeStatus::Unassigned { extrapolated_fr } => Some(NodeStatusCandid {
+                                status: Some(StatusCandid::Unassigned(UnassignedCandid {
+                                    extrapolated_fr_percent: Some(extrapolated_fr.into()),
+                                })),
+                            }),
+                        },
+                        performance_multiplier_percent: Some(dr.performance_multiplier.into()),
+                        rewards_reduction_percent: Some(dr.rewards_reduction.into()),
+                        base_rewards_xdr_permyriad: Some(dr.base_rewards.into()),
+                        adjusted_rewards_xdr_permyriad: Some(dr.adjusted_rewards.into()),
+                    })
+                    .collect(),
+            })
+            .collect(),
+    }
+}
diff --git a/rs/node_rewards/canister/src/canister/mod.rs b/rs/node_rewards/canister/src/canister/mod.rs
index 4e0678d8ad..c0bec07e99 100644
--- a/rs/node_rewards/canister/src/canister/mod.rs
+++ b/rs/node_rewards/canister/src/canister/mod.rs
@@ -1,3 +1,4 @@
+use crate::api_conversion::to_candid_type;
 use crate::metrics::MetricsManager;
 use crate::registry_querier::RegistryQuerier;
 use crate::storage::VM;
@@ -271,7 +272,7 @@ impl NodeRewardsCanister {
             provider_id
         ))?;
 
-        Ok(node_provider_rewards.into())
+        Ok(to_candid_type(node_provider_rewards))
     }
 }
 
diff --git a/rs/node_rewards/canister/src/canister/test/get_node_providers_rewards.rs b/rs/node_rewards/canister/src/canister/test/get_node_providers_rewards.rs
index 7a81171f1b..eb3db428bf 100644
--- a/rs/node_rewards/canister/src/canister/test/get_node_providers_rewards.rs
+++ b/rs/node_rewards/canister/src/canister/test/get_node_providers_rewards.rs
@@ -1,17 +1,16 @@
+use crate::api_conversion::to_candid_type;
 use crate::canister::test::test_utils::{
     setup_thread_local_canister_for_test, TestState, CANISTER_TEST, VM,
 };
 use crate::canister::NodeRewardsCanister;
 use crate::metrics::MetricsManager;
+use crate::pb::v1::{NodeMetrics, SubnetMetricsKey, SubnetMetricsValue};
 use futures_util::FutureExt;
 use ic_nervous_system_canisters::registry::fake::FakeRegistry;
 use ic_node_rewards_canister_api::provider_rewards_calculation::GetNodeProviderRewardsCalculationRequest;
 use ic_node_rewards_canister_api::providers_rewards::{
     GetNodeProvidersRewardsRequest, NodeProvidersRewards,
 };
-use ic_node_rewards_canister_protobuf::pb::ic_node_rewards::v1::{
-    NodeMetrics, SubnetMetricsKey, SubnetMetricsValue,
-};
 use ic_protobuf::registry::dc::v1::DataCenterRecord;
 use ic_protobuf::registry::node::v1::{NodeRecord, NodeRewardType};
 use ic_protobuf::registry::node_operator::v1::NodeOperatorRecord;
@@ -663,7 +662,7 @@ fn test_get_node_provider_rewards_calculation_historical() {
 
         assert_eq!(
             got,
-            expected_rewards.into(),
+            to_candid_type(expected_rewards),
             "Mismatch for provider {:?}",
             provider_id
         );
diff --git a/rs/node_rewards/canister/protobuf/src/gen/ic_node_rewards.pb.v1.rs b/rs/node_rewards/canister/src/gen/ic_node_rewards.pb.v1.rs
similarity index 100%
rename from rs/node_rewards/canister/protobuf/src/gen/ic_node_rewards.pb.v1.rs
rename to rs/node_rewards/canister/src/gen/ic_node_rewards.pb.v1.rs
diff --git a/rs/node_rewards/canister/src/lib.rs b/rs/node_rewards/canister/src/lib.rs
index 9d51126275..37cb0670d6 100644
--- a/rs/node_rewards/canister/src/lib.rs
+++ b/rs/node_rewards/canister/src/lib.rs
@@ -5,8 +5,162 @@
 // 4. Structure makes boundaries clear and easy to enforce
 // 5. Simple Organization
 
+use candid::Principal;
+use ic_base_types::{PrincipalId, SubnetId};
+use ic_management_canister_types::NodeMetrics;
+use ic_stable_structures::storable::Bound;
+use ic_stable_structures::Storable;
+use prost::Message;
+use rewards_calculation::types::SubnetMetricsDailyKey;
+use std::borrow::Cow;
+
+pub mod api_conversion;
 pub mod canister;
 pub mod metrics;
+pub mod pb;
 pub mod registry_querier;
 pub mod storage;
 pub mod telemetry;
+
+// Maximum sizes for the storable types chosen as result of test `max_bound_size`
+const MAX_BYTES_SUBNET_ID_STORED: u32 = 33;
+const MAX_BYTES_NODE_METRICS_STORED_KEY: u32 = 44;
+const PRINCIPAL_MAX_LENGTH_IN_BYTES: usize = 29;
+
+pub const MIN_PRINCIPAL_ID: PrincipalId = PrincipalId(Principal::from_slice(&[]));
+pub const MAX_PRINCIPAL_ID: PrincipalId = PrincipalId(Principal::from_slice(
+    &[0xFF_u8; PRINCIPAL_MAX_LENGTH_IN_BYTES],
+));
+
+pub trait KeyRange {
+    fn min_key() -> Self;
+    fn max_key() -> Self;
+}
+
+impl KeyRange for pb::v1::SubnetMetricsKey {
+    fn min_key() -> Self {
+        Self {
+            timestamp_nanos: u64::MIN,
+            subnet_id: Some(MIN_PRINCIPAL_ID),
+        }
+    }
+
+    fn max_key() -> Self {
+        Self {
+            timestamp_nanos: u64::MAX,
+            subnet_id: Some(MAX_PRINCIPAL_ID),
+        }
+    }
+}
+
+//------------ Storable Implementations ------------//
+
+impl Storable for pb::v1::SubnetIdKey {
+    fn to_bytes(&self) -> std::borrow::Cow<[u8]> {
+        Cow::Owned(self.encode_to_vec())
+    }
+
+    fn from_bytes(bytes: std::borrow::Cow<[u8]>) -> Self {
+        Self::decode(bytes.as_ref()).unwrap()
+    }
+
+    const BOUND: Bound = Bound::Bounded {
+        max_size: MAX_BYTES_SUBNET_ID_STORED,
+        is_fixed_size: false,
+    };
+}
+
+impl Storable for pb::v1::SubnetMetricsKey {
+    fn to_bytes(&self) -> std::borrow::Cow<[u8]> {
+        Cow::Owned(self.encode_to_vec())
+    }
+
+    fn from_bytes(bytes: std::borrow::Cow<[u8]>) -> Self {
+        Self::decode(bytes.as_ref()).unwrap()
+    }
+
+    const BOUND: Bound = Bound::Bounded {
+        max_size: 2 * MAX_BYTES_NODE_METRICS_STORED_KEY,
+        is_fixed_size: false,
+    };
+}
+
+impl Storable for pb::v1::SubnetMetricsValue {
+    fn to_bytes(&self) -> std::borrow::Cow<[u8]> {
+        Cow::Owned(self.encode_to_vec())
+    }
+
+    fn from_bytes(bytes: std::borrow::Cow<[u8]>) -> Self {
+        Self::decode(bytes.as_ref()).unwrap()
+    }
+
+    const BOUND: Bound = Bound::Unbounded;
+}
+
+impl Storable for pb::v1::NodeMetrics {
+    fn to_bytes(&self) -> std::borrow::Cow<[u8]> {
+        Cow::Owned(self.encode_to_vec())
+    }
+    fn from_bytes(bytes: std::borrow::Cow<[u8]>) -> Self {
+        Self::decode(bytes.as_ref()).unwrap()
+    }
+    const BOUND: Bound = Bound::Unbounded;
+}
+
+impl From<SubnetId> for pb::v1::SubnetIdKey {
+    fn from(subnet_id: SubnetId) -> Self {
+        Self {
+            subnet_id: Some(subnet_id.get()),
+        }
+    }
+}
+
+impl From<pb::v1::SubnetIdKey> for SubnetId {
+    fn from(subnet_id: pb::v1::SubnetIdKey) -> Self {
+        subnet_id.subnet_id.unwrap().into()
+    }
+}
+
+impl From<pb::v1::SubnetMetricsKey> for SubnetMetricsDailyKey {
+    fn from(key: pb::v1::SubnetMetricsKey) -> Self {
+        Self {
+            day: key.timestamp_nanos.into(),
+            subnet_id: SubnetId::from(key.subnet_id.unwrap()),
+        }
+    }
+}
+
+impl From<NodeMetrics> for pb::v1::NodeMetrics {
+    fn from(metrics: NodeMetrics) -> Self {
+        pb::v1::NodeMetrics {
+            node_id: Some(metrics.node_id.into()),
+            num_blocks_proposed_total: metrics.num_blocks_proposed_total,
+            num_blocks_failed_total: metrics.num_block_failures_total,
+        }
+    }
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+    #[test]
+    fn max_bound_size() {
+        let max_subnet_id_stored = pb::v1::SubnetIdKey {
+            subnet_id: MAX_PRINCIPAL_ID.into(),
+        };
+        let max_subnet_metrics_stored_key = pb::v1::SubnetMetricsKey {
+            timestamp_nanos: u64::MAX,
+            subnet_id: MAX_PRINCIPAL_ID.into(),
+        };
+
+        assert_eq!(
+            max_subnet_id_stored.to_bytes().len(),
+            MAX_BYTES_SUBNET_ID_STORED as usize
+        );
+
+        assert_eq!(
+            max_subnet_metrics_stored_key.to_bytes().len(),
+            MAX_BYTES_NODE_METRICS_STORED_KEY as usize
+        );
+    }
+}
diff --git a/rs/node_rewards/canister/src/metrics.rs b/rs/node_rewards/canister/src/metrics.rs
index ad76fa378e..8d9c7a6629 100644
--- a/rs/node_rewards/canister/src/metrics.rs
+++ b/rs/node_rewards/canister/src/metrics.rs
@@ -1,13 +1,11 @@
 #![allow(deprecated)]
+use crate::pb::v1::{SubnetIdKey, SubnetMetricsKey, SubnetMetricsValue};
+use crate::KeyRange;
 use async_trait::async_trait;
 use candid::Principal;
 use ic_base_types::{NodeId, SubnetId};
 use ic_cdk::api::call::CallResult;
 use ic_management_canister_types::{NodeMetricsHistoryArgs, NodeMetricsHistoryRecord};
-use ic_node_rewards_canister_protobuf::pb::ic_node_rewards::v1::{
-    SubnetIdKey, SubnetMetricsKey, SubnetMetricsValue,
-};
-use ic_node_rewards_canister_protobuf::KeyRange;
 use ic_stable_structures::StableBTreeMap;
 use itertools::Itertools;
 use rewards_calculation::types::{DayUtc, NodeMetricsDailyRaw, SubnetMetricsDailyKey, UnixTsNanos};
diff --git a/rs/node_rewards/canister/src/metrics/tests.rs b/rs/node_rewards/canister/src/metrics/tests.rs
index 5870caa275..5813510bfc 100644
--- a/rs/node_rewards/canister/src/metrics/tests.rs
+++ b/rs/node_rewards/canister/src/metrics/tests.rs
@@ -1,8 +1,8 @@
 use crate::metrics::{MetricsManager, UnixTsNanos};
+use crate::pb::v1::SubnetMetricsKey;
 use ic_base_types::{NodeId, PrincipalId, SubnetId};
 use ic_cdk::api::call::{CallResult, RejectionCode};
 use ic_management_canister_types::{NodeMetrics, NodeMetricsHistoryArgs, NodeMetricsHistoryRecord};
-use ic_node_rewards_canister_protobuf::pb::ic_node_rewards::v1::SubnetMetricsKey;
 use ic_stable_structures::memory_manager::{MemoryId, VirtualMemory};
 use ic_stable_structures::DefaultMemoryImpl;
 use rewards_calculation::types::{DayUtc, NodeMetricsDailyRaw};
diff --git a/rs/node_rewards/canister/src/pb/mod.rs b/rs/node_rewards/canister/src/pb/mod.rs
new file mode 100644
index 0000000000..7982e71834
--- /dev/null
+++ b/rs/node_rewards/canister/src/pb/mod.rs
@@ -0,0 +1,3 @@
+#[allow(clippy::all)]
+#[path = "../gen/ic_node_rewards.pb.v1.rs"]
+pub mod v1;
```

---

### Commit `c4bf3da835f3407818b706cf2f7ae4485c7e032f`

**Author:** mraszyk <31483726+mraszyk@users.noreply.github.com>  
**Date:** 2025-09-10  
**Message:** chore(PocketIC): replace EmptyConfig by better readable enumerations (#6630)

**Files Changed:**
- `rs/node_rewards/canister/tests/get_node_providers_monthly_xdr_rewards.rs`

**Code Changes:**

```diff
commit c4bf3da835f3407818b706cf2f7ae4485c7e032f
Author: mraszyk <31483726+mraszyk@users.noreply.github.com>
Date:   Wed Sep 10 11:37:13 2025 +0200

    chore(PocketIC): replace EmptyConfig by better readable enumerations (#6630)
    
    This PR replaces `EmptyConfig` in PocketIC public types with better
    readable enumerations that are less confusing to developers. It also
    renames nonmainnet features to ICP config.

diff --git a/rs/node_rewards/canister/tests/get_node_providers_monthly_xdr_rewards.rs b/rs/node_rewards/canister/tests/get_node_providers_monthly_xdr_rewards.rs
index bfdb6e3d32..fb5983a549 100644
--- a/rs/node_rewards/canister/tests/get_node_providers_monthly_xdr_rewards.rs
+++ b/rs/node_rewards/canister/tests/get_node_providers_monthly_xdr_rewards.rs
@@ -8,14 +8,14 @@ use ic_node_rewards_canister_api::provider_rewards_calculation::{
     GetNodeProviderRewardsCalculationRequest, GetNodeProviderRewardsCalculationResponse,
 };
 use ic_types::PrincipalId;
-use pocket_ic::common::rest::{EmptyConfig, IcpFeatures};
+use pocket_ic::common::rest::{IcpFeatures, IcpFeaturesConfig};
 use pocket_ic::nonblocking::{query_candid, update_candid, PocketIc};
 use pocket_ic::PocketIcBuilder;
 use std::time::Duration;
 
 async fn setup_env() -> PocketIc {
     let icp_features = IcpFeatures {
-        registry: Some(EmptyConfig {}),
+        registry: Some(IcpFeaturesConfig::DefaultConfig),
         ..Default::default()
     };
     let pocket_ic = PocketIcBuilder::new()
```

---

### Commit `db65a720ff4db47302d04d426e9abc414e73774b`

**Author:** pietrodimarco-dfinity <124565147+pietrodimarco-dfinity@users.noreply.github.com>  
**Date:** 2025-09-06  
**Message:** chore(nns): Release notes (#6532)

**Files Changed:**
- `rs/node_rewards/canister/CHANGELOG.md`

**Code Changes:**

```diff
commit db65a720ff4db47302d04d426e9abc414e73774b
Author: pietrodimarco-dfinity <124565147+pietrodimarco-dfinity@users.noreply.github.com>
Date:   Sat Sep 6 07:47:11 2025 +0200

    chore(nns): Release notes (#6532)
    
    Release notes for submitted proposals:
    
    https://dashboard.internetcomputer.org/proposal/138288

diff --git a/rs/node_rewards/canister/CHANGELOG.md b/rs/node_rewards/canister/CHANGELOG.md
index a0347f0adc..0ec4c84f0d 100644
--- a/rs/node_rewards/canister/CHANGELOG.md
+++ b/rs/node_rewards/canister/CHANGELOG.md
@@ -2,6 +2,21 @@
 
 INSERT NEW RELEASES HERE
 
+# 2025-08-30: Proposal 138288
+
+http://dashboard.internetcomputer.org/proposal/138288
+
+## Added
+
+* Add get_node_providers_rewards endpoint, to be used by the Governance to compute performance-based rewards.
+* Store rewards (including intermediate results) in stable memory for client retrieval.
+* Add get_node_provider_rewards_calculation endpoint to compute ongoing rewards and fetch historical ones.
+* Add get_historical_reward_periods endpoint to fetch historical reward periods and the providers rewarded.
+
+## Fixed
+
+* Fix rewards calculation algorithm to extrapolate with 0% failure rate node's performance for node providers with no
+  assigned nodes on a given day.
 * Replicated execution of the query endpoints `get_node_provider_rewards_calculation` and `get_historical_reward_periods`
   is disabled.
```

---

